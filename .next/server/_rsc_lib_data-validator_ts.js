"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_data-validator_ts";
exports.ids = ["_rsc_lib_data-validator_ts"];
exports.modules = {

/***/ "(rsc)/./lib/adaptive-data-validator.ts":
/*!****************************************!*\
  !*** ./lib/adaptive-data-validator.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdaptiveDataValidator: () => (/* binding */ AdaptiveDataValidator)\n/* harmony export */ });\n// Enhanced Data Validator with Adaptive Template System\n// This system learns from uploaded files and creates flexible mappings\nclass AdaptiveDataValidator {\n    static{\n        // Comprehensive keyword patterns for different business data types\n        this.COLUMN_PATTERNS = {\n            // Geographic/Location patterns\n            geographic: [\n                \"state\",\n                \"region\",\n                \"city\",\n                \"zip\",\n                \"postal\",\n                \"country\",\n                \"location\",\n                \"address\",\n                \"facility\",\n                \"warehouse\",\n                \"dc\",\n                \"distribution\",\n                \"center\",\n                \"site\",\n                \"branch\"\n            ],\n            // Financial patterns\n            financial: [\n                \"cost\",\n                \"price\",\n                \"amount\",\n                \"revenue\",\n                \"sales\",\n                \"expense\",\n                \"budget\",\n                \"profit\",\n                \"total\",\n                \"value\",\n                \"dollar\",\n                \"usd\",\n                \"currency\",\n                \"invoice\",\n                \"payment\",\n                \"billing\"\n            ],\n            // Quantity/Volume patterns\n            quantity: [\n                \"quantity\",\n                \"qty\",\n                \"count\",\n                \"volume\",\n                \"units\",\n                \"pieces\",\n                \"each\",\n                \"tons\",\n                \"pounds\",\n                \"kg\",\n                \"weight\",\n                \"capacity\",\n                \"throughput\",\n                \"demand\"\n            ],\n            // Performance/Metrics patterns\n            performance: [\n                \"percentage\",\n                \"percent\",\n                \"ratio\",\n                \"rate\",\n                \"accuracy\",\n                \"efficiency\",\n                \"utilization\",\n                \"performance\",\n                \"metric\",\n                \"kpi\",\n                \"score\",\n                \"index\",\n                \"otd\",\n                \"delivery\"\n            ],\n            // Date/Time patterns\n            temporal: [\n                \"date\",\n                \"time\",\n                \"year\",\n                \"month\",\n                \"week\",\n                \"day\",\n                \"period\",\n                \"quarter\",\n                \"created\",\n                \"updated\",\n                \"modified\",\n                \"start\",\n                \"end\",\n                \"due\"\n            ],\n            // Identifier patterns\n            identifier: [\n                \"id\",\n                \"number\",\n                \"code\",\n                \"ref\",\n                \"reference\",\n                \"sku\",\n                \"part\",\n                \"item\",\n                \"order\",\n                \"invoice\",\n                \"po\",\n                \"tracking\",\n                \"serial\"\n            ],\n            // Name/Description patterns\n            descriptive: [\n                \"name\",\n                \"description\",\n                \"title\",\n                \"label\",\n                \"category\",\n                \"type\",\n                \"class\",\n                \"group\",\n                \"segment\",\n                \"channel\",\n                \"method\",\n                \"mode\"\n            ],\n            // Operational specific patterns\n            operational: [\n                \"shipment\",\n                \"freight\",\n                \"carrier\",\n                \"route\",\n                \"delivery\",\n                \"receiving\",\n                \"inventory\",\n                \"stock\",\n                \"fulfillment\",\n                \"processing\",\n                \"handling\"\n            ]\n        };\n    }\n    static{\n        // Business context mappings for categorization\n        this.BUSINESS_CONTEXTS = {\n            networkFootprint: [\n                \"facility\",\n                \"warehouse\",\n                \"dc\",\n                \"capacity\",\n                \"sqft\",\n                \"space\",\n                \"dock\",\n                \"doors\"\n            ],\n            orderManagement: [\n                \"order\",\n                \"customer\",\n                \"shipment\",\n                \"delivery\",\n                \"fulfillment\"\n            ],\n            inventory: [\n                \"inventory\",\n                \"stock\",\n                \"sku\",\n                \"units\",\n                \"throughput\",\n                \"turns\"\n            ],\n            financialOperations: [\n                \"cost\",\n                \"expense\",\n                \"budget\",\n                \"revenue\",\n                \"profit\",\n                \"pricing\"\n            ],\n            salesGrowth: [\n                \"sales\",\n                \"growth\",\n                \"forecast\",\n                \"demand\",\n                \"projection\",\n                \"historical\"\n            ],\n            performance: [\n                \"accuracy\",\n                \"efficiency\",\n                \"otd\",\n                \"quality\",\n                \"utilization\",\n                \"metrics\"\n            ]\n        };\n    }\n    /**\n   * Analyze column structure and content to understand data patterns\n   */ static analyzeColumns(data) {\n        if (!data || data.length === 0) return [];\n        const columns = Object.keys(data[0] || {});\n        const analyses = [];\n        for (const columnName of columns){\n            const values = data.map((row)=>row[columnName]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            const sampleValues = values.slice(0, Math.min(10, values.length));\n            const nullCount = data.length - values.length;\n            // Type detection\n            const detectedType = this.detectColumnType(values);\n            // Pattern analysis\n            const patternAnalysis = this.analyzeColumnPatterns(columnName, sampleValues);\n            analyses.push({\n                columnName,\n                sampleValues,\n                detectedType,\n                nullCount,\n                uniqueValues: new Set(values).size,\n                avgLength: this.calculateAverageLength(values),\n                containsNumbers: this.containsNumbers(values),\n                containsDates: this.containsDates(values),\n                patternAnalysis\n            });\n        }\n        return analyses;\n    }\n    /**\n   * Create adaptive template from file analysis\n   */ static createAdaptiveTemplate(fileName, data, columnAnalysis) {\n        const dataPatterns = this.detectDataPatterns(columnAnalysis);\n        const suggestedMappings = this.generateColumnMappings(columnAnalysis, fileName);\n        // Calculate overall confidence based on pattern matches\n        const confidence = this.calculateTemplateConfidence(suggestedMappings);\n        return {\n            id: `adaptive_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            name: `Adaptive Template for ${fileName}`,\n            description: `Auto-generated template based on analysis of ${fileName}`,\n            confidence,\n            sourceFileName: fileName,\n            columnAnalysis,\n            suggestedMappings,\n            dataPatterns\n        };\n    }\n    /**\n   * Process data using adaptive template with flexible validation\n   */ static processWithAdaptiveTemplate(data, adaptiveTemplate) {\n        const errors = [];\n        const warnings = [];\n        const validationResults = [];\n        const processedData = [];\n        let validRows = 0;\n        let skippedRows = 0;\n        // Group mappings by target category\n        const mappingsByCategory = this.groupMappingsByCategory(adaptiveTemplate.suggestedMappings);\n        for(let rowIndex = 0; rowIndex < data.length; rowIndex++){\n            const row = data[rowIndex];\n            const processedRow = {};\n            let isValidRow = true;\n            let hasAnyData = false;\n            // Process each mapping with flexible validation\n            for (const mapping of adaptiveTemplate.suggestedMappings){\n                const sourceValue = row[mapping.sourceColumn];\n                if (sourceValue !== null && sourceValue !== undefined && sourceValue !== \"\") {\n                    hasAnyData = true;\n                    // Flexible validation - attempt to clean and convert data\n                    const cleanedValue = this.cleanValue(sourceValue, mapping.targetField);\n                    const validation = this.flexibleValidation(cleanedValue, mapping);\n                    validationResults.push(validation);\n                    if (!validation.isValid) {\n                        warnings.push(`Row ${rowIndex + 1}, Field '${mapping.targetField}': ${validation.errorMessage}`);\n                    // Don't mark row as invalid for minor issues, just log warning\n                    } else {\n                        processedRow[mapping.targetField] = validation.value;\n                    }\n                }\n            }\n            // Only skip rows that have no useful data at all\n            if (!hasAnyData) {\n                skippedRows++;\n                continue;\n            }\n            if (isValidRow || Object.keys(processedRow).length > 0) {\n                processedData.push(processedRow);\n                validRows++;\n            } else {\n                skippedRows++;\n            }\n        }\n        // Build comprehensive data structure\n        const comprehensiveData = this.buildComprehensiveData(processedData, mappingsByCategory);\n        // Calculate flexible data quality metrics\n        const dataQuality = this.calculateFlexibleDataQuality(data, validationResults, adaptiveTemplate);\n        return {\n            success: validRows > 0,\n            data: comprehensiveData,\n            errors,\n            warnings,\n            summary: {\n                totalRows: data.length,\n                validRows,\n                skippedRows,\n                dataQuality\n            }\n        };\n    }\n    // Helper methods for data analysis\n    static detectColumnType(values) {\n        if (values.length === 0) return \"string\";\n        const types = new Set();\n        for (const value of values.slice(0, 20)){\n            if (typeof value === \"number\" || !isNaN(Number(value)) && !isNaN(parseFloat(value))) {\n                types.add(\"number\");\n            } else if (this.isDateLike(value)) {\n                types.add(\"date\");\n            } else if (typeof value === \"boolean\" || [\n                \"true\",\n                \"false\",\n                \"1\",\n                \"0\",\n                \"yes\",\n                \"no\"\n            ].includes(String(value).toLowerCase())) {\n                types.add(\"boolean\");\n            } else {\n                types.add(\"string\");\n            }\n        }\n        if (types.size > 1) return \"mixed\";\n        return Array.from(types)[0];\n    }\n    static analyzeColumnPatterns(columnName, sampleValues) {\n        const name = columnName.toLowerCase();\n        return {\n            likelyId: this.matchesPatterns(name, this.COLUMN_PATTERNS.identifier),\n            likelyName: this.matchesPatterns(name, this.COLUMN_PATTERNS.descriptive),\n            likelyAddress: this.matchesPatterns(name, this.COLUMN_PATTERNS.geographic),\n            likelyAmount: this.matchesPatterns(name, this.COLUMN_PATTERNS.financial),\n            likelyDate: this.matchesPatterns(name, this.COLUMN_PATTERNS.temporal) || this.containsDates(sampleValues),\n            likelyCategory: this.matchesPatterns(name, this.COLUMN_PATTERNS.descriptive),\n            likelyQuantity: this.matchesPatterns(name, this.COLUMN_PATTERNS.quantity),\n            likelyPercentage: name.includes(\"percent\") || name.includes(\"%\") || sampleValues.some((v)=>String(v).includes(\"%\"))\n        };\n    }\n    static matchesPatterns(text, patterns) {\n        return patterns.some((pattern)=>text.includes(pattern));\n    }\n    static detectDataPatterns(columnAnalysis) {\n        const columns = columnAnalysis.map((c)=>c.columnName.toLowerCase()).join(\" \");\n        return {\n            hasGeographicData: this.matchesPatterns(columns, this.COLUMN_PATTERNS.geographic),\n            hasFinancialData: this.matchesPatterns(columns, this.COLUMN_PATTERNS.financial),\n            hasDateSequences: columnAnalysis.some((c)=>c.patternAnalysis.likelyDate),\n            hasQuantities: this.matchesPatterns(columns, this.COLUMN_PATTERNS.quantity),\n            hasCategories: this.matchesPatterns(columns, this.COLUMN_PATTERNS.descriptive),\n            hasPerformanceMetrics: this.matchesPatterns(columns, this.COLUMN_PATTERNS.performance)\n        };\n    }\n    static generateColumnMappings(columnAnalysis, fileName) {\n        const mappings = [];\n        for (const column of columnAnalysis){\n            const mapping = this.inferColumnMapping(column, fileName);\n            if (mapping) {\n                mappings.push(mapping);\n            }\n        }\n        return mappings;\n    }\n    static inferColumnMapping(column, fileName) {\n        const name = column.columnName.toLowerCase();\n        const fileContext = fileName.toLowerCase();\n        // Determine target category based on file name and column patterns\n        let targetCategory;\n        let targetSubcategory;\n        let targetField;\n        let confidence = 0;\n        let reasoning = \"\";\n        // Category inference logic\n        if (this.matchesPatterns(fileContext, [\n            \"budget\",\n            \"expense\",\n            \"cost\",\n            \"financial\"\n        ]) || column.patternAnalysis.likelyAmount) {\n            targetCategory = \"businessFinancials\";\n            targetSubcategory = \"costFinancialData\";\n            confidence += 0.3;\n            reasoning += \"Financial context detected; \";\n        } else if (this.matchesPatterns(fileContext, [\n            \"sales\",\n            \"growth\",\n            \"forecast\",\n            \"demand\"\n        ]) || this.matchesPatterns(name, [\n            \"sales\",\n            \"revenue\",\n            \"forecast\",\n            \"demand\"\n        ])) {\n            targetCategory = \"salesGrowthTrajectory\";\n            targetSubcategory = \"historicalSalesData\";\n            confidence += 0.3;\n            reasoning += \"Sales/growth context detected; \";\n        } else {\n            targetCategory = \"operationalReporting\";\n            targetSubcategory = this.determineOperationalSubcategory(column, fileContext);\n            confidence += 0.2;\n            reasoning += \"Operational context detected; \";\n        }\n        // Field name mapping with flexible matching\n        targetField = this.mapToTargetField(column, targetCategory, targetSubcategory);\n        // Confidence scoring\n        if (column.patternAnalysis.likelyAmount && targetCategory === \"businessFinancials\") confidence += 0.4;\n        if (column.patternAnalysis.likelyQuantity) confidence += 0.3;\n        if (column.patternAnalysis.likelyPercentage) confidence += 0.2;\n        if (column.nullCount / (column.nullCount + column.sampleValues.length) < 0.1) confidence += 0.1;\n        reasoning += `Column type: ${column.detectedType}; Null rate: ${(column.nullCount / (column.nullCount + column.sampleValues.length) * 100).toFixed(1)}%`;\n        return {\n            sourceColumn: column.columnName,\n            targetCategory,\n            targetSubcategory,\n            targetField,\n            confidence: Math.min(confidence, 1),\n            reasoning\n        };\n    }\n    static determineOperationalSubcategory(column, fileContext) {\n        const name = column.columnName.toLowerCase();\n        if (this.matchesPatterns(name + \" \" + fileContext, this.BUSINESS_CONTEXTS.networkFootprint)) {\n            return \"networkFootprintCapacity\";\n        } else if (this.matchesPatterns(name + \" \" + fileContext, this.BUSINESS_CONTEXTS.orderManagement)) {\n            return \"orderPaymentData\";\n        } else if (this.matchesPatterns(name + \" \" + fileContext, this.BUSINESS_CONTEXTS.performance)) {\n            return \"operationalPerformanceMetrics\";\n        } else {\n            return \"orderShipmentData\";\n        }\n    }\n    static mapToTargetField(column, category, subcategory) {\n        // Create a standardized field name from the source column\n        let fieldName = column.columnName.toLowerCase().replace(/[^a-z0-9]/g, \"\").replace(/\\s+/g, \"\");\n        // Add context-specific prefixes/suffixes\n        if (column.patternAnalysis.likelyAmount) {\n            if (!fieldName.includes(\"cost\") && !fieldName.includes(\"amount\") && !fieldName.includes(\"price\")) {\n                fieldName += \"Amount\";\n            }\n        }\n        if (column.patternAnalysis.likelyQuantity) {\n            if (!fieldName.includes(\"qty\") && !fieldName.includes(\"count\") && !fieldName.includes(\"quantity\")) {\n                fieldName += \"Quantity\";\n            }\n        }\n        if (column.patternAnalysis.likelyPercentage) {\n            if (!fieldName.includes(\"percent\") && !fieldName.includes(\"rate\")) {\n                fieldName += \"Percentage\";\n            }\n        }\n        return fieldName;\n    }\n    static groupMappingsByCategory(mappings) {\n        const grouped = {};\n        for (const mapping of mappings){\n            const key = `${mapping.targetCategory}.${mapping.targetSubcategory}`;\n            if (!grouped[key]) grouped[key] = [];\n            grouped[key].push(mapping);\n        }\n        return grouped;\n    }\n    static buildComprehensiveData(processedData, mappingsByCategory) {\n        const result = {\n            metadata: {\n                lastProcessed: new Date().toISOString()\n            }\n        };\n        // Aggregate data by category\n        const aggregatedData = this.aggregateProcessedData(processedData);\n        for (const [categoryKey, mappings] of Object.entries(mappingsByCategory)){\n            const [category, subcategory] = categoryKey.split(\".\");\n            if (category === \"operationalReporting\") {\n                if (!result.operationalReporting) result.operationalReporting = {};\n                result.operationalReporting[subcategory] = aggregatedData;\n            } else if (category === \"businessFinancials\") {\n                if (!result.businessFinancials) result.businessFinancials = {};\n                result.businessFinancials[subcategory] = aggregatedData;\n            } else if (category === \"salesGrowthTrajectory\") {\n                if (!result.salesGrowthTrajectory) result.salesGrowthTrajectory = {};\n                result.salesGrowthTrajectory[subcategory] = aggregatedData;\n            }\n        }\n        return result;\n    }\n    static aggregateProcessedData(data) {\n        if (data.length === 0) return {};\n        const aggregated = {};\n        const keys = Object.keys(data[0]);\n        for (const key of keys){\n            const values = data.map((row)=>row[key]).filter((val)=>val !== null && val !== undefined);\n            if (values.length === 0) continue;\n            if (typeof values[0] === \"number\") {\n                aggregated[key] = {\n                    total: values.reduce((sum, val)=>sum + val, 0),\n                    average: values.reduce((sum, val)=>sum + val, 0) / values.length,\n                    min: Math.min(...values),\n                    max: Math.max(...values),\n                    count: values.length,\n                    values: values\n                };\n            } else {\n                aggregated[key] = {\n                    uniqueValues: Array.from(new Set(values)),\n                    count: values.length,\n                    values: values\n                };\n            }\n        }\n        return aggregated;\n    }\n    // Utility methods\n    static calculateAverageLength(values) {\n        const lengths = values.map((v)=>String(v).length);\n        return lengths.reduce((sum, len)=>sum + len, 0) / lengths.length;\n    }\n    static containsNumbers(values) {\n        return values.some((v)=>typeof v === \"number\" || !isNaN(Number(v)));\n    }\n    static containsDates(values) {\n        return values.some((v)=>this.isDateLike(v));\n    }\n    static isDateLike(value) {\n        if (!value) return false;\n        const str = String(value);\n        return !isNaN(Date.parse(str)) || /\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}/.test(str) || /\\d{4}-\\d{2}-\\d{2}/.test(str);\n    }\n    static cleanValue(value, targetField) {\n        if (value === null || value === undefined) return value;\n        let cleaned = value;\n        // Remove common formatting\n        if (typeof cleaned === \"string\") {\n            cleaned = cleaned.trim();\n            // Clean currency symbols\n            if (targetField.toLowerCase().includes(\"cost\") || targetField.toLowerCase().includes(\"amount\")) {\n                cleaned = cleaned.replace(/[$,\\s]/g, \"\");\n            }\n            // Clean percentages\n            if (targetField.toLowerCase().includes(\"percent\")) {\n                cleaned = cleaned.replace(/%/g, \"\");\n            }\n        }\n        return cleaned;\n    }\n    static flexibleValidation(value, mapping) {\n        const result = {\n            field: mapping.targetField,\n            value,\n            isValid: true\n        };\n        if (value === null || value === undefined || value === \"\") {\n            return result; // Allow empty values\n        }\n        // Try to convert to appropriate type based on target field\n        try {\n            if (mapping.targetField.includes(\"cost\") || mapping.targetField.includes(\"amount\") || mapping.targetField.includes(\"quantity\") || mapping.targetField.includes(\"count\")) {\n                const numValue = parseFloat(String(value));\n                if (!isNaN(numValue)) {\n                    result.value = numValue;\n                }\n            } else if (mapping.targetField.includes(\"percent\")) {\n                const numValue = parseFloat(String(value));\n                if (!isNaN(numValue)) {\n                    result.value = Math.min(Math.max(numValue, 0), 100); // Clamp to 0-100\n                }\n            } else if (mapping.targetField.includes(\"date\")) {\n                const dateValue = new Date(value);\n                if (!isNaN(dateValue.getTime())) {\n                    result.value = dateValue.toISOString();\n                }\n            }\n        } catch (error) {\n            result.isValid = false;\n            result.errorMessage = `Could not convert '${value}' to expected type`;\n        }\n        return result;\n    }\n    static calculateTemplateConfidence(mappings) {\n        if (mappings.length === 0) return 0;\n        const avgConfidence = mappings.reduce((sum, m)=>sum + m.confidence, 0) / mappings.length;\n        const coverageBonus = Math.min(mappings.length / 10, 0.2); // Bonus for more mappings\n        return Math.min(avgConfidence + coverageBonus, 1);\n    }\n    static calculateFlexibleDataQuality(rawData, validationResults, template) {\n        const totalFields = rawData.length * template.suggestedMappings.length;\n        const validFields = validationResults.filter((r)=>r.isValid).length;\n        const nonEmptyFields = validationResults.filter((r)=>r.value !== null && r.value !== undefined && r.value !== \"\").length;\n        return {\n            completeness: totalFields > 0 ? nonEmptyFields / totalFields * 100 : 100,\n            accuracy: totalFields > 0 ? validFields / totalFields * 100 : 100,\n            consistency: 95,\n            timeliness: 100,\n            validRecords: Math.floor(validFields / template.suggestedMappings.length),\n            totalRecords: rawData.length,\n            missingFields: [],\n            invalidValues: validationResults.filter((r)=>!r.isValid).map((r)=>({\n                    field: r.field,\n                    value: r.value,\n                    reason: r.errorMessage || \"Validation failed\"\n                }))\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d2VicGFjazovL25ldHdvcngtZXNzZW50aWFscy8uL2xpYi9hZGFwdGl2ZS1kYXRhLXZhbGlkYXRvci50cz80MDJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVuaGFuY2VkIERhdGEgVmFsaWRhdG9yIHdpdGggQWRhcHRpdmUgVGVtcGxhdGUgU3lzdGVtXG4vLyBUaGlzIHN5c3RlbSBsZWFybnMgZnJvbSB1cGxvYWRlZCBmaWxlcyBhbmQgY3JlYXRlcyBmbGV4aWJsZSBtYXBwaW5nc1xuXG5pbXBvcnQgdHlwZSB7XG4gIENvbXByZWhlbnNpdmVPcGVyYXRpb25hbERhdGEsXG4gIERhdGFRdWFsaXR5TWV0cmljcyxcbiAgVmFsaWRhdGlvblJlc3VsdCxcbiAgUHJvY2Vzc2luZ1Jlc3VsdCxcbiAgRGF0YUZpZWxkTWFwcGluZyxcbiAgRGF0YU1hcHBpbmdUZW1wbGF0ZVxufSBmcm9tICdAL3R5cGVzL2RhdGEtc2NoZW1hJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5BbmFseXNpcyB7XG4gIGNvbHVtbk5hbWU6IHN0cmluZztcbiAgc2FtcGxlVmFsdWVzOiBhbnlbXTtcbiAgZGV0ZWN0ZWRUeXBlOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nIHwgJ2RhdGUnIHwgJ21peGVkJztcbiAgbnVsbENvdW50OiBudW1iZXI7XG4gIHVuaXF1ZVZhbHVlczogbnVtYmVyO1xuICBhdmdMZW5ndGg/OiBudW1iZXI7XG4gIGNvbnRhaW5zTnVtYmVyczogYm9vbGVhbjtcbiAgY29udGFpbnNEYXRlczogYm9vbGVhbjtcbiAgcGF0dGVybkFuYWx5c2lzOiB7XG4gICAgbGlrZWx5SWQ6IGJvb2xlYW47XG4gICAgbGlrZWx5TmFtZTogYm9vbGVhbjtcbiAgICBsaWtlbHlBZGRyZXNzOiBib29sZWFuO1xuICAgIGxpa2VseUFtb3VudDogYm9vbGVhbjtcbiAgICBsaWtlbHlEYXRlOiBib29sZWFuO1xuICAgIGxpa2VseUNhdGVnb3J5OiBib29sZWFuO1xuICAgIGxpa2VseVF1YW50aXR5OiBib29sZWFuO1xuICAgIGxpa2VseVBlcmNlbnRhZ2U6IGJvb2xlYW47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRhcHRpdmVUZW1wbGF0ZSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICBzb3VyY2VGaWxlTmFtZTogc3RyaW5nO1xuICBjb2x1bW5BbmFseXNpczogQ29sdW1uQW5hbHlzaXNbXTtcbiAgc3VnZ2VzdGVkTWFwcGluZ3M6IEFycmF5PHtcbiAgICBzb3VyY2VDb2x1bW46IHN0cmluZztcbiAgICB0YXJnZXRDYXRlZ29yeTogJ29wZXJhdGlvbmFsUmVwb3J0aW5nJyB8ICdidXNpbmVzc0ZpbmFuY2lhbHMnIHwgJ3NhbGVzR3Jvd3RoVHJhamVjdG9yeSc7XG4gICAgdGFyZ2V0U3ViY2F0ZWdvcnk6IHN0cmluZztcbiAgICB0YXJnZXRGaWVsZDogc3RyaW5nO1xuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICByZWFzb25pbmc6IHN0cmluZztcbiAgfT47XG4gIGRhdGFQYXR0ZXJuczoge1xuICAgIGhhc0dlb2dyYXBoaWNEYXRhOiBib29sZWFuO1xuICAgIGhhc0ZpbmFuY2lhbERhdGE6IGJvb2xlYW47XG4gICAgaGFzRGF0ZVNlcXVlbmNlczogYm9vbGVhbjtcbiAgICBoYXNRdWFudGl0aWVzOiBib29sZWFuO1xuICAgIGhhc0NhdGVnb3JpZXM6IGJvb2xlYW47XG4gICAgaGFzUGVyZm9ybWFuY2VNZXRyaWNzOiBib29sZWFuO1xuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgQWRhcHRpdmVEYXRhVmFsaWRhdG9yIHtcbiAgXG4gIC8vIENvbXByZWhlbnNpdmUga2V5d29yZCBwYXR0ZXJucyBmb3IgZGlmZmVyZW50IGJ1c2luZXNzIGRhdGEgdHlwZXNcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09MVU1OX1BBVFRFUk5TID0ge1xuICAgIC8vIEdlb2dyYXBoaWMvTG9jYXRpb24gcGF0dGVybnNcbiAgICBnZW9ncmFwaGljOiBbXG4gICAgICAnc3RhdGUnLCAncmVnaW9uJywgJ2NpdHknLCAnemlwJywgJ3Bvc3RhbCcsICdjb3VudHJ5JywgJ2xvY2F0aW9uJywgJ2FkZHJlc3MnLFxuICAgICAgJ2ZhY2lsaXR5JywgJ3dhcmVob3VzZScsICdkYycsICdkaXN0cmlidXRpb24nLCAnY2VudGVyJywgJ3NpdGUnLCAnYnJhbmNoJ1xuICAgIF0sXG4gICAgXG4gICAgLy8gRmluYW5jaWFsIHBhdHRlcm5zXG4gICAgZmluYW5jaWFsOiBbXG4gICAgICAnY29zdCcsICdwcmljZScsICdhbW91bnQnLCAncmV2ZW51ZScsICdzYWxlcycsICdleHBlbnNlJywgJ2J1ZGdldCcsICdwcm9maXQnLFxuICAgICAgJ3RvdGFsJywgJ3ZhbHVlJywgJ2RvbGxhcicsICd1c2QnLCAnY3VycmVuY3knLCAnaW52b2ljZScsICdwYXltZW50JywgJ2JpbGxpbmcnXG4gICAgXSxcbiAgICBcbiAgICAvLyBRdWFudGl0eS9Wb2x1bWUgcGF0dGVybnNcbiAgICBxdWFudGl0eTogW1xuICAgICAgJ3F1YW50aXR5JywgJ3F0eScsICdjb3VudCcsICd2b2x1bWUnLCAndW5pdHMnLCAncGllY2VzJywgJ2VhY2gnLCAndG9ucycsXG4gICAgICAncG91bmRzJywgJ2tnJywgJ3dlaWdodCcsICdjYXBhY2l0eScsICd0aHJvdWdocHV0JywgJ2RlbWFuZCdcbiAgICBdLFxuICAgIFxuICAgIC8vIFBlcmZvcm1hbmNlL01ldHJpY3MgcGF0dGVybnNcbiAgICBwZXJmb3JtYW5jZTogW1xuICAgICAgJ3BlcmNlbnRhZ2UnLCAncGVyY2VudCcsICdyYXRpbycsICdyYXRlJywgJ2FjY3VyYWN5JywgJ2VmZmljaWVuY3knLCAndXRpbGl6YXRpb24nLFxuICAgICAgJ3BlcmZvcm1hbmNlJywgJ21ldHJpYycsICdrcGknLCAnc2NvcmUnLCAnaW5kZXgnLCAnb3RkJywgJ2RlbGl2ZXJ5J1xuICAgIF0sXG4gICAgXG4gICAgLy8gRGF0ZS9UaW1lIHBhdHRlcm5zXG4gICAgdGVtcG9yYWw6IFtcbiAgICAgICdkYXRlJywgJ3RpbWUnLCAneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdwZXJpb2QnLCAncXVhcnRlcicsXG4gICAgICAnY3JlYXRlZCcsICd1cGRhdGVkJywgJ21vZGlmaWVkJywgJ3N0YXJ0JywgJ2VuZCcsICdkdWUnXG4gICAgXSxcbiAgICBcbiAgICAvLyBJZGVudGlmaWVyIHBhdHRlcm5zXG4gICAgaWRlbnRpZmllcjogW1xuICAgICAgJ2lkJywgJ251bWJlcicsICdjb2RlJywgJ3JlZicsICdyZWZlcmVuY2UnLCAnc2t1JywgJ3BhcnQnLCAnaXRlbScsXG4gICAgICAnb3JkZXInLCAnaW52b2ljZScsICdwbycsICd0cmFja2luZycsICdzZXJpYWwnXG4gICAgXSxcbiAgICBcbiAgICAvLyBOYW1lL0Rlc2NyaXB0aW9uIHBhdHRlcm5zXG4gICAgZGVzY3JpcHRpdmU6IFtcbiAgICAgICduYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ3RpdGxlJywgJ2xhYmVsJywgJ2NhdGVnb3J5JywgJ3R5cGUnLCAnY2xhc3MnLFxuICAgICAgJ2dyb3VwJywgJ3NlZ21lbnQnLCAnY2hhbm5lbCcsICdtZXRob2QnLCAnbW9kZSdcbiAgICBdLFxuICAgIFxuICAgIC8vIE9wZXJhdGlvbmFsIHNwZWNpZmljIHBhdHRlcm5zXG4gICAgb3BlcmF0aW9uYWw6IFtcbiAgICAgICdzaGlwbWVudCcsICdmcmVpZ2h0JywgJ2NhcnJpZXInLCAncm91dGUnLCAnZGVsaXZlcnknLCAncmVjZWl2aW5nJyxcbiAgICAgICdpbnZlbnRvcnknLCAnc3RvY2snLCAnZnVsZmlsbG1lbnQnLCAncHJvY2Vzc2luZycsICdoYW5kbGluZydcbiAgICBdXG4gIH07XG5cbiAgLy8gQnVzaW5lc3MgY29udGV4dCBtYXBwaW5ncyBmb3IgY2F0ZWdvcml6YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQlVTSU5FU1NfQ09OVEVYVFMgPSB7XG4gICAgbmV0d29ya0Zvb3RwcmludDogWydmYWNpbGl0eScsICd3YXJlaG91c2UnLCAnZGMnLCAnY2FwYWNpdHknLCAnc3FmdCcsICdzcGFjZScsICdkb2NrJywgJ2Rvb3JzJ10sXG4gICAgb3JkZXJNYW5hZ2VtZW50OiBbJ29yZGVyJywgJ2N1c3RvbWVyJywgJ3NoaXBtZW50JywgJ2RlbGl2ZXJ5JywgJ2Z1bGZpbGxtZW50J10sXG4gICAgaW52ZW50b3J5OiBbJ2ludmVudG9yeScsICdzdG9jaycsICdza3UnLCAndW5pdHMnLCAndGhyb3VnaHB1dCcsICd0dXJucyddLFxuICAgIGZpbmFuY2lhbE9wZXJhdGlvbnM6IFsnY29zdCcsICdleHBlbnNlJywgJ2J1ZGdldCcsICdyZXZlbnVlJywgJ3Byb2ZpdCcsICdwcmljaW5nJ10sXG4gICAgc2FsZXNHcm93dGg6IFsnc2FsZXMnLCAnZ3Jvd3RoJywgJ2ZvcmVjYXN0JywgJ2RlbWFuZCcsICdwcm9qZWN0aW9uJywgJ2hpc3RvcmljYWwnXSxcbiAgICBwZXJmb3JtYW5jZTogWydhY2N1cmFjeScsICdlZmZpY2llbmN5JywgJ290ZCcsICdxdWFsaXR5JywgJ3V0aWxpemF0aW9uJywgJ21ldHJpY3MnXVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbmFseXplIGNvbHVtbiBzdHJ1Y3R1cmUgYW5kIGNvbnRlbnQgdG8gdW5kZXJzdGFuZCBkYXRhIHBhdHRlcm5zXG4gICAqL1xuICBzdGF0aWMgYW5hbHl6ZUNvbHVtbnMoZGF0YTogYW55W10pOiBDb2x1bW5BbmFseXNpc1tdIHtcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcbiAgICBjb25zdCBhbmFseXNlczogQ29sdW1uQW5hbHlzaXNbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBjb2x1bW5OYW1lIG9mIGNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKHJvdyA9PiByb3dbY29sdW1uTmFtZV0pLmZpbHRlcih2YWwgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gJycpO1xuICAgICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIE1hdGgubWluKDEwLCB2YWx1ZXMubGVuZ3RoKSk7XG4gICAgICBjb25zdCBudWxsQ291bnQgPSBkYXRhLmxlbmd0aCAtIHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIC8vIFR5cGUgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBkZXRlY3RlZFR5cGUgPSB0aGlzLmRldGVjdENvbHVtblR5cGUodmFsdWVzKTtcbiAgICAgIFxuICAgICAgLy8gUGF0dGVybiBhbmFseXNpc1xuICAgICAgY29uc3QgcGF0dGVybkFuYWx5c2lzID0gdGhpcy5hbmFseXplQ29sdW1uUGF0dGVybnMoY29sdW1uTmFtZSwgc2FtcGxlVmFsdWVzKTtcblxuICAgICAgYW5hbHlzZXMucHVzaCh7XG4gICAgICAgIGNvbHVtbk5hbWUsXG4gICAgICAgIHNhbXBsZVZhbHVlcyxcbiAgICAgICAgZGV0ZWN0ZWRUeXBlLFxuICAgICAgICBudWxsQ291bnQsXG4gICAgICAgIHVuaXF1ZVZhbHVlczogbmV3IFNldCh2YWx1ZXMpLnNpemUsXG4gICAgICAgIGF2Z0xlbmd0aDogdGhpcy5jYWxjdWxhdGVBdmVyYWdlTGVuZ3RoKHZhbHVlcyksXG4gICAgICAgIGNvbnRhaW5zTnVtYmVyczogdGhpcy5jb250YWluc051bWJlcnModmFsdWVzKSxcbiAgICAgICAgY29udGFpbnNEYXRlczogdGhpcy5jb250YWluc0RhdGVzKHZhbHVlcyksXG4gICAgICAgIHBhdHRlcm5BbmFseXNpc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuYWx5c2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhZGFwdGl2ZSB0ZW1wbGF0ZSBmcm9tIGZpbGUgYW5hbHlzaXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBZGFwdGl2ZVRlbXBsYXRlKFxuICAgIGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgZGF0YTogYW55W10sXG4gICAgY29sdW1uQW5hbHlzaXM6IENvbHVtbkFuYWx5c2lzW11cbiAgKTogQWRhcHRpdmVUZW1wbGF0ZSB7XG4gICAgY29uc3QgZGF0YVBhdHRlcm5zID0gdGhpcy5kZXRlY3REYXRhUGF0dGVybnMoY29sdW1uQW5hbHlzaXMpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1hcHBpbmdzID0gdGhpcy5nZW5lcmF0ZUNvbHVtbk1hcHBpbmdzKGNvbHVtbkFuYWx5c2lzLCBmaWxlTmFtZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgY29uZmlkZW5jZSBiYXNlZCBvbiBwYXR0ZXJuIG1hdGNoZXNcbiAgICBjb25zdCBjb25maWRlbmNlID0gdGhpcy5jYWxjdWxhdGVUZW1wbGF0ZUNvbmZpZGVuY2Uoc3VnZ2VzdGVkTWFwcGluZ3MpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgYWRhcHRpdmVfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgICAgbmFtZTogYEFkYXB0aXZlIFRlbXBsYXRlIGZvciAke2ZpbGVOYW1lfWAsXG4gICAgICBkZXNjcmlwdGlvbjogYEF1dG8tZ2VuZXJhdGVkIHRlbXBsYXRlIGJhc2VkIG9uIGFuYWx5c2lzIG9mICR7ZmlsZU5hbWV9YCxcbiAgICAgIGNvbmZpZGVuY2UsXG4gICAgICBzb3VyY2VGaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICBjb2x1bW5BbmFseXNpcyxcbiAgICAgIHN1Z2dlc3RlZE1hcHBpbmdzLFxuICAgICAgZGF0YVBhdHRlcm5zXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGRhdGEgdXNpbmcgYWRhcHRpdmUgdGVtcGxhdGUgd2l0aCBmbGV4aWJsZSB2YWxpZGF0aW9uXG4gICAqL1xuICBzdGF0aWMgcHJvY2Vzc1dpdGhBZGFwdGl2ZVRlbXBsYXRlKFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGFkYXB0aXZlVGVtcGxhdGU6IEFkYXB0aXZlVGVtcGxhdGVcbiAgKTogUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHRzOiBWYWxpZGF0aW9uUmVzdWx0W10gPSBbXTtcbiAgICBjb25zdCBwcm9jZXNzZWREYXRhOiBhbnlbXSA9IFtdO1xuICAgIFxuICAgIGxldCB2YWxpZFJvd3MgPSAwO1xuICAgIGxldCBza2lwcGVkUm93cyA9IDA7XG5cbiAgICAvLyBHcm91cCBtYXBwaW5ncyBieSB0YXJnZXQgY2F0ZWdvcnlcbiAgICBjb25zdCBtYXBwaW5nc0J5Q2F0ZWdvcnkgPSB0aGlzLmdyb3VwTWFwcGluZ3NCeUNhdGVnb3J5KGFkYXB0aXZlVGVtcGxhdGUuc3VnZ2VzdGVkTWFwcGluZ3MpO1xuXG4gICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGRhdGEubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICBjb25zdCByb3cgPSBkYXRhW3Jvd0luZGV4XTtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZFJvdzogYW55ID0ge307XG4gICAgICBsZXQgaXNWYWxpZFJvdyA9IHRydWU7XG4gICAgICBsZXQgaGFzQW55RGF0YSA9IGZhbHNlO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggbWFwcGluZyB3aXRoIGZsZXhpYmxlIHZhbGlkYXRpb25cbiAgICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBhZGFwdGl2ZVRlbXBsYXRlLnN1Z2dlc3RlZE1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gcm93W21hcHBpbmcuc291cmNlQ29sdW1uXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSAhPT0gbnVsbCAmJiBzb3VyY2VWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZVZhbHVlICE9PSAnJykge1xuICAgICAgICAgIGhhc0FueURhdGEgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZsZXhpYmxlIHZhbGlkYXRpb24gLSBhdHRlbXB0IHRvIGNsZWFuIGFuZCBjb252ZXJ0IGRhdGFcbiAgICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWUgPSB0aGlzLmNsZWFuVmFsdWUoc291cmNlVmFsdWUsIG1hcHBpbmcudGFyZ2V0RmllbGQpO1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLmZsZXhpYmxlVmFsaWRhdGlvbihjbGVhbmVkVmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHRzLnB1c2godmFsaWRhdGlvbik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke3Jvd0luZGV4ICsgMX0sIEZpZWxkICcke21hcHBpbmcudGFyZ2V0RmllbGR9JzogJHt2YWxpZGF0aW9uLmVycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgICAgIC8vIERvbid0IG1hcmsgcm93IGFzIGludmFsaWQgZm9yIG1pbm9yIGlzc3VlcywganVzdCBsb2cgd2FybmluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRSb3dbbWFwcGluZy50YXJnZXRGaWVsZF0gPSB2YWxpZGF0aW9uLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHNraXAgcm93cyB0aGF0IGhhdmUgbm8gdXNlZnVsIGRhdGEgYXQgYWxsXG4gICAgICBpZiAoIWhhc0FueURhdGEpIHtcbiAgICAgICAgc2tpcHBlZFJvd3MrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ZhbGlkUm93IHx8IE9iamVjdC5rZXlzKHByb2Nlc3NlZFJvdykubGVuZ3RoID4gMCkge1xuICAgICAgICBwcm9jZXNzZWREYXRhLnB1c2gocHJvY2Vzc2VkUm93KTtcbiAgICAgICAgdmFsaWRSb3dzKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2lwcGVkUm93cysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIGNvbXByZWhlbnNpdmUgZGF0YSBzdHJ1Y3R1cmVcbiAgICBjb25zdCBjb21wcmVoZW5zaXZlRGF0YSA9IHRoaXMuYnVpbGRDb21wcmVoZW5zaXZlRGF0YShwcm9jZXNzZWREYXRhLCBtYXBwaW5nc0J5Q2F0ZWdvcnkpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBmbGV4aWJsZSBkYXRhIHF1YWxpdHkgbWV0cmljc1xuICAgIGNvbnN0IGRhdGFRdWFsaXR5ID0gdGhpcy5jYWxjdWxhdGVGbGV4aWJsZURhdGFRdWFsaXR5KGRhdGEsIHZhbGlkYXRpb25SZXN1bHRzLCBhZGFwdGl2ZVRlbXBsYXRlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB2YWxpZFJvd3MgPiAwLCAvLyBTdWNjZXNzIGlmIHdlIGdvdCBhbnkgdmFsaWQgZGF0YVxuICAgICAgZGF0YTogY29tcHJlaGVuc2l2ZURhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5ncyxcbiAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgdG90YWxSb3dzOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdmFsaWRSb3dzLFxuICAgICAgICBza2lwcGVkUm93cyxcbiAgICAgICAgZGF0YVF1YWxpdHlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHMgZm9yIGRhdGEgYW5hbHlzaXNcblxuICBwcml2YXRlIHN0YXRpYyBkZXRlY3RDb2x1bW5UeXBlKHZhbHVlczogYW55W10pOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nIHwgJ2RhdGUnIHwgJ21peGVkJyB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiAnc3RyaW5nJztcblxuICAgIGNvbnN0IHR5cGVzID0gbmV3IFNldCgpO1xuICAgIFxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzLnNsaWNlKDAsIDIwKSkgeyAvLyBTYW1wbGUgZmlyc3QgMjAgdmFsdWVzXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCAoIWlzTmFOKE51bWJlcih2YWx1ZSkpICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkpKSB7XG4gICAgICAgIHR5cGVzLmFkZCgnbnVtYmVyJyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgdHlwZXMuYWRkKCdkYXRlJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IFsndHJ1ZScsICdmYWxzZScsICcxJywgJzAnLCAneWVzJywgJ25vJ10uaW5jbHVkZXMoU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICB0eXBlcy5hZGQoJ2Jvb2xlYW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVzLmFkZCgnc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVzLnNpemUgPiAxKSByZXR1cm4gJ21peGVkJztcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0eXBlcylbMF0gYXMgYW55O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYW5hbHl6ZUNvbHVtblBhdHRlcm5zKGNvbHVtbk5hbWU6IHN0cmluZywgc2FtcGxlVmFsdWVzOiBhbnlbXSk6IENvbHVtbkFuYWx5c2lzWydwYXR0ZXJuQW5hbHlzaXMnXSB7XG4gICAgY29uc3QgbmFtZSA9IGNvbHVtbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgbGlrZWx5SWQ6IHRoaXMubWF0Y2hlc1BhdHRlcm5zKG5hbWUsIHRoaXMuQ09MVU1OX1BBVFRFUk5TLmlkZW50aWZpZXIpLFxuICAgICAgbGlrZWx5TmFtZTogdGhpcy5tYXRjaGVzUGF0dGVybnMobmFtZSwgdGhpcy5DT0xVTU5fUEFUVEVSTlMuZGVzY3JpcHRpdmUpLFxuICAgICAgbGlrZWx5QWRkcmVzczogdGhpcy5tYXRjaGVzUGF0dGVybnMobmFtZSwgdGhpcy5DT0xVTU5fUEFUVEVSTlMuZ2VvZ3JhcGhpYyksXG4gICAgICBsaWtlbHlBbW91bnQ6IHRoaXMubWF0Y2hlc1BhdHRlcm5zKG5hbWUsIHRoaXMuQ09MVU1OX1BBVFRFUk5TLmZpbmFuY2lhbCksXG4gICAgICBsaWtlbHlEYXRlOiB0aGlzLm1hdGNoZXNQYXR0ZXJucyhuYW1lLCB0aGlzLkNPTFVNTl9QQVRURVJOUy50ZW1wb3JhbCkgfHwgdGhpcy5jb250YWluc0RhdGVzKHNhbXBsZVZhbHVlcyksXG4gICAgICBsaWtlbHlDYXRlZ29yeTogdGhpcy5tYXRjaGVzUGF0dGVybnMobmFtZSwgdGhpcy5DT0xVTU5fUEFUVEVSTlMuZGVzY3JpcHRpdmUpLFxuICAgICAgbGlrZWx5UXVhbnRpdHk6IHRoaXMubWF0Y2hlc1BhdHRlcm5zKG5hbWUsIHRoaXMuQ09MVU1OX1BBVFRFUk5TLnF1YW50aXR5KSxcbiAgICAgIGxpa2VseVBlcmNlbnRhZ2U6IG5hbWUuaW5jbHVkZXMoJ3BlcmNlbnQnKSB8fCBuYW1lLmluY2x1ZGVzKCclJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlcy5zb21lKHYgPT4gU3RyaW5nKHYpLmluY2x1ZGVzKCclJykpXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG1hdGNoZXNQYXR0ZXJucyh0ZXh0OiBzdHJpbmcsIHBhdHRlcm5zOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gdGV4dC5pbmNsdWRlcyhwYXR0ZXJuKSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBkZXRlY3REYXRhUGF0dGVybnMoY29sdW1uQW5hbHlzaXM6IENvbHVtbkFuYWx5c2lzW10pOiBBZGFwdGl2ZVRlbXBsYXRlWydkYXRhUGF0dGVybnMnXSB7XG4gICAgY29uc3QgY29sdW1ucyA9IGNvbHVtbkFuYWx5c2lzLm1hcChjID0+IGMuY29sdW1uTmFtZS50b0xvd2VyQ2FzZSgpKS5qb2luKCcgJyk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0dlb2dyYXBoaWNEYXRhOiB0aGlzLm1hdGNoZXNQYXR0ZXJucyhjb2x1bW5zLCB0aGlzLkNPTFVNTl9QQVRURVJOUy5nZW9ncmFwaGljKSxcbiAgICAgIGhhc0ZpbmFuY2lhbERhdGE6IHRoaXMubWF0Y2hlc1BhdHRlcm5zKGNvbHVtbnMsIHRoaXMuQ09MVU1OX1BBVFRFUk5TLmZpbmFuY2lhbCksXG4gICAgICBoYXNEYXRlU2VxdWVuY2VzOiBjb2x1bW5BbmFseXNpcy5zb21lKGMgPT4gYy5wYXR0ZXJuQW5hbHlzaXMubGlrZWx5RGF0ZSksXG4gICAgICBoYXNRdWFudGl0aWVzOiB0aGlzLm1hdGNoZXNQYXR0ZXJucyhjb2x1bW5zLCB0aGlzLkNPTFVNTl9QQVRURVJOUy5xdWFudGl0eSksXG4gICAgICBoYXNDYXRlZ29yaWVzOiB0aGlzLm1hdGNoZXNQYXR0ZXJucyhjb2x1bW5zLCB0aGlzLkNPTFVNTl9QQVRURVJOUy5kZXNjcmlwdGl2ZSksXG4gICAgICBoYXNQZXJmb3JtYW5jZU1ldHJpY3M6IHRoaXMubWF0Y2hlc1BhdHRlcm5zKGNvbHVtbnMsIHRoaXMuQ09MVU1OX1BBVFRFUk5TLnBlcmZvcm1hbmNlKVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUNvbHVtbk1hcHBpbmdzKFxuICAgIGNvbHVtbkFuYWx5c2lzOiBDb2x1bW5BbmFseXNpc1tdLFxuICAgIGZpbGVOYW1lOiBzdHJpbmdcbiAgKTogQWRhcHRpdmVUZW1wbGF0ZVsnc3VnZ2VzdGVkTWFwcGluZ3MnXSB7XG4gICAgY29uc3QgbWFwcGluZ3M6IEFkYXB0aXZlVGVtcGxhdGVbJ3N1Z2dlc3RlZE1hcHBpbmdzJ10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbkFuYWx5c2lzKSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5pbmZlckNvbHVtbk1hcHBpbmcoY29sdW1uLCBmaWxlTmFtZSk7XG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICBtYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGluZmVyQ29sdW1uTWFwcGluZyhcbiAgICBjb2x1bW46IENvbHVtbkFuYWx5c2lzLFxuICAgIGZpbGVOYW1lOiBzdHJpbmdcbiAgKTogQWRhcHRpdmVUZW1wbGF0ZVsnc3VnZ2VzdGVkTWFwcGluZ3MnXVswXSB8IG51bGwge1xuICAgIGNvbnN0IG5hbWUgPSBjb2x1bW4uY29sdW1uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGZpbGVDb250ZXh0ID0gZmlsZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIERldGVybWluZSB0YXJnZXQgY2F0ZWdvcnkgYmFzZWQgb24gZmlsZSBuYW1lIGFuZCBjb2x1bW4gcGF0dGVybnNcbiAgICBsZXQgdGFyZ2V0Q2F0ZWdvcnk6ICdvcGVyYXRpb25hbFJlcG9ydGluZycgfCAnYnVzaW5lc3NGaW5hbmNpYWxzJyB8ICdzYWxlc0dyb3d0aFRyYWplY3RvcnknO1xuICAgIGxldCB0YXJnZXRTdWJjYXRlZ29yeTogc3RyaW5nO1xuICAgIGxldCB0YXJnZXRGaWVsZDogc3RyaW5nO1xuICAgIGxldCBjb25maWRlbmNlID0gMDtcbiAgICBsZXQgcmVhc29uaW5nID0gJyc7XG5cbiAgICAvLyBDYXRlZ29yeSBpbmZlcmVuY2UgbG9naWNcbiAgICBpZiAodGhpcy5tYXRjaGVzUGF0dGVybnMoZmlsZUNvbnRleHQsIFsnYnVkZ2V0JywgJ2V4cGVuc2UnLCAnY29zdCcsICdmaW5hbmNpYWwnXSkgfHxcbiAgICAgICAgY29sdW1uLnBhdHRlcm5BbmFseXNpcy5saWtlbHlBbW91bnQpIHtcbiAgICAgIHRhcmdldENhdGVnb3J5ID0gJ2J1c2luZXNzRmluYW5jaWFscyc7XG4gICAgICB0YXJnZXRTdWJjYXRlZ29yeSA9ICdjb3N0RmluYW5jaWFsRGF0YSc7XG4gICAgICBjb25maWRlbmNlICs9IDAuMztcbiAgICAgIHJlYXNvbmluZyArPSAnRmluYW5jaWFsIGNvbnRleHQgZGV0ZWN0ZWQ7ICc7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoZXNQYXR0ZXJucyhmaWxlQ29udGV4dCwgWydzYWxlcycsICdncm93dGgnLCAnZm9yZWNhc3QnLCAnZGVtYW5kJ10pIHx8XG4gICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNQYXR0ZXJucyhuYW1lLCBbJ3NhbGVzJywgJ3JldmVudWUnLCAnZm9yZWNhc3QnLCAnZGVtYW5kJ10pKSB7XG4gICAgICB0YXJnZXRDYXRlZ29yeSA9ICdzYWxlc0dyb3d0aFRyYWplY3RvcnknO1xuICAgICAgdGFyZ2V0U3ViY2F0ZWdvcnkgPSAnaGlzdG9yaWNhbFNhbGVzRGF0YSc7XG4gICAgICBjb25maWRlbmNlICs9IDAuMztcbiAgICAgIHJlYXNvbmluZyArPSAnU2FsZXMvZ3Jvd3RoIGNvbnRleHQgZGV0ZWN0ZWQ7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldENhdGVnb3J5ID0gJ29wZXJhdGlvbmFsUmVwb3J0aW5nJztcbiAgICAgIHRhcmdldFN1YmNhdGVnb3J5ID0gdGhpcy5kZXRlcm1pbmVPcGVyYXRpb25hbFN1YmNhdGVnb3J5KGNvbHVtbiwgZmlsZUNvbnRleHQpO1xuICAgICAgY29uZmlkZW5jZSArPSAwLjI7XG4gICAgICByZWFzb25pbmcgKz0gJ09wZXJhdGlvbmFsIGNvbnRleHQgZGV0ZWN0ZWQ7ICc7XG4gICAgfVxuXG4gICAgLy8gRmllbGQgbmFtZSBtYXBwaW5nIHdpdGggZmxleGlibGUgbWF0Y2hpbmdcbiAgICB0YXJnZXRGaWVsZCA9IHRoaXMubWFwVG9UYXJnZXRGaWVsZChjb2x1bW4sIHRhcmdldENhdGVnb3J5LCB0YXJnZXRTdWJjYXRlZ29yeSk7XG4gICAgXG4gICAgLy8gQ29uZmlkZW5jZSBzY29yaW5nXG4gICAgaWYgKGNvbHVtbi5wYXR0ZXJuQW5hbHlzaXMubGlrZWx5QW1vdW50ICYmIHRhcmdldENhdGVnb3J5ID09PSAnYnVzaW5lc3NGaW5hbmNpYWxzJykgY29uZmlkZW5jZSArPSAwLjQ7XG4gICAgaWYgKGNvbHVtbi5wYXR0ZXJuQW5hbHlzaXMubGlrZWx5UXVhbnRpdHkpIGNvbmZpZGVuY2UgKz0gMC4zO1xuICAgIGlmIChjb2x1bW4ucGF0dGVybkFuYWx5c2lzLmxpa2VseVBlcmNlbnRhZ2UpIGNvbmZpZGVuY2UgKz0gMC4yO1xuICAgIGlmIChjb2x1bW4ubnVsbENvdW50IC8gKGNvbHVtbi5udWxsQ291bnQgKyBjb2x1bW4uc2FtcGxlVmFsdWVzLmxlbmd0aCkgPCAwLjEpIGNvbmZpZGVuY2UgKz0gMC4xO1xuXG4gICAgcmVhc29uaW5nICs9IGBDb2x1bW4gdHlwZTogJHtjb2x1bW4uZGV0ZWN0ZWRUeXBlfTsgTnVsbCByYXRlOiAkeyhjb2x1bW4ubnVsbENvdW50IC8gKGNvbHVtbi5udWxsQ291bnQgKyBjb2x1bW4uc2FtcGxlVmFsdWVzLmxlbmd0aCkgKiAxMDApLnRvRml4ZWQoMSl9JWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlQ29sdW1uOiBjb2x1bW4uY29sdW1uTmFtZSxcbiAgICAgIHRhcmdldENhdGVnb3J5LFxuICAgICAgdGFyZ2V0U3ViY2F0ZWdvcnksXG4gICAgICB0YXJnZXRGaWVsZCxcbiAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEpLFxuICAgICAgcmVhc29uaW5nXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGRldGVybWluZU9wZXJhdGlvbmFsU3ViY2F0ZWdvcnkoY29sdW1uOiBDb2x1bW5BbmFseXNpcywgZmlsZUNvbnRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmFtZSA9IGNvbHVtbi5jb2x1bW5OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKHRoaXMubWF0Y2hlc1BhdHRlcm5zKG5hbWUgKyAnICcgKyBmaWxlQ29udGV4dCwgdGhpcy5CVVNJTkVTU19DT05URVhUUy5uZXR3b3JrRm9vdHByaW50KSkge1xuICAgICAgcmV0dXJuICduZXR3b3JrRm9vdHByaW50Q2FwYWNpdHknO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaGVzUGF0dGVybnMobmFtZSArICcgJyArIGZpbGVDb250ZXh0LCB0aGlzLkJVU0lORVNTX0NPTlRFWFRTLm9yZGVyTWFuYWdlbWVudCkpIHtcbiAgICAgIHJldHVybiAnb3JkZXJQYXltZW50RGF0YSc7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoZXNQYXR0ZXJucyhuYW1lICsgJyAnICsgZmlsZUNvbnRleHQsIHRoaXMuQlVTSU5FU1NfQ09OVEVYVFMucGVyZm9ybWFuY2UpKSB7XG4gICAgICByZXR1cm4gJ29wZXJhdGlvbmFsUGVyZm9ybWFuY2VNZXRyaWNzJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdvcmRlclNoaXBtZW50RGF0YSc7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgbWFwVG9UYXJnZXRGaWVsZChcbiAgICBjb2x1bW46IENvbHVtbkFuYWx5c2lzLFxuICAgIGNhdGVnb3J5OiBzdHJpbmcsXG4gICAgc3ViY2F0ZWdvcnk6IHN0cmluZ1xuICApOiBzdHJpbmcge1xuICAgIC8vIENyZWF0ZSBhIHN0YW5kYXJkaXplZCBmaWVsZCBuYW1lIGZyb20gdGhlIHNvdXJjZSBjb2x1bW5cbiAgICBsZXQgZmllbGROYW1lID0gY29sdW1uLmNvbHVtbk5hbWVcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAucmVwbGFjZSgvW15hLXowLTldL2csICcnKVxuICAgICAgLnJlcGxhY2UoL1xccysvZywgJycpO1xuXG4gICAgLy8gQWRkIGNvbnRleHQtc3BlY2lmaWMgcHJlZml4ZXMvc3VmZml4ZXNcbiAgICBpZiAoY29sdW1uLnBhdHRlcm5BbmFseXNpcy5saWtlbHlBbW91bnQpIHtcbiAgICAgIGlmICghZmllbGROYW1lLmluY2x1ZGVzKCdjb3N0JykgJiYgIWZpZWxkTmFtZS5pbmNsdWRlcygnYW1vdW50JykgJiYgIWZpZWxkTmFtZS5pbmNsdWRlcygncHJpY2UnKSkge1xuICAgICAgICBmaWVsZE5hbWUgKz0gJ0Ftb3VudCc7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjb2x1bW4ucGF0dGVybkFuYWx5c2lzLmxpa2VseVF1YW50aXR5KSB7XG4gICAgICBpZiAoIWZpZWxkTmFtZS5pbmNsdWRlcygncXR5JykgJiYgIWZpZWxkTmFtZS5pbmNsdWRlcygnY291bnQnKSAmJiAhZmllbGROYW1lLmluY2x1ZGVzKCdxdWFudGl0eScpKSB7XG4gICAgICAgIGZpZWxkTmFtZSArPSAnUXVhbnRpdHknO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2x1bW4ucGF0dGVybkFuYWx5c2lzLmxpa2VseVBlcmNlbnRhZ2UpIHtcbiAgICAgIGlmICghZmllbGROYW1lLmluY2x1ZGVzKCdwZXJjZW50JykgJiYgIWZpZWxkTmFtZS5pbmNsdWRlcygncmF0ZScpKSB7XG4gICAgICAgIGZpZWxkTmFtZSArPSAnUGVyY2VudGFnZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkTmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdyb3VwTWFwcGluZ3NCeUNhdGVnb3J5KG1hcHBpbmdzOiBBZGFwdGl2ZVRlbXBsYXRlWydzdWdnZXN0ZWRNYXBwaW5ncyddKSB7XG4gICAgY29uc3QgZ3JvdXBlZDogUmVjb3JkPHN0cmluZywgQWRhcHRpdmVUZW1wbGF0ZVsnc3VnZ2VzdGVkTWFwcGluZ3MnXT4gPSB7fTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgbWFwcGluZ3MpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke21hcHBpbmcudGFyZ2V0Q2F0ZWdvcnl9LiR7bWFwcGluZy50YXJnZXRTdWJjYXRlZ29yeX1gO1xuICAgICAgaWYgKCFncm91cGVkW2tleV0pIGdyb3VwZWRba2V5XSA9IFtdO1xuICAgICAgZ3JvdXBlZFtrZXldLnB1c2gobWFwcGluZyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBncm91cGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYnVpbGRDb21wcmVoZW5zaXZlRGF0YShcbiAgICBwcm9jZXNzZWREYXRhOiBhbnlbXSxcbiAgICBtYXBwaW5nc0J5Q2F0ZWdvcnk6IFJlY29yZDxzdHJpbmcsIEFkYXB0aXZlVGVtcGxhdGVbJ3N1Z2dlc3RlZE1hcHBpbmdzJ10+XG4gICk6IENvbXByZWhlbnNpdmVPcGVyYXRpb25hbERhdGEge1xuICAgIGNvbnN0IHJlc3VsdDogQ29tcHJlaGVuc2l2ZU9wZXJhdGlvbmFsRGF0YSA9IHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGxhc3RQcm9jZXNzZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZ2dyZWdhdGUgZGF0YSBieSBjYXRlZ29yeVxuICAgIGNvbnN0IGFnZ3JlZ2F0ZWREYXRhID0gdGhpcy5hZ2dyZWdhdGVQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xuXG4gICAgZm9yIChjb25zdCBbY2F0ZWdvcnlLZXksIG1hcHBpbmdzXSBvZiBPYmplY3QuZW50cmllcyhtYXBwaW5nc0J5Q2F0ZWdvcnkpKSB7XG4gICAgICBjb25zdCBbY2F0ZWdvcnksIHN1YmNhdGVnb3J5XSA9IGNhdGVnb3J5S2V5LnNwbGl0KCcuJyk7XG4gICAgICBcbiAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ29wZXJhdGlvbmFsUmVwb3J0aW5nJykge1xuICAgICAgICBpZiAoIXJlc3VsdC5vcGVyYXRpb25hbFJlcG9ydGluZykgcmVzdWx0Lm9wZXJhdGlvbmFsUmVwb3J0aW5nID0ge307XG4gICAgICAgIChyZXN1bHQub3BlcmF0aW9uYWxSZXBvcnRpbmcgYXMgYW55KVtzdWJjYXRlZ29yeV0gPSBhZ2dyZWdhdGVkRGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoY2F0ZWdvcnkgPT09ICdidXNpbmVzc0ZpbmFuY2lhbHMnKSB7XG4gICAgICAgIGlmICghcmVzdWx0LmJ1c2luZXNzRmluYW5jaWFscykgcmVzdWx0LmJ1c2luZXNzRmluYW5jaWFscyA9IHt9O1xuICAgICAgICAocmVzdWx0LmJ1c2luZXNzRmluYW5jaWFscyBhcyBhbnkpW3N1YmNhdGVnb3J5XSA9IGFnZ3JlZ2F0ZWREYXRhO1xuICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeSA9PT0gJ3NhbGVzR3Jvd3RoVHJhamVjdG9yeScpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuc2FsZXNHcm93dGhUcmFqZWN0b3J5KSByZXN1bHQuc2FsZXNHcm93dGhUcmFqZWN0b3J5ID0ge307XG4gICAgICAgIChyZXN1bHQuc2FsZXNHcm93dGhUcmFqZWN0b3J5IGFzIGFueSlbc3ViY2F0ZWdvcnldID0gYWdncmVnYXRlZERhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGFnZ3JlZ2F0ZVByb2Nlc3NlZERhdGEoZGF0YTogYW55W10pOiBhbnkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xuICAgIFxuICAgIGNvbnN0IGFnZ3JlZ2F0ZWQ6IGFueSA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLm1hcChyb3cgPT4gcm93W2tleV0pLmZpbHRlcih2YWwgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIHZhbHVlc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWdncmVnYXRlZFtrZXldID0ge1xuICAgICAgICAgIHRvdGFsOiB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSxcbiAgICAgICAgICBhdmVyYWdlOiB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgbWluOiBNYXRoLm1pbiguLi52YWx1ZXMpLFxuICAgICAgICAgIG1heDogTWF0aC5tYXgoLi4udmFsdWVzKSxcbiAgICAgICAgICBjb3VudDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFtrZXldID0ge1xuICAgICAgICAgIHVuaXF1ZVZhbHVlczogQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpLFxuICAgICAgICAgIGNvdW50OiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhZ2dyZWdhdGVkO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHByaXZhdGUgc3RhdGljIGNhbGN1bGF0ZUF2ZXJhZ2VMZW5ndGgodmFsdWVzOiBhbnlbXSk6IG51bWJlciB7XG4gICAgY29uc3QgbGVuZ3RocyA9IHZhbHVlcy5tYXAodiA9PiBTdHJpbmcodikubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3Rocy5yZWR1Y2UoKHN1bSwgbGVuKSA9PiBzdW0gKyBsZW4sIDApIC8gbGVuZ3Rocy5sZW5ndGg7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjb250YWluc051bWJlcnModmFsdWVzOiBhbnlbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZXMuc29tZSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCAhaXNOYU4oTnVtYmVyKHYpKSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjb250YWluc0RhdGVzKHZhbHVlczogYW55W10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWVzLnNvbWUodiA9PiB0aGlzLmlzRGF0ZUxpa2UodikpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaXNEYXRlTGlrZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHN0cikpIHx8IC9cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezIsNH0vLnRlc3Qoc3RyKSB8fCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNsZWFuVmFsdWUodmFsdWU6IGFueSwgdGFyZ2V0RmllbGQ6IHN0cmluZyk6IGFueSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB2YWx1ZTtcbiAgICBcbiAgICBsZXQgY2xlYW5lZCA9IHZhbHVlO1xuICAgIFxuICAgIC8vIFJlbW92ZSBjb21tb24gZm9ybWF0dGluZ1xuICAgIGlmICh0eXBlb2YgY2xlYW5lZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gY3VycmVuY3kgc3ltYm9sc1xuICAgICAgaWYgKHRhcmdldEZpZWxkLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2Nvc3QnKSB8fCB0YXJnZXRGaWVsZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdhbW91bnQnKSkge1xuICAgICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9bJCxcXHNdL2csICcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gcGVyY2VudGFnZXNcbiAgICAgIGlmICh0YXJnZXRGaWVsZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwZXJjZW50JykpIHtcbiAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvJS9nLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZmxleGlibGVWYWxpZGF0aW9uKHZhbHVlOiBhbnksIG1hcHBpbmc6IEFkYXB0aXZlVGVtcGxhdGVbJ3N1Z2dlc3RlZE1hcHBpbmdzJ11bMF0pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCByZXN1bHQ6IFZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICBmaWVsZDogbWFwcGluZy50YXJnZXRGaWVsZCxcbiAgICAgIHZhbHVlLFxuICAgICAgaXNWYWxpZDogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7IC8vIEFsbG93IGVtcHR5IHZhbHVlc1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBjb252ZXJ0IHRvIGFwcHJvcHJpYXRlIHR5cGUgYmFzZWQgb24gdGFyZ2V0IGZpZWxkXG4gICAgdHJ5IHtcbiAgICAgIGlmIChtYXBwaW5nLnRhcmdldEZpZWxkLmluY2x1ZGVzKCdjb3N0JykgfHwgbWFwcGluZy50YXJnZXRGaWVsZC5pbmNsdWRlcygnYW1vdW50JykgfHwgXG4gICAgICAgICAgbWFwcGluZy50YXJnZXRGaWVsZC5pbmNsdWRlcygncXVhbnRpdHknKSB8fCBtYXBwaW5nLnRhcmdldEZpZWxkLmluY2x1ZGVzKCdjb3VudCcpKSB7XG4gICAgICAgIGNvbnN0IG51bVZhbHVlID0gcGFyc2VGbG9hdChTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgaWYgKCFpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSBudW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXBwaW5nLnRhcmdldEZpZWxkLmluY2x1ZGVzKCdwZXJjZW50JykpIHtcbiAgICAgICAgY29uc3QgbnVtVmFsdWUgPSBwYXJzZUZsb2F0KFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICBpZiAoIWlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KG51bVZhbHVlLCAwKSwgMTAwKTsgLy8gQ2xhbXAgdG8gMC0xMDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXBwaW5nLnRhcmdldEZpZWxkLmluY2x1ZGVzKCdkYXRlJykpIHtcbiAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIWlzTmFOKGRhdGVWYWx1ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gZGF0ZVZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcbiAgICAgIHJlc3VsdC5lcnJvck1lc3NhZ2UgPSBgQ291bGQgbm90IGNvbnZlcnQgJyR7dmFsdWV9JyB0byBleHBlY3RlZCB0eXBlYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlVGVtcGxhdGVDb25maWRlbmNlKG1hcHBpbmdzOiBBZGFwdGl2ZVRlbXBsYXRlWydzdWdnZXN0ZWRNYXBwaW5ncyddKTogbnVtYmVyIHtcbiAgICBpZiAobWFwcGluZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICBcbiAgICBjb25zdCBhdmdDb25maWRlbmNlID0gbWFwcGluZ3MucmVkdWNlKChzdW0sIG0pID0+IHN1bSArIG0uY29uZmlkZW5jZSwgMCkgLyBtYXBwaW5ncy5sZW5ndGg7XG4gICAgY29uc3QgY292ZXJhZ2VCb251cyA9IE1hdGgubWluKG1hcHBpbmdzLmxlbmd0aCAvIDEwLCAwLjIpOyAvLyBCb251cyBmb3IgbW9yZSBtYXBwaW5nc1xuICAgIFxuICAgIHJldHVybiBNYXRoLm1pbihhdmdDb25maWRlbmNlICsgY292ZXJhZ2VCb251cywgMSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjYWxjdWxhdGVGbGV4aWJsZURhdGFRdWFsaXR5KFxuICAgIHJhd0RhdGE6IGFueVtdLFxuICAgIHZhbGlkYXRpb25SZXN1bHRzOiBWYWxpZGF0aW9uUmVzdWx0W10sXG4gICAgdGVtcGxhdGU6IEFkYXB0aXZlVGVtcGxhdGVcbiAgKTogRGF0YVF1YWxpdHlNZXRyaWNzIHtcbiAgICBjb25zdCB0b3RhbEZpZWxkcyA9IHJhd0RhdGEubGVuZ3RoICogdGVtcGxhdGUuc3VnZ2VzdGVkTWFwcGluZ3MubGVuZ3RoO1xuICAgIGNvbnN0IHZhbGlkRmllbGRzID0gdmFsaWRhdGlvblJlc3VsdHMuZmlsdGVyKHIgPT4gci5pc1ZhbGlkKS5sZW5ndGg7XG4gICAgXG4gICAgY29uc3Qgbm9uRW1wdHlGaWVsZHMgPSB2YWxpZGF0aW9uUmVzdWx0cy5maWx0ZXIociA9PiBcbiAgICAgIHIudmFsdWUgIT09IG51bGwgJiYgci52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHIudmFsdWUgIT09ICcnXG4gICAgKS5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGxldGVuZXNzOiB0b3RhbEZpZWxkcyA+IDAgPyAobm9uRW1wdHlGaWVsZHMgLyB0b3RhbEZpZWxkcykgKiAxMDAgOiAxMDAsXG4gICAgICBhY2N1cmFjeTogdG90YWxGaWVsZHMgPiAwID8gKHZhbGlkRmllbGRzIC8gdG90YWxGaWVsZHMpICogMTAwIDogMTAwLFxuICAgICAgY29uc2lzdGVuY3k6IDk1LCAvLyBPcHRpbWlzdGljIGZvciBhZGFwdGl2ZSBwcm9jZXNzaW5nXG4gICAgICB0aW1lbGluZXNzOiAxMDAsXG4gICAgICB2YWxpZFJlY29yZHM6IE1hdGguZmxvb3IodmFsaWRGaWVsZHMgLyB0ZW1wbGF0ZS5zdWdnZXN0ZWRNYXBwaW5ncy5sZW5ndGgpLFxuICAgICAgdG90YWxSZWNvcmRzOiByYXdEYXRhLmxlbmd0aCxcbiAgICAgIG1pc3NpbmdGaWVsZHM6IFtdLFxuICAgICAgaW52YWxpZFZhbHVlczogdmFsaWRhdGlvblJlc3VsdHNcbiAgICAgICAgLmZpbHRlcihyID0+ICFyLmlzVmFsaWQpXG4gICAgICAgIC5tYXAociA9PiAoe1xuICAgICAgICAgIGZpZWxkOiByLmZpZWxkLFxuICAgICAgICAgIHZhbHVlOiByLnZhbHVlLFxuICAgICAgICAgIHJlYXNvbjogci5lcnJvck1lc3NhZ2UgfHwgJ1ZhbGlkYXRpb24gZmFpbGVkJ1xuICAgICAgICB9KSlcbiAgICB9O1xuICB9XG59XG4iXSwibmFtZXMiOlsiQWRhcHRpdmVEYXRhVmFsaWRhdG9yIiwiQ09MVU1OX1BBVFRFUk5TIiwiZ2VvZ3JhcGhpYyIsImZpbmFuY2lhbCIsInF1YW50aXR5IiwicGVyZm9ybWFuY2UiLCJ0ZW1wb3JhbCIsImlkZW50aWZpZXIiLCJkZXNjcmlwdGl2ZSIsIm9wZXJhdGlvbmFsIiwiQlVTSU5FU1NfQ09OVEVYVFMiLCJuZXR3b3JrRm9vdHByaW50Iiwib3JkZXJNYW5hZ2VtZW50IiwiaW52ZW50b3J5IiwiZmluYW5jaWFsT3BlcmF0aW9ucyIsInNhbGVzR3Jvd3RoIiwiYW5hbHl6ZUNvbHVtbnMiLCJkYXRhIiwibGVuZ3RoIiwiY29sdW1ucyIsIk9iamVjdCIsImtleXMiLCJhbmFseXNlcyIsImNvbHVtbk5hbWUiLCJ2YWx1ZXMiLCJtYXAiLCJyb3ciLCJmaWx0ZXIiLCJ2YWwiLCJ1bmRlZmluZWQiLCJzYW1wbGVWYWx1ZXMiLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJudWxsQ291bnQiLCJkZXRlY3RlZFR5cGUiLCJkZXRlY3RDb2x1bW5UeXBlIiwicGF0dGVybkFuYWx5c2lzIiwiYW5hbHl6ZUNvbHVtblBhdHRlcm5zIiwicHVzaCIsInVuaXF1ZVZhbHVlcyIsIlNldCIsInNpemUiLCJhdmdMZW5ndGgiLCJjYWxjdWxhdGVBdmVyYWdlTGVuZ3RoIiwiY29udGFpbnNOdW1iZXJzIiwiY29udGFpbnNEYXRlcyIsImNyZWF0ZUFkYXB0aXZlVGVtcGxhdGUiLCJmaWxlTmFtZSIsImNvbHVtbkFuYWx5c2lzIiwiZGF0YVBhdHRlcm5zIiwiZGV0ZWN0RGF0YVBhdHRlcm5zIiwic3VnZ2VzdGVkTWFwcGluZ3MiLCJnZW5lcmF0ZUNvbHVtbk1hcHBpbmdzIiwiY29uZmlkZW5jZSIsImNhbGN1bGF0ZVRlbXBsYXRlQ29uZmlkZW5jZSIsImlkIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwibmFtZSIsImRlc2NyaXB0aW9uIiwic291cmNlRmlsZU5hbWUiLCJwcm9jZXNzV2l0aEFkYXB0aXZlVGVtcGxhdGUiLCJhZGFwdGl2ZVRlbXBsYXRlIiwiZXJyb3JzIiwid2FybmluZ3MiLCJ2YWxpZGF0aW9uUmVzdWx0cyIsInByb2Nlc3NlZERhdGEiLCJ2YWxpZFJvd3MiLCJza2lwcGVkUm93cyIsIm1hcHBpbmdzQnlDYXRlZ29yeSIsImdyb3VwTWFwcGluZ3NCeUNhdGVnb3J5Iiwicm93SW5kZXgiLCJwcm9jZXNzZWRSb3ciLCJpc1ZhbGlkUm93IiwiaGFzQW55RGF0YSIsIm1hcHBpbmciLCJzb3VyY2VWYWx1ZSIsInNvdXJjZUNvbHVtbiIsImNsZWFuZWRWYWx1ZSIsImNsZWFuVmFsdWUiLCJ0YXJnZXRGaWVsZCIsInZhbGlkYXRpb24iLCJmbGV4aWJsZVZhbGlkYXRpb24iLCJpc1ZhbGlkIiwiZXJyb3JNZXNzYWdlIiwidmFsdWUiLCJjb21wcmVoZW5zaXZlRGF0YSIsImJ1aWxkQ29tcHJlaGVuc2l2ZURhdGEiLCJkYXRhUXVhbGl0eSIsImNhbGN1bGF0ZUZsZXhpYmxlRGF0YVF1YWxpdHkiLCJzdWNjZXNzIiwic3VtbWFyeSIsInRvdGFsUm93cyIsInR5cGVzIiwiaXNOYU4iLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwiYWRkIiwiaXNEYXRlTGlrZSIsImluY2x1ZGVzIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJBcnJheSIsImZyb20iLCJsaWtlbHlJZCIsIm1hdGNoZXNQYXR0ZXJucyIsImxpa2VseU5hbWUiLCJsaWtlbHlBZGRyZXNzIiwibGlrZWx5QW1vdW50IiwibGlrZWx5RGF0ZSIsImxpa2VseUNhdGVnb3J5IiwibGlrZWx5UXVhbnRpdHkiLCJsaWtlbHlQZXJjZW50YWdlIiwic29tZSIsInYiLCJ0ZXh0IiwicGF0dGVybnMiLCJwYXR0ZXJuIiwiYyIsImpvaW4iLCJoYXNHZW9ncmFwaGljRGF0YSIsImhhc0ZpbmFuY2lhbERhdGEiLCJoYXNEYXRlU2VxdWVuY2VzIiwiaGFzUXVhbnRpdGllcyIsImhhc0NhdGVnb3JpZXMiLCJoYXNQZXJmb3JtYW5jZU1ldHJpY3MiLCJtYXBwaW5ncyIsImNvbHVtbiIsImluZmVyQ29sdW1uTWFwcGluZyIsImZpbGVDb250ZXh0IiwidGFyZ2V0Q2F0ZWdvcnkiLCJ0YXJnZXRTdWJjYXRlZ29yeSIsInJlYXNvbmluZyIsImRldGVybWluZU9wZXJhdGlvbmFsU3ViY2F0ZWdvcnkiLCJtYXBUb1RhcmdldEZpZWxkIiwidG9GaXhlZCIsImNhdGVnb3J5Iiwic3ViY2F0ZWdvcnkiLCJmaWVsZE5hbWUiLCJyZXBsYWNlIiwiZ3JvdXBlZCIsImtleSIsInJlc3VsdCIsIm1ldGFkYXRhIiwibGFzdFByb2Nlc3NlZCIsInRvSVNPU3RyaW5nIiwiYWdncmVnYXRlZERhdGEiLCJhZ2dyZWdhdGVQcm9jZXNzZWREYXRhIiwiY2F0ZWdvcnlLZXkiLCJlbnRyaWVzIiwic3BsaXQiLCJvcGVyYXRpb25hbFJlcG9ydGluZyIsImJ1c2luZXNzRmluYW5jaWFscyIsInNhbGVzR3Jvd3RoVHJhamVjdG9yeSIsImFnZ3JlZ2F0ZWQiLCJ0b3RhbCIsInJlZHVjZSIsInN1bSIsImF2ZXJhZ2UiLCJtYXgiLCJjb3VudCIsImxlbmd0aHMiLCJsZW4iLCJzdHIiLCJwYXJzZSIsInRlc3QiLCJjbGVhbmVkIiwidHJpbSIsImZpZWxkIiwibnVtVmFsdWUiLCJkYXRlVmFsdWUiLCJnZXRUaW1lIiwiZXJyb3IiLCJhdmdDb25maWRlbmNlIiwibSIsImNvdmVyYWdlQm9udXMiLCJyYXdEYXRhIiwidGVtcGxhdGUiLCJ0b3RhbEZpZWxkcyIsInZhbGlkRmllbGRzIiwiciIsIm5vbkVtcHR5RmllbGRzIiwiY29tcGxldGVuZXNzIiwiYWNjdXJhY3kiLCJjb25zaXN0ZW5jeSIsInRpbWVsaW5lc3MiLCJ2YWxpZFJlY29yZHMiLCJmbG9vciIsInRvdGFsUmVjb3JkcyIsIm1pc3NpbmdGaWVsZHMiLCJpbnZhbGlkVmFsdWVzIiwicmVhc29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/adaptive-data-validator.ts\n");

/***/ }),

/***/ "(rsc)/./lib/data-validator.ts":
/*!*******************************!*\
  !*** ./lib/data-validator.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataProcessingUtils: () => (/* binding */ DataProcessingUtils),\n/* harmony export */   DataValidator: () => (/* binding */ DataValidator)\n/* harmony export */ });\n/* harmony import */ var _types_data_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/data-schema */ \"(rsc)/./types/data-schema.ts\");\n/* harmony import */ var _adaptive_data_validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adaptive-data-validator */ \"(rsc)/./lib/adaptive-data-validator.ts\");\n/* harmony import */ var _missing_data_imputation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./missing-data-imputation */ \"(rsc)/./lib/missing-data-imputation.ts\");\n// XLSX is imported dynamically in parseFile to avoid SSR issues\n\n\n\nclass DataValidator {\n    /**\n   * Enhanced processing with automatic missing data imputation\n   */ static async processDataWithImputationAndTemplate(rawData, template, imputationConfig = {}) {\n        if (!rawData || rawData.length === 0) {\n            throw new Error(\"No data provided for processing\");\n        }\n        // Step 1: Diagnose missing data patterns\n        const diagnosis = _missing_data_imputation__WEBPACK_IMPORTED_MODULE_2__.AdvancedDataImputation.diagnoseMissingData(rawData);\n        let imputationResult;\n        let dataToProcess = rawData;\n        // Step 2: Apply imputation if missing data is detected\n        if (diagnosis.patterns.length > 0) {\n            console.log(\"Missing data detected, applying advanced imputation...\");\n            console.log(\"Recommended method:\", diagnosis.suggestedMethod);\n            console.log(\"Missing data patterns:\", diagnosis.patterns.map((p)=>`${p.field}: ${p.missingPercentage.toFixed(1)}% missing (${p.pattern})`));\n            try {\n                imputationResult = await _missing_data_imputation__WEBPACK_IMPORTED_MODULE_2__.AdvancedDataImputation.imputeMissingData(rawData, {\n                    ...imputationConfig,\n                    method: imputationConfig.method || diagnosis.suggestedMethod\n                });\n                dataToProcess = imputationResult.data;\n                console.log(`Imputation completed: ${imputationResult.statistics.totalImputed} values imputed with ${imputationResult.statistics.averageConfidence.toFixed(2)} average confidence`);\n            } catch (error) {\n                console.warn(\"Imputation failed, proceeding with original data:\", error);\n            }\n        }\n        // Step 3: Process the data (imputed or original) with the template\n        const processingResult = this.processDataWithTemplate(dataToProcess, template);\n        // Step 4: Enhance metadata with imputation information\n        if (processingResult.data?.metadata && imputationResult) {\n            processingResult.data.metadata.imputationInfo = {\n                methodUsed: imputationResult.statistics.methodsUsed,\n                totalImputed: imputationResult.statistics.totalImputed,\n                averageConfidence: imputationResult.statistics.averageConfidence,\n                qualityMetrics: imputationResult.qualityMetrics,\n                imputedFields: imputationResult.imputedFields.map((field)=>({\n                        field: field.field,\n                        rowIndex: field.rowIndex,\n                        confidence: field.confidence,\n                        method: field.method\n                    }))\n            };\n        }\n        return {\n            processingResult,\n            imputationResult\n        };\n    }\n    /**\n   * Diagnose missing data patterns in a dataset\n   */ static diagnoseMissingDataPatterns(data) {\n        return _missing_data_imputation__WEBPACK_IMPORTED_MODULE_2__.AdvancedDataImputation.diagnoseMissingData(data);\n    }\n    /**\n   * Apply standalone imputation to data\n   */ static async imputeMissingData(data, config = {}) {\n        return _missing_data_imputation__WEBPACK_IMPORTED_MODULE_2__.AdvancedDataImputation.imputeMissingData(data, config);\n    }\n    // Validate individual field values\n    static validateFieldValue(value, mapping) {\n        const result = {\n            field: mapping.targetField,\n            value,\n            isValid: true\n        };\n        // Check if required field is missing\n        if (mapping.required && (value === null || value === undefined || value === \"\")) {\n            result.isValid = false;\n            result.errorMessage = `Required field '${mapping.targetField}' is missing`;\n            return result;\n        }\n        // Skip validation for optional empty fields\n        if (!mapping.required && (value === null || value === undefined || value === \"\")) {\n            return result;\n        }\n        // Type validation\n        switch(mapping.dataType){\n            case \"number\":\n                const numValue = typeof value === \"string\" ? parseFloat(value) : value;\n                if (isNaN(numValue)) {\n                    result.isValid = false;\n                    result.errorMessage = `Expected number, got '${value}'`;\n                    result.suggestion = \"Ensure this field contains only numeric values\";\n                } else {\n                    result.value = numValue;\n                    // Range validation\n                    if (mapping.validation?.min !== undefined && numValue < mapping.validation.min) {\n                        result.isValid = false;\n                        result.errorMessage = `Value ${numValue} is below minimum ${mapping.validation.min}`;\n                    }\n                    if (mapping.validation?.max !== undefined && numValue > mapping.validation.max) {\n                        result.isValid = false;\n                        result.errorMessage = `Value ${numValue} is above maximum ${mapping.validation.max}`;\n                    }\n                }\n                break;\n            case \"string\":\n                const strValue = String(value).trim();\n                result.value = strValue;\n                // Pattern validation\n                if (mapping.validation?.pattern) {\n                    const regex = new RegExp(mapping.validation.pattern);\n                    if (!regex.test(strValue)) {\n                        result.isValid = false;\n                        result.errorMessage = `Value '${strValue}' does not match required pattern`;\n                    }\n                }\n                // Allowed values validation\n                if (mapping.validation?.allowedValues && !mapping.validation.allowedValues.includes(strValue)) {\n                    result.isValid = false;\n                    result.errorMessage = `Value '${strValue}' is not in allowed values: ${mapping.validation.allowedValues.join(\", \")}`;\n                }\n                break;\n            case \"boolean\":\n                if (typeof value === \"boolean\") {\n                    result.value = value;\n                } else {\n                    const strValue = String(value).toLowerCase().trim();\n                    if ([\n                        \"true\",\n                        \"1\",\n                        \"yes\",\n                        \"y\"\n                    ].includes(strValue)) {\n                        result.value = true;\n                    } else if ([\n                        \"false\",\n                        \"0\",\n                        \"no\",\n                        \"n\"\n                    ].includes(strValue)) {\n                        result.value = false;\n                    } else {\n                        result.isValid = false;\n                        result.errorMessage = `Cannot convert '${value}' to boolean`;\n                    }\n                }\n                break;\n            case \"date\":\n                const dateValue = new Date(value);\n                if (isNaN(dateValue.getTime())) {\n                    result.isValid = false;\n                    result.errorMessage = `Invalid date format: '${value}'`;\n                } else {\n                    result.value = dateValue.toISOString();\n                }\n                break;\n        }\n        return result;\n    }\n    // Process raw data using mapping template (traditional or adaptive)\n    static processDataWithTemplate(rawData, template) {\n        // Check if this is an adaptive template\n        if (\"suggestedMappings\" in template) {\n            return _adaptive_data_validator__WEBPACK_IMPORTED_MODULE_1__.AdaptiveDataValidator.processWithAdaptiveTemplate(rawData, template);\n        }\n        // Continue with traditional processing\n        const errors = [];\n        const warnings = [];\n        const validationResults = [];\n        const processedData = [];\n        let validRows = 0;\n        let skippedRows = 0;\n        for(let rowIndex = 0; rowIndex < rawData.length; rowIndex++){\n            const row = rawData[rowIndex];\n            const processedRow = {};\n            let isValidRow = true;\n            let hasRequiredFields = false;\n            // Check for required columns\n            for (const requiredColumn of template.requiredColumns){\n                if (!(requiredColumn in row) || row[requiredColumn] === null || row[requiredColumn] === undefined || row[requiredColumn] === \"\") {\n                    errors.push(`Row ${rowIndex + 1}: Missing required column '${requiredColumn}'`);\n                    isValidRow = false;\n                } else {\n                    hasRequiredFields = true;\n                }\n            }\n            if (!hasRequiredFields) {\n                skippedRows++;\n                continue;\n            }\n            // Process each mapped field\n            for (const mapping of template.mappings){\n                const sourceValue = row[mapping.sourceColumn];\n                const validation = this.validateFieldValue(sourceValue, mapping);\n                validationResults.push(validation);\n                if (!validation.isValid) {\n                    errors.push(`Row ${rowIndex + 1}, Field '${mapping.targetField}': ${validation.errorMessage}`);\n                    isValidRow = false;\n                } else {\n                    processedRow[mapping.targetField] = validation.value;\n                }\n            }\n            if (isValidRow) {\n                processedData.push(processedRow);\n                validRows++;\n            } else {\n                skippedRows++;\n            }\n        }\n        // Calculate data quality metrics\n        const dataQuality = this.calculateDataQuality(rawData, validationResults, template);\n        // Build comprehensive operational data structure\n        const comprehensiveData = {\n            metadata: {\n                dataQuality,\n                validationResults,\n                lastProcessed: new Date().toISOString()\n            }\n        };\n        // Map processed data to appropriate category structure\n        if (template.targetCategory === \"operationalReporting\") {\n            comprehensiveData.operationalReporting = {\n                [template.targetSubcategory]: this.aggregateData(processedData)\n            };\n        } else if (template.targetCategory === \"businessFinancials\") {\n            comprehensiveData.businessFinancials = {\n                [template.targetSubcategory]: this.aggregateData(processedData)\n            };\n        } else if (template.targetCategory === \"salesGrowthTrajectory\") {\n            comprehensiveData.salesGrowthTrajectory = {\n                [template.targetSubcategory]: this.aggregateData(processedData)\n            };\n        }\n        return {\n            success: errors.length === 0,\n            data: comprehensiveData,\n            errors,\n            warnings,\n            summary: {\n                totalRows: rawData.length,\n                validRows,\n                skippedRows,\n                dataQuality\n            }\n        };\n    }\n    // Aggregate array data into summary metrics\n    static aggregateData(data) {\n        if (data.length === 0) return {};\n        const aggregated = {};\n        const keys = Object.keys(data[0]);\n        for (const key of keys){\n            const values = data.map((row)=>row[key]).filter((val)=>val !== null && val !== undefined);\n            if (values.length === 0) continue;\n            const firstValue = values[0];\n            if (typeof firstValue === \"number\") {\n                // For numeric fields, calculate statistics\n                aggregated[key] = {\n                    total: values.reduce((sum, val)=>sum + val, 0),\n                    average: values.reduce((sum, val)=>sum + val, 0) / values.length,\n                    min: Math.min(...values),\n                    max: Math.max(...values),\n                    count: values.length,\n                    values: values // Keep individual values for detailed analysis\n                };\n            } else {\n                // For non-numeric fields, keep unique values\n                const uniqueValues = Array.from(new Set(values));\n                aggregated[key] = {\n                    uniqueValues,\n                    count: values.length,\n                    values: values\n                };\n            }\n        }\n        return aggregated;\n    }\n    // Calculate comprehensive data quality metrics\n    static calculateDataQuality(rawData, validationResults, template) {\n        const totalFields = rawData.length * template.mappings.length;\n        const validFields = validationResults.filter((r)=>r.isValid).length;\n        const requiredFieldsCount = rawData.length * template.requiredColumns.length;\n        const filledRequiredFields = validationResults.filter((r)=>r.isValid && template.requiredColumns.some((col)=>template.mappings.find((m)=>m.sourceColumn === col)?.targetField === r.field)).length;\n        const missingFields = template.mappings.filter((mapping)=>!rawData.some((row)=>row[mapping.sourceColumn] !== null && row[mapping.sourceColumn] !== undefined)).map((mapping)=>mapping.sourceColumn);\n        const invalidValues = validationResults.filter((r)=>!r.isValid).map((r)=>({\n                field: r.field,\n                value: r.value,\n                reason: r.errorMessage || \"Unknown validation error\"\n            }));\n        return {\n            completeness: requiredFieldsCount > 0 ? filledRequiredFields / requiredFieldsCount * 100 : 100,\n            accuracy: totalFields > 0 ? validFields / totalFields * 100 : 100,\n            consistency: 100,\n            timeliness: 100,\n            validRecords: validationResults.filter((r)=>r.isValid).length,\n            totalRecords: rawData.length,\n            missingFields,\n            invalidValues\n        };\n    }\n    // Enhanced template detection with adaptive fallback\n    static detectDataTemplate(columnHeaders, fileName, data) {\n        // First try traditional template matching\n        let bestMatch = null;\n        for (const template of _types_data_schema__WEBPACK_IMPORTED_MODULE_0__.DATA_MAPPING_TEMPLATES){\n            let score = 0;\n            // Calculate match score based on column presence\n            for (const mapping of template.mappings){\n                if (columnHeaders.some((header)=>header.toLowerCase().includes(mapping.sourceColumn.toLowerCase()) || mapping.sourceColumn.toLowerCase().includes(header.toLowerCase()))) {\n                    score += mapping.required ? 2 : 1; // Weight required fields more heavily\n                }\n            }\n            // Normalize score by template size\n            const normalizedScore = score / template.mappings.length;\n            if (!bestMatch || normalizedScore > bestMatch.score) {\n                bestMatch = {\n                    template,\n                    score: normalizedScore\n                };\n            }\n        }\n        // If traditional matching found a good match, use it\n        if (bestMatch && bestMatch.score > 0.5) {\n            return bestMatch.template;\n        }\n        // Otherwise, create adaptive template\n        if (fileName && data && data.length > 0) {\n            try {\n                const columnAnalysis = _adaptive_data_validator__WEBPACK_IMPORTED_MODULE_1__.AdaptiveDataValidator.analyzeColumns(data);\n                const adaptiveTemplate = _adaptive_data_validator__WEBPACK_IMPORTED_MODULE_1__.AdaptiveDataValidator.createAdaptiveTemplate(fileName, data, columnAnalysis);\n                // Only return adaptive template if it has reasonable confidence\n                if (adaptiveTemplate.confidence > 0.2) {\n                    return adaptiveTemplate;\n                }\n            } catch (error) {\n                console.warn(\"Failed to create adaptive template:\", error);\n            }\n        }\n        // Return best traditional match even if score is low, or null\n        return bestMatch?.template || null;\n    }\n    // Parse Excel/CSV file and extract data\n    static async parseFile(file) {\n        // Ensure this runs only on client side\n        if (true) {\n            throw new Error(\"File parsing is only available on the client side\");\n        }\n        try {\n            // Dynamically import XLSX to avoid SSR issues\n            const XLSX = await __webpack_require__.e(/*! import() */ \"vendor-chunks/xlsx\").then(__webpack_require__.bind(__webpack_require__, /*! xlsx */ \"(rsc)/./node_modules/xlsx/xlsx.mjs\"));\n            return new Promise((resolve, reject)=>{\n                const reader = new FileReader();\n                reader.onload = (e)=>{\n                    try {\n                        const data = e.target?.result;\n                        let workbook;\n                        if (file.type.includes(\"csv\")) {\n                            workbook = XLSX.read(data, {\n                                type: \"binary\"\n                            });\n                        } else {\n                            workbook = XLSX.read(data, {\n                                type: \"array\"\n                            });\n                        }\n                        const sheetName = workbook.SheetNames[0];\n                        const worksheet = workbook.Sheets[sheetName];\n                        const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                            header: 1\n                        });\n                        if (jsonData.length === 0) {\n                            reject(new Error(\"File contains no data\"));\n                            return;\n                        }\n                        const columnHeaders = jsonData[0];\n                        const dataRows = jsonData.slice(1).map((row)=>{\n                            const rowObj = {};\n                            columnHeaders.forEach((header, index)=>{\n                                rowObj[header] = row[index];\n                            });\n                            return rowObj;\n                        });\n                        resolve({\n                            data: dataRows,\n                            columnHeaders\n                        });\n                    } catch (error) {\n                        reject(new Error(`Failed to parse file: ${error}`));\n                    }\n                };\n                reader.onerror = ()=>reject(new Error(\"Failed to read file\"));\n                if (file.type.includes(\"csv\")) {\n                    reader.readAsText(file);\n                } else {\n                    reader.readAsArrayBuffer(file);\n                }\n            });\n        } catch (error) {\n            throw new Error(`Failed to process file: ${error}`);\n        }\n    }\n    /**\n   * Extract pallet and carton data from spreadsheet\n   * @param data Parsed JSON data from the file\n   * @returns Object containing units per carton and cartons per pallet\n   */ static extractCartonPalletData(data) {\n        const result = {};\n        if (!data || data.length === 0) return result;\n        // Look for column names that might contain carton/pallet data\n        const columnMappings = {\n            units_per_carton: [\n                \"units per carton\",\n                \"units/carton\",\n                \"unit per carton\",\n                \"upc\",\n                \"units_per_carton\",\n                \"carton_size\"\n            ],\n            cartons_per_pallet: [\n                \"cartons per pallet\",\n                \"cartons/pallet\",\n                \"carton per pallet\",\n                \"cpp\",\n                \"cartons_per_pallet\",\n                \"pallet_size\"\n            ],\n            days_on_hand: [\n                \"days on hand\",\n                \"doh\",\n                \"days_on_hand\",\n                \"inventory_days\",\n                \"stock_days\"\n            ]\n        };\n        // Find relevant columns\n        const firstRow = data[0];\n        const columnNames = Object.keys(firstRow).map((col)=>col.toLowerCase().trim());\n        const foundColumns = {};\n        Object.entries(columnMappings).forEach(([key, patterns])=>{\n            const matchingColumn = columnNames.find((col)=>patterns.some((pattern)=>col.includes(pattern.toLowerCase())));\n            if (matchingColumn) {\n                foundColumns[key] = Object.keys(firstRow)[columnNames.indexOf(matchingColumn)];\n            }\n        });\n        // Extract values from the data\n        if (foundColumns.units_per_carton) {\n            const values = data.map((row)=>row[foundColumns.units_per_carton]).filter((val)=>val && !isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (values.length > 0) {\n                // Use the most common value or average\n                result.units_per_carton = Math.round(values.reduce((sum, val)=>sum + val, 0) / values.length);\n            }\n        }\n        if (foundColumns.cartons_per_pallet) {\n            const values = data.map((row)=>row[foundColumns.cartons_per_pallet]).filter((val)=>val && !isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (values.length > 0) {\n                result.cartons_per_pallet = Math.round(values.reduce((sum, val)=>sum + val, 0) / values.length);\n            }\n        }\n        if (foundColumns.days_on_hand) {\n            const values = data.map((row)=>row[foundColumns.days_on_hand]).filter((val)=>val && !isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (values.length > 0) {\n                result.days_on_hand = Math.round(values.reduce((sum, val)=>sum + val, 0) / values.length);\n            }\n        }\n        // If no columns found, try to extract from any numeric data that makes sense\n        if (!result.units_per_carton && !result.cartons_per_pallet) {\n            // Look for reasonable default patterns in the data\n            const numericColumns = Object.keys(firstRow).filter((col)=>{\n                const values = data.slice(0, 10).map((row)=>row[col]).filter((val)=>!isNaN(parseFloat(val)));\n                return values.length > 5; // Column has mostly numeric data\n            });\n            numericColumns.forEach((col)=>{\n                const values = data.map((row)=>parseFloat(row[col])).filter((val)=>!isNaN(val));\n                const avg = values.reduce((sum, val)=>sum + val, 0) / values.length;\n                const colName = col.toLowerCase();\n                // Heuristics for common ranges\n                if (avg >= 6 && avg <= 100 && colName.includes(\"carton\")) {\n                    result.units_per_carton = Math.round(avg);\n                } else if (avg >= 20 && avg <= 200 && colName.includes(\"pallet\")) {\n                    result.cartons_per_pallet = Math.round(avg);\n                } else if (avg >= 30 && avg <= 500 && (colName.includes(\"day\") || colName.includes(\"doh\"))) {\n                    result.days_on_hand = Math.round(avg);\n                }\n            });\n        }\n        return result;\n    }\n    /**\n   * Extract metadata from parsed data\n   * @param data Parsed JSON data from the file\n   * @param fileName Original file name\n   * @returns Object containing metadata about the data\n   */ static extractMetadata(data, fileName) {\n        if (!data || data.length === 0) {\n            return {\n                rowCount: 0,\n                columnCount: 0,\n                fileName,\n                processingDate: new Date().toISOString()\n            };\n        }\n        const firstRow = data[0];\n        const columns = Object.keys(firstRow);\n        const cartonPalletData = DataValidator.extractCartonPalletData(data);\n        return {\n            rowCount: data.length,\n            columnCount: columns.length,\n            columns: columns,\n            fileName,\n            processingDate: new Date().toISOString(),\n            dataTypes: DataValidator.analyzeColumnTypes(data),\n            sampleData: data.slice(0, 3),\n            ...cartonPalletData // Include carton/pallet data in metadata\n        };\n    }\n    /**\n   * Analyze column types in the data\n   * @param data Parsed data array\n   * @returns Object mapping column names to detected types\n   */ static analyzeColumnTypes(data) {\n        if (!data || data.length === 0) return {};\n        const firstRow = data[0];\n        const typeAnalysis = {};\n        Object.keys(firstRow).forEach((column)=>{\n            const sampleValues = data.slice(0, 10).map((row)=>row[column]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            if (sampleValues.length === 0) {\n                typeAnalysis[column] = \"empty\";\n                return;\n            }\n            const numericValues = sampleValues.filter((val)=>!isNaN(parseFloat(val)));\n            const dateValues = sampleValues.filter((val)=>!isNaN(Date.parse(val)));\n            if (numericValues.length === sampleValues.length) {\n                typeAnalysis[column] = \"number\";\n            } else if (dateValues.length === sampleValues.length) {\n                typeAnalysis[column] = \"date\";\n            } else {\n                typeAnalysis[column] = \"string\";\n            }\n        });\n        return typeAnalysis;\n    }\n}\n// Utility functions for data processing\nconst DataProcessingUtils = {\n    // Format validation results for display\n    formatValidationResults: (results)=>{\n        const errors = results.filter((r)=>!r.isValid);\n        if (errors.length === 0) return \"All data validation checks passed successfully.\";\n        return `Found ${errors.length} validation errors:\\n${errors.map((r)=>` ${r.field}: ${r.errorMessage}`).join(\"\\n\")}`;\n    },\n    // Format data quality metrics for display\n    formatDataQuality: (quality)=>{\n        return `Data Quality Assessment:\n Completeness: ${quality.completeness.toFixed(1)}%\n Accuracy: ${quality.accuracy.toFixed(1)}%\n Valid Records: ${quality.validRecords}/${quality.totalRecords}\n${quality.missingFields.length > 0 ? ` Missing Fields: ${quality.missingFields.join(\", \")}` : \"\"}\n${quality.invalidValues.length > 0 ? ` Invalid Values: ${quality.invalidValues.length} found` : \"\"}`;\n    },\n    // Generate processing summary\n    generateProcessingSummary: (result)=>{\n        const { summary, errors, warnings } = result;\n        return `Processing Complete:\n Total Rows: ${summary.totalRows}\n Valid Rows: ${summary.validRows}\n Skipped Rows: ${summary.skippedRows}\n Success Rate: ${(summary.validRows / summary.totalRows * 100).toFixed(1)}%\n${errors.length > 0 ? `\\nErrors (${errors.length}):\\n${errors.slice(0, 5).join(\"\\n\")}${errors.length > 5 ? \"\\n...\" : \"\"}` : \"\"}\n${warnings.length > 0 ? `\\nWarnings (${warnings.length}):\\n${warnings.slice(0, 3).join(\"\\n\")}${warnings.length > 3 ? \"\\n...\" : \"\"}` : \"\"}`;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsQ0FBQztJQUN4STtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXR3b3J4LWVzc2VudGlhbHMvLi9saWIvZGF0YS12YWxpZGF0b3IudHM/YzE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBYTFNYIGlzIGltcG9ydGVkIGR5bmFtaWNhbGx5IGluIHBhcnNlRmlsZSB0byBhdm9pZCBTU1IgaXNzdWVzXG5pbXBvcnQgdHlwZSB7XG4gIENvbXByZWhlbnNpdmVPcGVyYXRpb25hbERhdGEsXG4gIERhdGFRdWFsaXR5TWV0cmljcyxcbiAgVmFsaWRhdGlvblJlc3VsdCxcbiAgUHJvY2Vzc2luZ1Jlc3VsdCxcbiAgRGF0YUZpZWxkTWFwcGluZyxcbiAgRGF0YU1hcHBpbmdUZW1wbGF0ZVxufSBmcm9tICdAL3R5cGVzL2RhdGEtc2NoZW1hJztcbmltcG9ydCB7IERBVEFfTUFQUElOR19URU1QTEFURVMgfSBmcm9tICdAL3R5cGVzL2RhdGEtc2NoZW1hJztcbmltcG9ydCB7IEFkYXB0aXZlRGF0YVZhbGlkYXRvciwgdHlwZSBBZGFwdGl2ZVRlbXBsYXRlIH0gZnJvbSAnLi9hZGFwdGl2ZS1kYXRhLXZhbGlkYXRvcic7XG5pbXBvcnQgeyBBZHZhbmNlZERhdGFJbXB1dGF0aW9uLCB0eXBlIEltcHV0YXRpb25Db25maWcsIHR5cGUgSW1wdXRhdGlvblJlc3VsdCB9IGZyb20gJy4vbWlzc2luZy1kYXRhLWltcHV0YXRpb24nO1xuXG5leHBvcnQgY2xhc3MgRGF0YVZhbGlkYXRvciB7XG5cbiAgLyoqXG4gICAqIEVuaGFuY2VkIHByb2Nlc3Npbmcgd2l0aCBhdXRvbWF0aWMgbWlzc2luZyBkYXRhIGltcHV0YXRpb25cbiAgICovXG4gIHN0YXRpYyBhc3luYyBwcm9jZXNzRGF0YVdpdGhJbXB1dGF0aW9uQW5kVGVtcGxhdGUoXG4gICAgcmF3RGF0YTogYW55W10sXG4gICAgdGVtcGxhdGU6IERhdGFNYXBwaW5nVGVtcGxhdGUgfCBBZGFwdGl2ZVRlbXBsYXRlLFxuICAgIGltcHV0YXRpb25Db25maWc6IFBhcnRpYWw8SW1wdXRhdGlvbkNvbmZpZz4gPSB7fVxuICApOiBQcm9taXNlPHtcbiAgICBwcm9jZXNzaW5nUmVzdWx0OiBQcm9jZXNzaW5nUmVzdWx0O1xuICAgIGltcHV0YXRpb25SZXN1bHQ/OiBJbXB1dGF0aW9uUmVzdWx0O1xuICB9PiB7XG4gICAgaWYgKCFyYXdEYXRhIHx8IHJhd0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgcHJvdmlkZWQgZm9yIHByb2Nlc3NpbmcnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDE6IERpYWdub3NlIG1pc3NpbmcgZGF0YSBwYXR0ZXJuc1xuICAgIGNvbnN0IGRpYWdub3NpcyA9IEFkdmFuY2VkRGF0YUltcHV0YXRpb24uZGlhZ25vc2VNaXNzaW5nRGF0YShyYXdEYXRhKTtcblxuICAgIGxldCBpbXB1dGF0aW9uUmVzdWx0OiBJbXB1dGF0aW9uUmVzdWx0IHwgdW5kZWZpbmVkO1xuICAgIGxldCBkYXRhVG9Qcm9jZXNzID0gcmF3RGF0YTtcblxuICAgIC8vIFN0ZXAgMjogQXBwbHkgaW1wdXRhdGlvbiBpZiBtaXNzaW5nIGRhdGEgaXMgZGV0ZWN0ZWRcbiAgICBpZiAoZGlhZ25vc2lzLnBhdHRlcm5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW5nIGRhdGEgZGV0ZWN0ZWQsIGFwcGx5aW5nIGFkdmFuY2VkIGltcHV0YXRpb24uLi4nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNvbW1lbmRlZCBtZXRob2Q6JywgZGlhZ25vc2lzLnN1Z2dlc3RlZE1ldGhvZCk7XG4gICAgICBjb25zb2xlLmxvZygnTWlzc2luZyBkYXRhIHBhdHRlcm5zOicsIGRpYWdub3Npcy5wYXR0ZXJucy5tYXAocCA9PlxuICAgICAgICBgJHtwLmZpZWxkfTogJHtwLm1pc3NpbmdQZXJjZW50YWdlLnRvRml4ZWQoMSl9JSBtaXNzaW5nICgke3AucGF0dGVybn0pYFxuICAgICAgKSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGltcHV0YXRpb25SZXN1bHQgPSBhd2FpdCBBZHZhbmNlZERhdGFJbXB1dGF0aW9uLmltcHV0ZU1pc3NpbmdEYXRhKFxuICAgICAgICAgIHJhd0RhdGEsXG4gICAgICAgICAgeyAuLi5pbXB1dGF0aW9uQ29uZmlnLCBtZXRob2Q6IGltcHV0YXRpb25Db25maWcubWV0aG9kIHx8IGRpYWdub3Npcy5zdWdnZXN0ZWRNZXRob2QgYXMgYW55IH1cbiAgICAgICAgKTtcblxuICAgICAgICBkYXRhVG9Qcm9jZXNzID0gaW1wdXRhdGlvblJlc3VsdC5kYXRhO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBJbXB1dGF0aW9uIGNvbXBsZXRlZDogJHtpbXB1dGF0aW9uUmVzdWx0LnN0YXRpc3RpY3MudG90YWxJbXB1dGVkfSB2YWx1ZXMgaW1wdXRlZCB3aXRoICR7aW1wdXRhdGlvblJlc3VsdC5zdGF0aXN0aWNzLmF2ZXJhZ2VDb25maWRlbmNlLnRvRml4ZWQoMil9IGF2ZXJhZ2UgY29uZmlkZW5jZWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbXB1dGF0aW9uIGZhaWxlZCwgcHJvY2VlZGluZyB3aXRoIG9yaWdpbmFsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMzogUHJvY2VzcyB0aGUgZGF0YSAoaW1wdXRlZCBvciBvcmlnaW5hbCkgd2l0aCB0aGUgdGVtcGxhdGVcbiAgICBjb25zdCBwcm9jZXNzaW5nUmVzdWx0ID0gdGhpcy5wcm9jZXNzRGF0YVdpdGhUZW1wbGF0ZShkYXRhVG9Qcm9jZXNzLCB0ZW1wbGF0ZSk7XG5cbiAgICAvLyBTdGVwIDQ6IEVuaGFuY2UgbWV0YWRhdGEgd2l0aCBpbXB1dGF0aW9uIGluZm9ybWF0aW9uXG4gICAgaWYgKHByb2Nlc3NpbmdSZXN1bHQuZGF0YT8ubWV0YWRhdGEgJiYgaW1wdXRhdGlvblJlc3VsdCkge1xuICAgICAgcHJvY2Vzc2luZ1Jlc3VsdC5kYXRhLm1ldGFkYXRhLmltcHV0YXRpb25JbmZvID0ge1xuICAgICAgICBtZXRob2RVc2VkOiBpbXB1dGF0aW9uUmVzdWx0LnN0YXRpc3RpY3MubWV0aG9kc1VzZWQsXG4gICAgICAgIHRvdGFsSW1wdXRlZDogaW1wdXRhdGlvblJlc3VsdC5zdGF0aXN0aWNzLnRvdGFsSW1wdXRlZCxcbiAgICAgICAgYXZlcmFnZUNvbmZpZGVuY2U6IGltcHV0YXRpb25SZXN1bHQuc3RhdGlzdGljcy5hdmVyYWdlQ29uZmlkZW5jZSxcbiAgICAgICAgcXVhbGl0eU1ldHJpY3M6IGltcHV0YXRpb25SZXN1bHQucXVhbGl0eU1ldHJpY3MsXG4gICAgICAgIGltcHV0ZWRGaWVsZHM6IGltcHV0YXRpb25SZXN1bHQuaW1wdXRlZEZpZWxkcy5tYXAoZmllbGQgPT4gKHtcbiAgICAgICAgICBmaWVsZDogZmllbGQuZmllbGQsXG4gICAgICAgICAgcm93SW5kZXg6IGZpZWxkLnJvd0luZGV4LFxuICAgICAgICAgIGNvbmZpZGVuY2U6IGZpZWxkLmNvbmZpZGVuY2UsXG4gICAgICAgICAgbWV0aG9kOiBmaWVsZC5tZXRob2RcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzaW5nUmVzdWx0LFxuICAgICAgaW1wdXRhdGlvblJlc3VsdFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlhZ25vc2UgbWlzc2luZyBkYXRhIHBhdHRlcm5zIGluIGEgZGF0YXNldFxuICAgKi9cbiAgc3RhdGljIGRpYWdub3NlTWlzc2luZ0RhdGFQYXR0ZXJucyhkYXRhOiBhbnlbXSk6IHtcbiAgICBwYXR0ZXJuczogYW55W107XG4gICAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgICBzdWdnZXN0ZWRNZXRob2Q6IHN0cmluZztcbiAgfSB7XG4gICAgcmV0dXJuIEFkdmFuY2VkRGF0YUltcHV0YXRpb24uZGlhZ25vc2VNaXNzaW5nRGF0YShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBzdGFuZGFsb25lIGltcHV0YXRpb24gdG8gZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGltcHV0ZU1pc3NpbmdEYXRhKFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGNvbmZpZzogUGFydGlhbDxJbXB1dGF0aW9uQ29uZmlnPiA9IHt9XG4gICk6IFByb21pc2U8SW1wdXRhdGlvblJlc3VsdD4ge1xuICAgIHJldHVybiBBZHZhbmNlZERhdGFJbXB1dGF0aW9uLmltcHV0ZU1pc3NpbmdEYXRhKGRhdGEsIGNvbmZpZyk7XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIGluZGl2aWR1YWwgZmllbGQgdmFsdWVzXG4gIHN0YXRpYyB2YWxpZGF0ZUZpZWxkVmFsdWUoXG4gICAgdmFsdWU6IGFueSxcbiAgICBtYXBwaW5nOiBEYXRhRmllbGRNYXBwaW5nXG4gICk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IHJlc3VsdDogVmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgIGZpZWxkOiBtYXBwaW5nLnRhcmdldEZpZWxkLFxuICAgICAgdmFsdWUsXG4gICAgICBpc1ZhbGlkOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHJlcXVpcmVkIGZpZWxkIGlzIG1pc3NpbmdcbiAgICBpZiAobWFwcGluZy5yZXF1aXJlZCAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpKSB7XG4gICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgcmVzdWx0LmVycm9yTWVzc2FnZSA9IGBSZXF1aXJlZCBmaWVsZCAnJHttYXBwaW5nLnRhcmdldEZpZWxkfScgaXMgbWlzc2luZ2A7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFNraXAgdmFsaWRhdGlvbiBmb3Igb3B0aW9uYWwgZW1wdHkgZmllbGRzXG4gICAgaWYgKCFtYXBwaW5nLnJlcXVpcmVkICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gVHlwZSB2YWxpZGF0aW9uXG4gICAgc3dpdGNoIChtYXBwaW5nLmRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjb25zdCBudW1WYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoaXNOYU4obnVtVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gYEV4cGVjdGVkIG51bWJlciwgZ290ICcke3ZhbHVlfSdgO1xuICAgICAgICAgIHJlc3VsdC5zdWdnZXN0aW9uID0gJ0Vuc3VyZSB0aGlzIGZpZWxkIGNvbnRhaW5zIG9ubHkgbnVtZXJpYyB2YWx1ZXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IG51bVZhbHVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJhbmdlIHZhbGlkYXRpb25cbiAgICAgICAgICBpZiAobWFwcGluZy52YWxpZGF0aW9uPy5taW4gIT09IHVuZGVmaW5lZCAmJiBudW1WYWx1ZSA8IG1hcHBpbmcudmFsaWRhdGlvbi5taW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gYFZhbHVlICR7bnVtVmFsdWV9IGlzIGJlbG93IG1pbmltdW0gJHttYXBwaW5nLnZhbGlkYXRpb24ubWlufWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXBwaW5nLnZhbGlkYXRpb24/Lm1heCAhPT0gdW5kZWZpbmVkICYmIG51bVZhbHVlID4gbWFwcGluZy52YWxpZGF0aW9uLm1heCkge1xuICAgICAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvck1lc3NhZ2UgPSBgVmFsdWUgJHtudW1WYWx1ZX0gaXMgYWJvdmUgbWF4aW11bSAke21hcHBpbmcudmFsaWRhdGlvbi5tYXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKS50cmltKCk7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHN0clZhbHVlO1xuICAgICAgICBcbiAgICAgICAgLy8gUGF0dGVybiB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChtYXBwaW5nLnZhbGlkYXRpb24/LnBhdHRlcm4pIHtcbiAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAobWFwcGluZy52YWxpZGF0aW9uLnBhdHRlcm4pO1xuICAgICAgICAgIGlmICghcmVnZXgudGVzdChzdHJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gYFZhbHVlICcke3N0clZhbHVlfScgZG9lcyBub3QgbWF0Y2ggcmVxdWlyZWQgcGF0dGVybmA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBbGxvd2VkIHZhbHVlcyB2YWxpZGF0aW9uXG4gICAgICAgIGlmIChtYXBwaW5nLnZhbGlkYXRpb24/LmFsbG93ZWRWYWx1ZXMgJiYgXG4gICAgICAgICAgICAhbWFwcGluZy52YWxpZGF0aW9uLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMoc3RyVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gYFZhbHVlICcke3N0clZhbHVlfScgaXMgbm90IGluIGFsbG93ZWQgdmFsdWVzOiAke21hcHBpbmcudmFsaWRhdGlvbi5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9YDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgICBpZiAoWyd0cnVlJywgJzEnLCAneWVzJywgJ3knXS5pbmNsdWRlcyhzdHJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChbJ2ZhbHNlJywgJzAnLCAnbm8nLCAnbiddLmluY2x1ZGVzKHN0clZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JNZXNzYWdlID0gYENhbm5vdCBjb252ZXJ0ICcke3ZhbHVlfScgdG8gYm9vbGVhbmA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICBpZiAoaXNOYU4oZGF0ZVZhbHVlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgIHJlc3VsdC5lcnJvck1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlIGZvcm1hdDogJyR7dmFsdWV9J2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gZGF0ZVZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFByb2Nlc3MgcmF3IGRhdGEgdXNpbmcgbWFwcGluZyB0ZW1wbGF0ZSAodHJhZGl0aW9uYWwgb3IgYWRhcHRpdmUpXG4gIHN0YXRpYyBwcm9jZXNzRGF0YVdpdGhUZW1wbGF0ZShcbiAgICByYXdEYXRhOiBhbnlbXSxcbiAgICB0ZW1wbGF0ZTogRGF0YU1hcHBpbmdUZW1wbGF0ZSB8IEFkYXB0aXZlVGVtcGxhdGVcbiAgKTogUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhZGFwdGl2ZSB0ZW1wbGF0ZVxuICAgIGlmICgnc3VnZ2VzdGVkTWFwcGluZ3MnIGluIHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gQWRhcHRpdmVEYXRhVmFsaWRhdG9yLnByb2Nlc3NXaXRoQWRhcHRpdmVUZW1wbGF0ZShyYXdEYXRhLCB0ZW1wbGF0ZSBhcyBBZGFwdGl2ZVRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIHRyYWRpdGlvbmFsIHByb2Nlc3NpbmdcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHM6IFZhbGlkYXRpb25SZXN1bHRbXSA9IFtdO1xuICAgIGNvbnN0IHByb2Nlc3NlZERhdGE6IGFueVtdID0gW107XG4gICAgXG4gICAgbGV0IHZhbGlkUm93cyA9IDA7XG4gICAgbGV0IHNraXBwZWRSb3dzID0gMDtcblxuICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByYXdEYXRhLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgY29uc3Qgcm93ID0gcmF3RGF0YVtyb3dJbmRleF07XG4gICAgICBjb25zdCBwcm9jZXNzZWRSb3c6IGFueSA9IHt9O1xuICAgICAgbGV0IGlzVmFsaWRSb3cgPSB0cnVlO1xuICAgICAgbGV0IGhhc1JlcXVpcmVkRmllbGRzID0gZmFsc2U7XG5cbiAgICAgIC8vIENoZWNrIGZvciByZXF1aXJlZCBjb2x1bW5zXG4gICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkQ29sdW1uIG9mIHRlbXBsYXRlLnJlcXVpcmVkQ29sdW1ucykge1xuICAgICAgICBpZiAoIShyZXF1aXJlZENvbHVtbiBpbiByb3cpIHx8IHJvd1tyZXF1aXJlZENvbHVtbl0gPT09IG51bGwgfHwgcm93W3JlcXVpcmVkQ29sdW1uXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tyZXF1aXJlZENvbHVtbl0gPT09ICcnKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke3Jvd0luZGV4ICsgMX06IE1pc3NpbmcgcmVxdWlyZWQgY29sdW1uICcke3JlcXVpcmVkQ29sdW1ufSdgKTtcbiAgICAgICAgICBpc1ZhbGlkUm93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzUmVxdWlyZWRGaWVsZHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzUmVxdWlyZWRGaWVsZHMpIHtcbiAgICAgICAgc2tpcHBlZFJvd3MrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBtYXBwZWQgZmllbGRcbiAgICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiB0ZW1wbGF0ZS5tYXBwaW5ncykge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHJvd1ttYXBwaW5nLnNvdXJjZUNvbHVtbl07XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlRmllbGRWYWx1ZShzb3VyY2VWYWx1ZSwgbWFwcGluZyk7XG4gICAgICAgIFxuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0cy5wdXNoKHZhbGlkYXRpb24pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7cm93SW5kZXggKyAxfSwgRmllbGQgJyR7bWFwcGluZy50YXJnZXRGaWVsZH0nOiAke3ZhbGlkYXRpb24uZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICAgIGlzVmFsaWRSb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzZWRSb3dbbWFwcGluZy50YXJnZXRGaWVsZF0gPSB2YWxpZGF0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ZhbGlkUm93KSB7XG4gICAgICAgIHByb2Nlc3NlZERhdGEucHVzaChwcm9jZXNzZWRSb3cpO1xuICAgICAgICB2YWxpZFJvd3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBwZWRSb3dzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGRhdGEgcXVhbGl0eSBtZXRyaWNzXG4gICAgY29uc3QgZGF0YVF1YWxpdHkgPSB0aGlzLmNhbGN1bGF0ZURhdGFRdWFsaXR5KHJhd0RhdGEsIHZhbGlkYXRpb25SZXN1bHRzLCB0ZW1wbGF0ZSk7XG5cbiAgICAvLyBCdWlsZCBjb21wcmVoZW5zaXZlIG9wZXJhdGlvbmFsIGRhdGEgc3RydWN0dXJlXG4gICAgY29uc3QgY29tcHJlaGVuc2l2ZURhdGE6IENvbXByZWhlbnNpdmVPcGVyYXRpb25hbERhdGEgPSB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBkYXRhUXVhbGl0eSxcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdHMsXG4gICAgICAgIGxhc3RQcm9jZXNzZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBNYXAgcHJvY2Vzc2VkIGRhdGEgdG8gYXBwcm9wcmlhdGUgY2F0ZWdvcnkgc3RydWN0dXJlXG4gICAgaWYgKHRlbXBsYXRlLnRhcmdldENhdGVnb3J5ID09PSAnb3BlcmF0aW9uYWxSZXBvcnRpbmcnKSB7XG4gICAgICBjb21wcmVoZW5zaXZlRGF0YS5vcGVyYXRpb25hbFJlcG9ydGluZyA9IHtcbiAgICAgICAgW3RlbXBsYXRlLnRhcmdldFN1YmNhdGVnb3J5XTogdGhpcy5hZ2dyZWdhdGVEYXRhKHByb2Nlc3NlZERhdGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGVtcGxhdGUudGFyZ2V0Q2F0ZWdvcnkgPT09ICdidXNpbmVzc0ZpbmFuY2lhbHMnKSB7XG4gICAgICBjb21wcmVoZW5zaXZlRGF0YS5idXNpbmVzc0ZpbmFuY2lhbHMgPSB7XG4gICAgICAgIFt0ZW1wbGF0ZS50YXJnZXRTdWJjYXRlZ29yeV06IHRoaXMuYWdncmVnYXRlRGF0YShwcm9jZXNzZWREYXRhKVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLnRhcmdldENhdGVnb3J5ID09PSAnc2FsZXNHcm93dGhUcmFqZWN0b3J5Jykge1xuICAgICAgY29tcHJlaGVuc2l2ZURhdGEuc2FsZXNHcm93dGhUcmFqZWN0b3J5ID0ge1xuICAgICAgICBbdGVtcGxhdGUudGFyZ2V0U3ViY2F0ZWdvcnldOiB0aGlzLmFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBkYXRhOiBjb21wcmVoZW5zaXZlRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgc3VtbWFyeToge1xuICAgICAgICB0b3RhbFJvd3M6IHJhd0RhdGEubGVuZ3RoLFxuICAgICAgICB2YWxpZFJvd3MsXG4gICAgICAgIHNraXBwZWRSb3dzLFxuICAgICAgICBkYXRhUXVhbGl0eVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBBZ2dyZWdhdGUgYXJyYXkgZGF0YSBpbnRvIHN1bW1hcnkgbWV0cmljc1xuICBwcml2YXRlIHN0YXRpYyBhZ2dyZWdhdGVEYXRhKGRhdGE6IGFueVtdKTogYW55IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiB7fTtcbiAgICBcbiAgICBjb25zdCBhZ2dyZWdhdGVkOiBhbnkgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZGF0YS5tYXAocm93ID0+IHJvd1trZXldKS5maWx0ZXIodmFsID0+IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBGb3IgbnVtZXJpYyBmaWVsZHMsIGNhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgICAgIGFnZ3JlZ2F0ZWRba2V5XSA9IHtcbiAgICAgICAgICB0b3RhbDogdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCksXG4gICAgICAgICAgYXZlcmFnZTogdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4udmFsdWVzKSxcbiAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLnZhbHVlcyksXG4gICAgICAgICAgY291bnQ6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXMgLy8gS2VlcCBpbmRpdmlkdWFsIHZhbHVlcyBmb3IgZGV0YWlsZWQgYW5hbHlzaXNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBub24tbnVtZXJpYyBmaWVsZHMsIGtlZXAgdW5pcXVlIHZhbHVlc1xuICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSk7XG4gICAgICAgIGFnZ3JlZ2F0ZWRba2V5XSA9IHtcbiAgICAgICAgICB1bmlxdWVWYWx1ZXMsXG4gICAgICAgICAgY291bnQ6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZWQ7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgY29tcHJlaGVuc2l2ZSBkYXRhIHF1YWxpdHkgbWV0cmljc1xuICBwcml2YXRlIHN0YXRpYyBjYWxjdWxhdGVEYXRhUXVhbGl0eShcbiAgICByYXdEYXRhOiBhbnlbXSxcbiAgICB2YWxpZGF0aW9uUmVzdWx0czogVmFsaWRhdGlvblJlc3VsdFtdLFxuICAgIHRlbXBsYXRlOiBEYXRhTWFwcGluZ1RlbXBsYXRlXG4gICk6IERhdGFRdWFsaXR5TWV0cmljcyB7XG4gICAgY29uc3QgdG90YWxGaWVsZHMgPSByYXdEYXRhLmxlbmd0aCAqIHRlbXBsYXRlLm1hcHBpbmdzLmxlbmd0aDtcbiAgICBjb25zdCB2YWxpZEZpZWxkcyA9IHZhbGlkYXRpb25SZXN1bHRzLmZpbHRlcihyID0+IHIuaXNWYWxpZCkubGVuZ3RoO1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzQ291bnQgPSByYXdEYXRhLmxlbmd0aCAqIHRlbXBsYXRlLnJlcXVpcmVkQ29sdW1ucy5sZW5ndGg7XG4gICAgY29uc3QgZmlsbGVkUmVxdWlyZWRGaWVsZHMgPSB2YWxpZGF0aW9uUmVzdWx0cy5maWx0ZXIociA9PiBcbiAgICAgIHIuaXNWYWxpZCAmJiB0ZW1wbGF0ZS5yZXF1aXJlZENvbHVtbnMuc29tZShjb2wgPT4gXG4gICAgICAgIHRlbXBsYXRlLm1hcHBpbmdzLmZpbmQobSA9PiBtLnNvdXJjZUNvbHVtbiA9PT0gY29sKT8udGFyZ2V0RmllbGQgPT09IHIuZmllbGRcbiAgICAgIClcbiAgICApLmxlbmd0aDtcblxuICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSB0ZW1wbGF0ZS5tYXBwaW5nc1xuICAgICAgLmZpbHRlcihtYXBwaW5nID0+ICFyYXdEYXRhLnNvbWUocm93ID0+IHJvd1ttYXBwaW5nLnNvdXJjZUNvbHVtbl0gIT09IG51bGwgJiYgcm93W21hcHBpbmcuc291cmNlQ29sdW1uXSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgIC5tYXAobWFwcGluZyA9PiBtYXBwaW5nLnNvdXJjZUNvbHVtbik7XG5cbiAgICBjb25zdCBpbnZhbGlkVmFsdWVzID0gdmFsaWRhdGlvblJlc3VsdHNcbiAgICAgIC5maWx0ZXIociA9PiAhci5pc1ZhbGlkKVxuICAgICAgLm1hcChyID0+ICh7XG4gICAgICAgIGZpZWxkOiByLmZpZWxkLFxuICAgICAgICB2YWx1ZTogci52YWx1ZSxcbiAgICAgICAgcmVhc29uOiByLmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biB2YWxpZGF0aW9uIGVycm9yJ1xuICAgICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBsZXRlbmVzczogcmVxdWlyZWRGaWVsZHNDb3VudCA+IDAgPyAoZmlsbGVkUmVxdWlyZWRGaWVsZHMgLyByZXF1aXJlZEZpZWxkc0NvdW50KSAqIDEwMCA6IDEwMCxcbiAgICAgIGFjY3VyYWN5OiB0b3RhbEZpZWxkcyA+IDAgPyAodmFsaWRGaWVsZHMgLyB0b3RhbEZpZWxkcykgKiAxMDAgOiAxMDAsXG4gICAgICBjb25zaXN0ZW5jeTogMTAwLCAvLyBDYW4gYmUgZW5oYW5jZWQgd2l0aCBjcm9zcy1maWVsZCB2YWxpZGF0aW9uXG4gICAgICB0aW1lbGluZXNzOiAxMDAsIC8vIEFzc3VtZXMgY3VycmVudCBkYXRhIGlzIHRpbWVseVxuICAgICAgdmFsaWRSZWNvcmRzOiB2YWxpZGF0aW9uUmVzdWx0cy5maWx0ZXIociA9PiByLmlzVmFsaWQpLmxlbmd0aCxcbiAgICAgIHRvdGFsUmVjb3JkczogcmF3RGF0YS5sZW5ndGgsXG4gICAgICBtaXNzaW5nRmllbGRzLFxuICAgICAgaW52YWxpZFZhbHVlc1xuICAgIH07XG4gIH1cblxuICAvLyBFbmhhbmNlZCB0ZW1wbGF0ZSBkZXRlY3Rpb24gd2l0aCBhZGFwdGl2ZSBmYWxsYmFja1xuICBzdGF0aWMgZGV0ZWN0RGF0YVRlbXBsYXRlKGNvbHVtbkhlYWRlcnM6IHN0cmluZ1tdLCBmaWxlTmFtZT86IHN0cmluZywgZGF0YT86IGFueVtdKTogRGF0YU1hcHBpbmdUZW1wbGF0ZSB8IEFkYXB0aXZlVGVtcGxhdGUgfCBudWxsIHtcbiAgICAvLyBGaXJzdCB0cnkgdHJhZGl0aW9uYWwgdGVtcGxhdGUgbWF0Y2hpbmdcbiAgICBsZXQgYmVzdE1hdGNoOiB7IHRlbXBsYXRlOiBEYXRhTWFwcGluZ1RlbXBsYXRlOyBzY29yZTogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcblxuICAgIGZvciAoY29uc3QgdGVtcGxhdGUgb2YgREFUQV9NQVBQSU5HX1RFTVBMQVRFUykge1xuICAgICAgbGV0IHNjb3JlID0gMDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIG1hdGNoIHNjb3JlIGJhc2VkIG9uIGNvbHVtbiBwcmVzZW5jZVxuICAgICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIHRlbXBsYXRlLm1hcHBpbmdzKSB7XG4gICAgICAgIGlmIChjb2x1bW5IZWFkZXJzLnNvbWUoaGVhZGVyID0+XG4gICAgICAgICAgaGVhZGVyLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWFwcGluZy5zb3VyY2VDb2x1bW4udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZUNvbHVtbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGhlYWRlci50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApKSB7XG4gICAgICAgICAgc2NvcmUgKz0gbWFwcGluZy5yZXF1aXJlZCA/IDIgOiAxOyAvLyBXZWlnaHQgcmVxdWlyZWQgZmllbGRzIG1vcmUgaGVhdmlseVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBzY29yZSBieSB0ZW1wbGF0ZSBzaXplXG4gICAgICBjb25zdCBub3JtYWxpemVkU2NvcmUgPSBzY29yZSAvIHRlbXBsYXRlLm1hcHBpbmdzLmxlbmd0aDtcblxuICAgICAgaWYgKCFiZXN0TWF0Y2ggfHwgbm9ybWFsaXplZFNjb3JlID4gYmVzdE1hdGNoLnNjb3JlKSB7XG4gICAgICAgIGJlc3RNYXRjaCA9IHsgdGVtcGxhdGUsIHNjb3JlOiBub3JtYWxpemVkU2NvcmUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0cmFkaXRpb25hbCBtYXRjaGluZyBmb3VuZCBhIGdvb2QgbWF0Y2gsIHVzZSBpdFxuICAgIGlmIChiZXN0TWF0Y2ggJiYgYmVzdE1hdGNoLnNjb3JlID4gMC41KSB7XG4gICAgICByZXR1cm4gYmVzdE1hdGNoLnRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGFkYXB0aXZlIHRlbXBsYXRlXG4gICAgaWYgKGZpbGVOYW1lICYmIGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2x1bW5BbmFseXNpcyA9IEFkYXB0aXZlRGF0YVZhbGlkYXRvci5hbmFseXplQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgYWRhcHRpdmVUZW1wbGF0ZSA9IEFkYXB0aXZlRGF0YVZhbGlkYXRvci5jcmVhdGVBZGFwdGl2ZVRlbXBsYXRlKGZpbGVOYW1lLCBkYXRhLCBjb2x1bW5BbmFseXNpcyk7XG5cbiAgICAgICAgLy8gT25seSByZXR1cm4gYWRhcHRpdmUgdGVtcGxhdGUgaWYgaXQgaGFzIHJlYXNvbmFibGUgY29uZmlkZW5jZVxuICAgICAgICBpZiAoYWRhcHRpdmVUZW1wbGF0ZS5jb25maWRlbmNlID4gMC4yKSB7XG4gICAgICAgICAgcmV0dXJuIGFkYXB0aXZlVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNyZWF0ZSBhZGFwdGl2ZSB0ZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGJlc3QgdHJhZGl0aW9uYWwgbWF0Y2ggZXZlbiBpZiBzY29yZSBpcyBsb3csIG9yIG51bGxcbiAgICByZXR1cm4gYmVzdE1hdGNoPy50ZW1wbGF0ZSB8fCBudWxsO1xuICB9XG5cbiAgLy8gUGFyc2UgRXhjZWwvQ1NWIGZpbGUgYW5kIGV4dHJhY3QgZGF0YVxuICBzdGF0aWMgYXN5bmMgcGFyc2VGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPHsgZGF0YTogYW55W107IGNvbHVtbkhlYWRlcnM6IHN0cmluZ1tdIH0+IHtcbiAgICAvLyBFbnN1cmUgdGhpcyBydW5zIG9ubHkgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBwYXJzaW5nIGlzIG9ubHkgYXZhaWxhYmxlIG9uIHRoZSBjbGllbnQgc2lkZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBEeW5hbWljYWxseSBpbXBvcnQgWExTWCB0byBhdm9pZCBTU1IgaXNzdWVzXG4gICAgICBjb25zdCBYTFNYID0gYXdhaXQgaW1wb3J0KCd4bHN4Jyk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLnRhcmdldD8ucmVzdWx0O1xuICAgICAgICAgICAgbGV0IHdvcmtib29rOiBhbnk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlLnR5cGUuaW5jbHVkZXMoJ2NzdicpKSB7XG4gICAgICAgICAgICAgIHdvcmtib29rID0gWExTWC5yZWFkKGRhdGEsIHsgdHlwZTogJ2JpbmFyeScgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNoZWV0TmFtZSA9IHdvcmtib29rLlNoZWV0TmFtZXNbMF07XG4gICAgICAgICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwgeyBoZWFkZXI6IDEgfSk7XG5cbiAgICAgICAgICAgIGlmIChqc29uRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmlsZSBjb250YWlucyBubyBkYXRhJykpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkhlYWRlcnMgPSBqc29uRGF0YVswXSBhcyBzdHJpbmdbXTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSb3dzID0ganNvbkRhdGEuc2xpY2UoMSkubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJvd09iajogYW55ID0ge307XG4gICAgICAgICAgICAgIGNvbHVtbkhlYWRlcnMuZm9yRWFjaCgoaGVhZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJvd09ialtoZWFkZXJdID0gKHJvdyBhcyBhbnlbXSlbaW5kZXhdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvd09iajtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNvbHZlKHsgZGF0YTogZGF0YVJvd3MsIGNvbHVtbkhlYWRlcnMgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBmaWxlOiAke2Vycm9yfWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlJykpO1xuXG4gICAgICAgIGlmIChmaWxlLnR5cGUuaW5jbHVkZXMoJ2NzdicpKSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBmaWxlOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHBhbGxldCBhbmQgY2FydG9uIGRhdGEgZnJvbSBzcHJlYWRzaGVldFxuICAgKiBAcGFyYW0gZGF0YSBQYXJzZWQgSlNPTiBkYXRhIGZyb20gdGhlIGZpbGVcbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgdW5pdHMgcGVyIGNhcnRvbiBhbmQgY2FydG9ucyBwZXIgcGFsbGV0XG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdENhcnRvblBhbGxldERhdGEoZGF0YTogYW55W10pOiB7XG4gICAgdW5pdHNfcGVyX2NhcnRvbj86IG51bWJlcjtcbiAgICBjYXJ0b25zX3Blcl9wYWxsZXQ/OiBudW1iZXI7XG4gICAgZGF5c19vbl9oYW5kPzogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCByZXN1bHQ6IHsgdW5pdHNfcGVyX2NhcnRvbj86IG51bWJlcjsgY2FydG9uc19wZXJfcGFsbGV0PzogbnVtYmVyOyBkYXlzX29uX2hhbmQ/OiBudW1iZXIgfSA9IHt9O1xuXG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgLy8gTG9vayBmb3IgY29sdW1uIG5hbWVzIHRoYXQgbWlnaHQgY29udGFpbiBjYXJ0b24vcGFsbGV0IGRhdGFcbiAgICBjb25zdCBjb2x1bW5NYXBwaW5ncyA9IHtcbiAgICAgIHVuaXRzX3Blcl9jYXJ0b246IFsndW5pdHMgcGVyIGNhcnRvbicsICd1bml0cy9jYXJ0b24nLCAndW5pdCBwZXIgY2FydG9uJywgJ3VwYycsICd1bml0c19wZXJfY2FydG9uJywgJ2NhcnRvbl9zaXplJ10sXG4gICAgICBjYXJ0b25zX3Blcl9wYWxsZXQ6IFsnY2FydG9ucyBwZXIgcGFsbGV0JywgJ2NhcnRvbnMvcGFsbGV0JywgJ2NhcnRvbiBwZXIgcGFsbGV0JywgJ2NwcCcsICdjYXJ0b25zX3Blcl9wYWxsZXQnLCAncGFsbGV0X3NpemUnXSxcbiAgICAgIGRheXNfb25faGFuZDogWydkYXlzIG9uIGhhbmQnLCAnZG9oJywgJ2RheXNfb25faGFuZCcsICdpbnZlbnRvcnlfZGF5cycsICdzdG9ja19kYXlzJ11cbiAgICB9O1xuXG4gICAgLy8gRmluZCByZWxldmFudCBjb2x1bW5zXG4gICAgY29uc3QgZmlyc3RSb3cgPSBkYXRhWzBdO1xuICAgIGNvbnN0IGNvbHVtbk5hbWVzID0gT2JqZWN0LmtleXMoZmlyc3RSb3cpLm1hcChjb2wgPT4gY29sLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcblxuICAgIGNvbnN0IGZvdW5kQ29sdW1uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gICAgT2JqZWN0LmVudHJpZXMoY29sdW1uTWFwcGluZ3MpLmZvckVhY2goKFtrZXksIHBhdHRlcm5zXSkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hpbmdDb2x1bW4gPSBjb2x1bW5OYW1lcy5maW5kKGNvbCA9PlxuICAgICAgICBwYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gY29sLmluY2x1ZGVzKHBhdHRlcm4udG9Mb3dlckNhc2UoKSkpXG4gICAgICApO1xuICAgICAgaWYgKG1hdGNoaW5nQ29sdW1uKSB7XG4gICAgICAgIGZvdW5kQ29sdW1uc1trZXldID0gT2JqZWN0LmtleXMoZmlyc3RSb3cpW2NvbHVtbk5hbWVzLmluZGV4T2YobWF0Y2hpbmdDb2x1bW4pXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEV4dHJhY3QgdmFsdWVzIGZyb20gdGhlIGRhdGFcbiAgICBpZiAoZm91bmRDb2x1bW5zLnVuaXRzX3Blcl9jYXJ0b24pIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKHJvdyA9PiByb3dbZm91bmRDb2x1bW5zLnVuaXRzX3Blcl9jYXJ0b25dKVxuICAgICAgICAuZmlsdGVyKHZhbCA9PiB2YWwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsKSkpXG4gICAgICAgIC5tYXAodmFsID0+IHBhcnNlRmxvYXQodmFsKSk7XG5cbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBVc2UgdGhlIG1vc3QgY29tbW9uIHZhbHVlIG9yIGF2ZXJhZ2VcbiAgICAgICAgcmVzdWx0LnVuaXRzX3Blcl9jYXJ0b24gPSBNYXRoLnJvdW5kKHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kQ29sdW1ucy5jYXJ0b25zX3Blcl9wYWxsZXQpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKHJvdyA9PiByb3dbZm91bmRDb2x1bW5zLmNhcnRvbnNfcGVyX3BhbGxldF0pXG4gICAgICAgIC5maWx0ZXIodmFsID0+IHZhbCAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWwpKSlcbiAgICAgICAgLm1hcCh2YWwgPT4gcGFyc2VGbG9hdCh2YWwpKTtcblxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5jYXJ0b25zX3Blcl9wYWxsZXQgPSBNYXRoLnJvdW5kKHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kQ29sdW1ucy5kYXlzX29uX2hhbmQpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKHJvdyA9PiByb3dbZm91bmRDb2x1bW5zLmRheXNfb25faGFuZF0pXG4gICAgICAgIC5maWx0ZXIodmFsID0+IHZhbCAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWwpKSlcbiAgICAgICAgLm1hcCh2YWwgPT4gcGFyc2VGbG9hdCh2YWwpKTtcblxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5kYXlzX29uX2hhbmQgPSBNYXRoLnJvdW5kKHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gY29sdW1ucyBmb3VuZCwgdHJ5IHRvIGV4dHJhY3QgZnJvbSBhbnkgbnVtZXJpYyBkYXRhIHRoYXQgbWFrZXMgc2Vuc2VcbiAgICBpZiAoIXJlc3VsdC51bml0c19wZXJfY2FydG9uICYmICFyZXN1bHQuY2FydG9uc19wZXJfcGFsbGV0KSB7XG4gICAgICAvLyBMb29rIGZvciByZWFzb25hYmxlIGRlZmF1bHQgcGF0dGVybnMgaW4gdGhlIGRhdGFcbiAgICAgIGNvbnN0IG51bWVyaWNDb2x1bW5zID0gT2JqZWN0LmtleXMoZmlyc3RSb3cpLmZpbHRlcihjb2wgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLnNsaWNlKDAsIDEwKS5tYXAocm93ID0+IHJvd1tjb2xdKS5maWx0ZXIodmFsID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiA1OyAvLyBDb2x1bW4gaGFzIG1vc3RseSBudW1lcmljIGRhdGFcbiAgICAgIH0pO1xuXG4gICAgICBudW1lcmljQ29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKHJvdyA9PiBwYXJzZUZsb2F0KHJvd1tjb2xdKSkuZmlsdGVyKHZhbCA9PiAhaXNOYU4odmFsKSk7XG4gICAgICAgIGNvbnN0IGF2ZyA9IHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY29sTmFtZSA9IGNvbC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIEhldXJpc3RpY3MgZm9yIGNvbW1vbiByYW5nZXNcbiAgICAgICAgaWYgKGF2ZyA+PSA2ICYmIGF2ZyA8PSAxMDAgJiYgY29sTmFtZS5pbmNsdWRlcygnY2FydG9uJykpIHtcbiAgICAgICAgICByZXN1bHQudW5pdHNfcGVyX2NhcnRvbiA9IE1hdGgucm91bmQoYXZnKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdmcgPj0gMjAgJiYgYXZnIDw9IDIwMCAmJiBjb2xOYW1lLmluY2x1ZGVzKCdwYWxsZXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5jYXJ0b25zX3Blcl9wYWxsZXQgPSBNYXRoLnJvdW5kKGF2Zyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXZnID49IDMwICYmIGF2ZyA8PSA1MDAgJiYgKGNvbE5hbWUuaW5jbHVkZXMoJ2RheScpIHx8IGNvbE5hbWUuaW5jbHVkZXMoJ2RvaCcpKSkge1xuICAgICAgICAgIHJlc3VsdC5kYXlzX29uX2hhbmQgPSBNYXRoLnJvdW5kKGF2Zyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBtZXRhZGF0YSBmcm9tIHBhcnNlZCBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIFBhcnNlZCBKU09OIGRhdGEgZnJvbSB0aGUgZmlsZVxuICAgKiBAcGFyYW0gZmlsZU5hbWUgT3JpZ2luYWwgZmlsZSBuYW1lXG4gICAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIGFib3V0IHRoZSBkYXRhXG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdE1ldGFkYXRhKGRhdGE6IGFueVtdLCBmaWxlTmFtZTogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3dDb3VudDogMCxcbiAgICAgICAgY29sdW1uQ291bnQ6IDAsXG4gICAgICAgIGZpbGVOYW1lLFxuICAgICAgICBwcm9jZXNzaW5nRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcbiAgICBjb25zdCBjb2x1bW5zID0gT2JqZWN0LmtleXMoZmlyc3RSb3cpO1xuICAgIGNvbnN0IGNhcnRvblBhbGxldERhdGEgPSBEYXRhVmFsaWRhdG9yLmV4dHJhY3RDYXJ0b25QYWxsZXREYXRhKGRhdGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd0NvdW50OiBkYXRhLmxlbmd0aCxcbiAgICAgIGNvbHVtbkNvdW50OiBjb2x1bW5zLmxlbmd0aCxcbiAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIHByb2Nlc3NpbmdEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRhVHlwZXM6IERhdGFWYWxpZGF0b3IuYW5hbHl6ZUNvbHVtblR5cGVzKGRhdGEpLFxuICAgICAgc2FtcGxlRGF0YTogZGF0YS5zbGljZSgwLCAzKSwgLy8gRmlyc3QgMyByb3dzIGFzIHNhbXBsZVxuICAgICAgLi4uY2FydG9uUGFsbGV0RGF0YSAvLyBJbmNsdWRlIGNhcnRvbi9wYWxsZXQgZGF0YSBpbiBtZXRhZGF0YVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBjb2x1bW4gdHlwZXMgaW4gdGhlIGRhdGFcbiAgICogQHBhcmFtIGRhdGEgUGFyc2VkIGRhdGEgYXJyYXlcbiAgICogQHJldHVybnMgT2JqZWN0IG1hcHBpbmcgY29sdW1uIG5hbWVzIHRvIGRldGVjdGVkIHR5cGVzXG4gICAqL1xuICBzdGF0aWMgYW5hbHl6ZUNvbHVtblR5cGVzKGRhdGE6IGFueVtdKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBmaXJzdFJvdyA9IGRhdGFbMF07XG4gICAgY29uc3QgdHlwZUFuYWx5c2lzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhmaXJzdFJvdykuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gZGF0YS5zbGljZSgwLCAxMClcbiAgICAgICAgLm1hcChyb3cgPT4gcm93W2NvbHVtbl0pXG4gICAgICAgIC5maWx0ZXIodmFsID0+IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09ICcnKTtcblxuICAgICAgaWYgKHNhbXBsZVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdHlwZUFuYWx5c2lzW2NvbHVtbl0gPSAnZW1wdHknO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG51bWVyaWNWYWx1ZXMgPSBzYW1wbGVWYWx1ZXMuZmlsdGVyKHZhbCA9PiAhaXNOYU4ocGFyc2VGbG9hdCh2YWwpKSk7XG4gICAgICBjb25zdCBkYXRlVmFsdWVzID0gc2FtcGxlVmFsdWVzLmZpbHRlcih2YWwgPT4gIWlzTmFOKERhdGUucGFyc2UodmFsKSkpO1xuXG4gICAgICBpZiAobnVtZXJpY1ZhbHVlcy5sZW5ndGggPT09IHNhbXBsZVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdHlwZUFuYWx5c2lzW2NvbHVtbl0gPSAnbnVtYmVyJztcbiAgICAgIH0gZWxzZSBpZiAoZGF0ZVZhbHVlcy5sZW5ndGggPT09IHNhbXBsZVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdHlwZUFuYWx5c2lzW2NvbHVtbl0gPSAnZGF0ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQW5hbHlzaXNbY29sdW1uXSA9ICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHR5cGVBbmFseXNpcztcbiAgfVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGF0YSBwcm9jZXNzaW5nXG5leHBvcnQgY29uc3QgRGF0YVByb2Nlc3NpbmdVdGlscyA9IHtcbiAgXG4gIC8vIEZvcm1hdCB2YWxpZGF0aW9uIHJlc3VsdHMgZm9yIGRpc3BsYXlcbiAgZm9ybWF0VmFsaWRhdGlvblJlc3VsdHM6IChyZXN1bHRzOiBWYWxpZGF0aW9uUmVzdWx0W10pOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGVycm9ycyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuaXNWYWxpZCk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHJldHVybiAnQWxsIGRhdGEgdmFsaWRhdGlvbiBjaGVja3MgcGFzc2VkIHN1Y2Nlc3NmdWxseS4nO1xuICAgIFxuICAgIHJldHVybiBgRm91bmQgJHtlcnJvcnMubGVuZ3RofSB2YWxpZGF0aW9uIGVycm9yczpcXG4ke2Vycm9ycy5tYXAociA9PiBcbiAgICAgIGDigKIgJHtyLmZpZWxkfTogJHtyLmVycm9yTWVzc2FnZX1gXG4gICAgKS5qb2luKCdcXG4nKX1gO1xuICB9LFxuXG4gIC8vIEZvcm1hdCBkYXRhIHF1YWxpdHkgbWV0cmljcyBmb3IgZGlzcGxheVxuICBmb3JtYXREYXRhUXVhbGl0eTogKHF1YWxpdHk6IERhdGFRdWFsaXR5TWV0cmljcyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGBEYXRhIFF1YWxpdHkgQXNzZXNzbWVudDpcbu+/ve+/vSBDb21wbGV0ZW5lc3M6ICR7cXVhbGl0eS5jb21wbGV0ZW5lc3MudG9GaXhlZCgxKX0lXG7igKIgQWNjdXJhY3k6ICR7cXVhbGl0eS5hY2N1cmFjeS50b0ZpeGVkKDEpfSVcbuKAoiBWYWxpZCBSZWNvcmRzOiAke3F1YWxpdHkudmFsaWRSZWNvcmRzfS8ke3F1YWxpdHkudG90YWxSZWNvcmRzfVxuJHtxdWFsaXR5Lm1pc3NpbmdGaWVsZHMubGVuZ3RoID4gMCA/IGDigKIgTWlzc2luZyBGaWVsZHM6ICR7cXVhbGl0eS5taXNzaW5nRmllbGRzLmpvaW4oJywgJyl9YCA6ICcnfVxuJHtxdWFsaXR5LmludmFsaWRWYWx1ZXMubGVuZ3RoID4gMCA/IGDigKIgSW52YWxpZCBWYWx1ZXM6ICR7cXVhbGl0eS5pbnZhbGlkVmFsdWVzLmxlbmd0aH0gZm91bmRgIDogJyd9YDtcbiAgfSxcblxuICAvLyBHZW5lcmF0ZSBwcm9jZXNzaW5nIHN1bW1hcnlcbiAgZ2VuZXJhdGVQcm9jZXNzaW5nU3VtbWFyeTogKHJlc3VsdDogUHJvY2Vzc2luZ1Jlc3VsdCk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgeyBzdW1tYXJ5LCBlcnJvcnMsIHdhcm5pbmdzIH0gPSByZXN1bHQ7XG4gICAgXG4gICAgcmV0dXJuIGBQcm9jZXNzaW5nIENvbXBsZXRlOlxu4oCiIFRvdGFsIFJvd3M6ICR7c3VtbWFyeS50b3RhbFJvd3N9XG7igKIgVmFsaWQgUm93czogJHtzdW1tYXJ5LnZhbGlkUm93c31cbuKAoiBTa2lwcGVkIFJvd3M6ICR7c3VtbWFyeS5za2lwcGVkUm93c31cbuKAoiBTdWNjZXNzIFJhdGU6ICR7KChzdW1tYXJ5LnZhbGlkUm93cyAvIHN1bW1hcnkudG90YWxSb3dzKSAqIDEwMCkudG9GaXhlZCgxKX0lXG4ke2Vycm9ycy5sZW5ndGggPiAwID8gYFxcbkVycm9ycyAoJHtlcnJvcnMubGVuZ3RofSk6XFxuJHtlcnJvcnMuc2xpY2UoMCwgNSkuam9pbignXFxuJyl9JHtlcnJvcnMubGVuZ3RoID4gNSA/ICdcXG4uLi4nIDogJyd9YCA6ICcnfVxuJHt3YXJuaW5ncy5sZW5ndGggPiAwID8gYFxcbldhcm5pbmdzICgke3dhcm5pbmdzLmxlbmd0aH0pOlxcbiR7d2FybmluZ3Muc2xpY2UoMCwgMykuam9pbignXFxuJyl9JHt3YXJuaW5ncy5sZW5ndGggPiAzID8gJ1xcbi4uLicgOiAnJ31gIDogJyd9YDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJEQVRBX01BUFBJTkdfVEVNUExBVEVTIiwiQWRhcHRpdmVEYXRhVmFsaWRhdG9yIiwiQWR2YW5jZWREYXRhSW1wdXRhdGlvbiIsIkRhdGFWYWxpZGF0b3IiLCJwcm9jZXNzRGF0YVdpdGhJbXB1dGF0aW9uQW5kVGVtcGxhdGUiLCJyYXdEYXRhIiwidGVtcGxhdGUiLCJpbXB1dGF0aW9uQ29uZmlnIiwibGVuZ3RoIiwiRXJyb3IiLCJkaWFnbm9zaXMiLCJkaWFnbm9zZU1pc3NpbmdEYXRhIiwiaW1wdXRhdGlvblJlc3VsdCIsImRhdGFUb1Byb2Nlc3MiLCJwYXR0ZXJucyIsImNvbnNvbGUiLCJsb2ciLCJzdWdnZXN0ZWRNZXRob2QiLCJtYXAiLCJwIiwiZmllbGQiLCJtaXNzaW5nUGVyY2VudGFnZSIsInRvRml4ZWQiLCJwYXR0ZXJuIiwiaW1wdXRlTWlzc2luZ0RhdGEiLCJtZXRob2QiLCJkYXRhIiwic3RhdGlzdGljcyIsInRvdGFsSW1wdXRlZCIsImF2ZXJhZ2VDb25maWRlbmNlIiwiZXJyb3IiLCJ3YXJuIiwicHJvY2Vzc2luZ1Jlc3VsdCIsInByb2Nlc3NEYXRhV2l0aFRlbXBsYXRlIiwibWV0YWRhdGEiLCJpbXB1dGF0aW9uSW5mbyIsIm1ldGhvZFVzZWQiLCJtZXRob2RzVXNlZCIsInF1YWxpdHlNZXRyaWNzIiwiaW1wdXRlZEZpZWxkcyIsInJvd0luZGV4IiwiY29uZmlkZW5jZSIsImRpYWdub3NlTWlzc2luZ0RhdGFQYXR0ZXJucyIsImNvbmZpZyIsInZhbGlkYXRlRmllbGRWYWx1ZSIsInZhbHVlIiwibWFwcGluZyIsInJlc3VsdCIsInRhcmdldEZpZWxkIiwiaXNWYWxpZCIsInJlcXVpcmVkIiwidW5kZWZpbmVkIiwiZXJyb3JNZXNzYWdlIiwiZGF0YVR5cGUiLCJudW1WYWx1ZSIsInBhcnNlRmxvYXQiLCJpc05hTiIsInN1Z2dlc3Rpb24iLCJ2YWxpZGF0aW9uIiwibWluIiwibWF4Iiwic3RyVmFsdWUiLCJTdHJpbmciLCJ0cmltIiwicmVnZXgiLCJSZWdFeHAiLCJ0ZXN0IiwiYWxsb3dlZFZhbHVlcyIsImluY2x1ZGVzIiwiam9pbiIsInRvTG93ZXJDYXNlIiwiZGF0ZVZhbHVlIiwiRGF0ZSIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsInByb2Nlc3NXaXRoQWRhcHRpdmVUZW1wbGF0ZSIsImVycm9ycyIsIndhcm5pbmdzIiwidmFsaWRhdGlvblJlc3VsdHMiLCJwcm9jZXNzZWREYXRhIiwidmFsaWRSb3dzIiwic2tpcHBlZFJvd3MiLCJyb3ciLCJwcm9jZXNzZWRSb3ciLCJpc1ZhbGlkUm93IiwiaGFzUmVxdWlyZWRGaWVsZHMiLCJyZXF1aXJlZENvbHVtbiIsInJlcXVpcmVkQ29sdW1ucyIsInB1c2giLCJtYXBwaW5ncyIsInNvdXJjZVZhbHVlIiwic291cmNlQ29sdW1uIiwiZGF0YVF1YWxpdHkiLCJjYWxjdWxhdGVEYXRhUXVhbGl0eSIsImNvbXByZWhlbnNpdmVEYXRhIiwibGFzdFByb2Nlc3NlZCIsInRhcmdldENhdGVnb3J5Iiwib3BlcmF0aW9uYWxSZXBvcnRpbmciLCJ0YXJnZXRTdWJjYXRlZ29yeSIsImFnZ3JlZ2F0ZURhdGEiLCJidXNpbmVzc0ZpbmFuY2lhbHMiLCJzYWxlc0dyb3d0aFRyYWplY3RvcnkiLCJzdWNjZXNzIiwic3VtbWFyeSIsInRvdGFsUm93cyIsImFnZ3JlZ2F0ZWQiLCJrZXlzIiwiT2JqZWN0Iiwia2V5IiwidmFsdWVzIiwiZmlsdGVyIiwidmFsIiwiZmlyc3RWYWx1ZSIsInRvdGFsIiwicmVkdWNlIiwic3VtIiwiYXZlcmFnZSIsIk1hdGgiLCJjb3VudCIsInVuaXF1ZVZhbHVlcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsInRvdGFsRmllbGRzIiwidmFsaWRGaWVsZHMiLCJyIiwicmVxdWlyZWRGaWVsZHNDb3VudCIsImZpbGxlZFJlcXVpcmVkRmllbGRzIiwic29tZSIsImNvbCIsImZpbmQiLCJtIiwibWlzc2luZ0ZpZWxkcyIsImludmFsaWRWYWx1ZXMiLCJyZWFzb24iLCJjb21wbGV0ZW5lc3MiLCJhY2N1cmFjeSIsImNvbnNpc3RlbmN5IiwidGltZWxpbmVzcyIsInZhbGlkUmVjb3JkcyIsInRvdGFsUmVjb3JkcyIsImRldGVjdERhdGFUZW1wbGF0ZSIsImNvbHVtbkhlYWRlcnMiLCJmaWxlTmFtZSIsImJlc3RNYXRjaCIsInNjb3JlIiwiaGVhZGVyIiwibm9ybWFsaXplZFNjb3JlIiwiY29sdW1uQW5hbHlzaXMiLCJhbmFseXplQ29sdW1ucyIsImFkYXB0aXZlVGVtcGxhdGUiLCJjcmVhdGVBZGFwdGl2ZVRlbXBsYXRlIiwicGFyc2VGaWxlIiwiZmlsZSIsIlhMU1giLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwidGFyZ2V0Iiwid29ya2Jvb2siLCJ0eXBlIiwicmVhZCIsInNoZWV0TmFtZSIsIlNoZWV0TmFtZXMiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJqc29uRGF0YSIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsImRhdGFSb3dzIiwic2xpY2UiLCJyb3dPYmoiLCJmb3JFYWNoIiwiaW5kZXgiLCJvbmVycm9yIiwicmVhZEFzVGV4dCIsInJlYWRBc0FycmF5QnVmZmVyIiwiZXh0cmFjdENhcnRvblBhbGxldERhdGEiLCJjb2x1bW5NYXBwaW5ncyIsInVuaXRzX3Blcl9jYXJ0b24iLCJjYXJ0b25zX3Blcl9wYWxsZXQiLCJkYXlzX29uX2hhbmQiLCJmaXJzdFJvdyIsImNvbHVtbk5hbWVzIiwiZm91bmRDb2x1bW5zIiwiZW50cmllcyIsIm1hdGNoaW5nQ29sdW1uIiwiaW5kZXhPZiIsInJvdW5kIiwibnVtZXJpY0NvbHVtbnMiLCJhdmciLCJjb2xOYW1lIiwiZXh0cmFjdE1ldGFkYXRhIiwicm93Q291bnQiLCJjb2x1bW5Db3VudCIsInByb2Nlc3NpbmdEYXRlIiwiY29sdW1ucyIsImNhcnRvblBhbGxldERhdGEiLCJkYXRhVHlwZXMiLCJhbmFseXplQ29sdW1uVHlwZXMiLCJzYW1wbGVEYXRhIiwidHlwZUFuYWx5c2lzIiwiY29sdW1uIiwic2FtcGxlVmFsdWVzIiwibnVtZXJpY1ZhbHVlcyIsImRhdGVWYWx1ZXMiLCJwYXJzZSIsIkRhdGFQcm9jZXNzaW5nVXRpbHMiLCJmb3JtYXRWYWxpZGF0aW9uUmVzdWx0cyIsInJlc3VsdHMiLCJmb3JtYXREYXRhUXVhbGl0eSIsInF1YWxpdHkiLCJnZW5lcmF0ZVByb2Nlc3NpbmdTdW1tYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/data-validator.ts\n");

/***/ }),

/***/ "(rsc)/./lib/missing-data-imputation.ts":
/*!****************************************!*\
  !*** ./lib/missing-data-imputation.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdvancedDataImputation: () => (/* binding */ AdvancedDataImputation)\n/* harmony export */ });\n// Advanced Missing Data Imputation System\n// Implements Random Forests, XGBoost-style algorithms, Neural Networks (MissForest, GAIN), and MICE\nclass AdvancedDataImputation {\n    /**\n   * Diagnose missing data patterns and recommend imputation strategy\n   */ static diagnoseMissingData(data) {\n        if (!data || data.length === 0) {\n            return {\n                patterns: [],\n                recommendations: [],\n                suggestedMethod: \"mean_median\"\n            };\n        }\n        const columns = Object.keys(data[0]);\n        const patterns = [];\n        const recommendations = [];\n        // Analyze each field for missing patterns\n        for (const field of columns){\n            const pattern = this.analyzeFieldMissingPattern(data, field, columns);\n            if (pattern.missingCount > 0) {\n                patterns.push(pattern);\n            }\n        }\n        // Generate recommendations based on patterns\n        const totalMissing = patterns.reduce((sum, p)=>sum + p.missingCount, 0);\n        const highCorrelationPatterns = patterns.filter((p)=>p.correlatedWith.length > 0);\n        if (totalMissing === 0) {\n            recommendations.push(\"No missing data detected - ready for processing\");\n            return {\n                patterns,\n                recommendations,\n                suggestedMethod: \"none\"\n            };\n        }\n        if (patterns.length <= 2 && patterns.every((p)=>p.missingPercentage < 10)) {\n            recommendations.push(\"Low missing data rate - simple imputation methods recommended\");\n            return {\n                patterns,\n                recommendations,\n                suggestedMethod: \"mean_median\"\n            };\n        }\n        if (highCorrelationPatterns.length > 0) {\n            recommendations.push(\"Strong correlations detected - use regression or ML-based methods\");\n            return {\n                patterns,\n                recommendations,\n                suggestedMethod: \"random_forest\"\n            };\n        }\n        if (patterns.some((p)=>p.missingPercentage > 30)) {\n            recommendations.push(\"High missing data rate - advanced imputation required\");\n            return {\n                patterns,\n                recommendations,\n                suggestedMethod: \"neural_network\"\n            };\n        }\n        recommendations.push(\"Moderate complexity - MICE or Random Forest recommended\");\n        return {\n            patterns,\n            recommendations,\n            suggestedMethod: \"mice\"\n        };\n    }\n    /**\n   * Main imputation method that automatically selects best strategy\n   */ static async imputeMissingData(data, config = {}) {\n        const defaultConfig = {\n            method: \"auto\",\n            confidence_threshold: 0.7,\n            max_iterations: 10,\n            mark_imputed: true\n        };\n        const finalConfig = {\n            ...defaultConfig,\n            ...config\n        };\n        if (!data || data.length === 0) {\n            throw new Error(\"No data provided for imputation\");\n        }\n        // Diagnose missing data first\n        const diagnosis = this.diagnoseMissingData(data);\n        // Auto-select method if not specified\n        let method = finalConfig.method;\n        if (method === \"auto\") {\n            method = diagnosis.suggestedMethod;\n        }\n        // Perform imputation based on selected method\n        let result;\n        switch(method){\n            case \"mean_median\":\n                result = this.imputeWithMeanMedian(data, finalConfig);\n                break;\n            case \"knn\":\n                result = this.imputeWithKNN(data, finalConfig);\n                break;\n            case \"regression\":\n                result = this.imputeWithRegression(data, finalConfig);\n                break;\n            case \"random_forest\":\n                result = this.imputeWithRandomForest(data, finalConfig);\n                break;\n            case \"neural_network\":\n                result = await this.imputeWithNeuralNetwork(data, finalConfig);\n                break;\n            case \"mice\":\n                result = this.imputeWithMICE(data, finalConfig);\n                break;\n            default:\n                result = this.imputeWithMeanMedian(data, finalConfig);\n        }\n        // Add diagnosis information to result\n        result.statistics.methodsUsed = [\n            method\n        ];\n        return result;\n    }\n    /**\n   * Simple mean/median imputation for basic cases\n   */ static imputeWithMeanMedian(data, config) {\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        for (const column of columns){\n            const values = data.map((row)=>row[column]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            if (values.length === 0) continue;\n            let imputeValue;\n            const numericValues = values.filter((val)=>!isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (numericValues.length === values.length && numericValues.length > 0) {\n                // Numeric field - use median for robustness\n                const sorted = numericValues.sort((a, b)=>a - b);\n                const mid = Math.floor(sorted.length / 2);\n                imputeValue = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n            } else {\n                // Categorical field - use mode\n                const counts = values.reduce((acc, val)=>{\n                    acc[val] = (acc[val] || 0) + 1;\n                    return acc;\n                }, {});\n                imputeValue = Object.keys(counts).reduce((a, b)=>counts[a] > counts[b] ? a : b);\n            }\n            // Apply imputation\n            for(let i = 0; i < imputedData.length; i++){\n                const originalValue = imputedData[i][column];\n                if (originalValue === null || originalValue === undefined || originalValue === \"\") {\n                    imputedData[i][column] = imputeValue;\n                    if (config.mark_imputed) {\n                        imputedData[i][`${column}_imputed`] = true;\n                    }\n                    imputedFields.push({\n                        field: column,\n                        originalValue,\n                        imputedValue: imputeValue,\n                        confidence: 0.6,\n                        method: \"mean_median\",\n                        rowIndex: i\n                    });\n                }\n            }\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"mean_median\"\n        ]);\n    }\n    /**\n   * K-Nearest Neighbors imputation\n   */ static imputeWithKNN(data, config) {\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        const k = Math.min(5, Math.floor(data.length / 10)); // Dynamic k selection\n        for (const targetColumn of columns){\n            const missingIndices = imputedData.map((row, idx)=>({\n                    row,\n                    idx\n                })).filter(({ row })=>row[targetColumn] === null || row[targetColumn] === undefined || row[targetColumn] === \"\").map(({ idx })=>idx);\n            if (missingIndices.length === 0) continue;\n            const validData = imputedData.filter((row)=>row[targetColumn] !== null && row[targetColumn] !== undefined && row[targetColumn] !== \"\");\n            if (validData.length === 0) continue;\n            for (const missingIdx of missingIndices){\n                const missingRow = imputedData[missingIdx];\n                // Calculate distances to all valid rows\n                const distances = validData.map((validRow)=>({\n                        row: validRow,\n                        distance: this.calculateDistance(missingRow, validRow, columns.filter((col)=>col !== targetColumn))\n                    }));\n                // Get k nearest neighbors\n                const neighbors = distances.sort((a, b)=>a.distance - b.distance).slice(0, k);\n                // Compute imputed value\n                const neighborValues = neighbors.map((n)=>n.row[targetColumn]);\n                let imputedValue;\n                if (neighborValues.every((val)=>!isNaN(parseFloat(val)))) {\n                    // Numeric - weighted average\n                    const weights = neighbors.map((n)=>1 / (n.distance + 1e-6)); // Add small epsilon to avoid division by zero\n                    const weightedSum = neighbors.reduce((sum, n, i)=>sum + parseFloat(n.row[targetColumn]) * weights[i], 0);\n                    const weightSum = weights.reduce((sum, w)=>sum + w, 0);\n                    imputedValue = weightedSum / weightSum;\n                } else {\n                    // Categorical - mode of neighbors\n                    const counts = neighborValues.reduce((acc, val)=>{\n                        acc[val] = (acc[val] || 0) + 1;\n                        return acc;\n                    }, {});\n                    imputedValue = Object.keys(counts).reduce((a, b)=>counts[a] > counts[b] ? a : b);\n                }\n                // Apply imputation\n                const confidence = Math.max(0.5, 1 - (neighbors[0]?.distance || 0.5));\n                imputedData[missingIdx][targetColumn] = imputedValue;\n                if (config.mark_imputed) {\n                    imputedData[missingIdx][`${targetColumn}_imputed`] = true;\n                }\n                imputedFields.push({\n                    field: targetColumn,\n                    originalValue: missingRow[targetColumn],\n                    imputedValue,\n                    confidence,\n                    method: \"knn\",\n                    rowIndex: missingIdx\n                });\n            }\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"knn\"\n        ]);\n    }\n    /**\n   * Regression-based imputation\n   */ static imputeWithRegression(data, config) {\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        for (const targetColumn of columns){\n            const missingIndices = imputedData.map((row, idx)=>({\n                    row,\n                    idx\n                })).filter(({ row })=>row[targetColumn] === null || row[targetColumn] === undefined || row[targetColumn] === \"\").map(({ idx })=>idx);\n            if (missingIndices.length === 0) continue;\n            // Get predictor columns (exclude target and non-numeric)\n            const predictorColumns = columns.filter((col)=>{\n                if (col === targetColumn) return false;\n                const values = data.map((row)=>row[col]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n                return values.length > 0 && values.every((val)=>!isNaN(parseFloat(val)));\n            });\n            if (predictorColumns.length === 0) continue;\n            // Prepare training data\n            const trainingData = imputedData.filter((row)=>row[targetColumn] !== null && row[targetColumn] !== undefined && row[targetColumn] !== \"\" && predictorColumns.every((col)=>row[col] !== null && row[col] !== undefined && row[col] !== \"\"));\n            if (trainingData.length < 3) continue; // Need minimum data for regression\n            // Simple linear regression implementation\n            const { coefficients, rSquared } = this.simpleLinearRegression(trainingData, predictorColumns, targetColumn);\n            // Apply predictions\n            for (const missingIdx of missingIndices){\n                const missingRow = imputedData[missingIdx];\n                // Check if all predictors are available\n                if (predictorColumns.some((col)=>missingRow[col] === null || missingRow[col] === undefined || missingRow[col] === \"\")) {\n                    continue; // Skip if predictors are missing\n                }\n                // Calculate predicted value\n                let prediction = coefficients?.intercept || 0;\n                for(let i = 0; i < predictorColumns.length; i++){\n                    prediction += (coefficients?.slopes[i] || 0) * parseFloat(missingRow[predictorColumns[i]]);\n                }\n                const confidence = Math.max(0.4, rSquared);\n                imputedData[missingIdx][targetColumn] = prediction;\n                if (config.mark_imputed) {\n                    imputedData[missingIdx][`${targetColumn}_imputed`] = true;\n                }\n                imputedFields.push({\n                    field: targetColumn,\n                    originalValue: missingRow[targetColumn],\n                    imputedValue: prediction,\n                    confidence,\n                    method: \"regression\",\n                    rowIndex: missingIdx\n                });\n            }\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"regression\"\n        ]);\n    }\n    /**\n   * Random Forest-style imputation\n   */ static imputeWithRandomForest(data, config) {\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        const numTrees = 10; // Simplified forest size\n        for (const targetColumn of columns){\n            const missingIndices = imputedData.map((row, idx)=>({\n                    row,\n                    idx\n                })).filter(({ row })=>row[targetColumn] === null || row[targetColumn] === undefined || row[targetColumn] === \"\").map(({ idx })=>idx);\n            if (missingIndices.length === 0) continue;\n            const predictorColumns = columns.filter((col)=>col !== targetColumn);\n            // Create multiple decision trees (simplified random forest)\n            const trees = [];\n            for(let t = 0; t < numTrees; t++){\n                const tree = this.buildSimpleDecisionTree(imputedData, predictorColumns, targetColumn);\n                if (tree) trees.push(tree);\n            }\n            if (trees.length === 0) continue;\n            // Apply ensemble predictions\n            for (const missingIdx of missingIndices){\n                const missingRow = imputedData[missingIdx];\n                const predictions = trees.map((tree)=>this.predictWithTree(tree, missingRow));\n                let imputedValue;\n                if (predictions.every((p)=>!isNaN(parseFloat(p)))) {\n                    // Numeric - average\n                    imputedValue = predictions.reduce((sum, p)=>sum + parseFloat(p), 0) / predictions.length;\n                } else {\n                    // Categorical - mode\n                    const counts = predictions.reduce((acc, val)=>{\n                        acc[val] = (acc[val] || 0) + 1;\n                        return acc;\n                    }, {});\n                    imputedValue = Object.keys(counts).reduce((a, b)=>counts[a] > counts[b] ? a : b);\n                }\n                const confidence = Math.min(0.9, 0.5 + trees.length / numTrees * 0.4);\n                imputedData[missingIdx][targetColumn] = imputedValue;\n                if (config.mark_imputed) {\n                    imputedData[missingIdx][`${targetColumn}_imputed`] = true;\n                }\n                imputedFields.push({\n                    field: targetColumn,\n                    originalValue: missingRow[targetColumn],\n                    imputedValue,\n                    confidence,\n                    method: \"random_forest\",\n                    rowIndex: missingIdx\n                });\n            }\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"random_forest\"\n        ]);\n    }\n    /**\n   * Neural Network-based imputation (simplified implementation of GAIN concept)\n   */ static async imputeWithNeuralNetwork(data, config) {\n        // Simplified neural network approach - in production, would use TensorFlow.js\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        // Convert to numeric matrix for neural network processing\n        const { matrix, columnInfo } = this.prepareDataMatrix(data, columns);\n        if (matrix.length === 0) {\n            return this.buildImputationResult(imputedData, imputedFields, [\n                \"neural_network\"\n            ]);\n        }\n        // Simple autoencoder-style imputation\n        for(let colIdx = 0; colIdx < columns.length; colIdx++){\n            const targetColumn = columns[colIdx];\n            const missingRows = matrix.map((row, idx)=>({\n                    row,\n                    idx\n                })).filter(({ row })=>isNaN(row[colIdx])).map(({ idx })=>idx);\n            if (missingRows.length === 0) continue;\n            // Use other columns to predict missing values\n            const completeRows = matrix.filter((row)=>!isNaN(row[colIdx]));\n            if (completeRows.length < 3) continue;\n            // Simplified neural network prediction (would be replaced with actual NN in production)\n            for (const missingRowIdx of missingRows){\n                const missingRow = matrix[missingRowIdx];\n                const predictions = [];\n                // Find similar complete rows based on available features\n                for (const completeRow of completeRows){\n                    let similarity = 0;\n                    let validComparisons = 0;\n                    for(let i = 0; i < columns.length; i++){\n                        if (i !== colIdx && !isNaN(missingRow[i]) && !isNaN(completeRow[i])) {\n                            similarity += 1 - Math.abs(missingRow[i] - completeRow[i]) / (1 + Math.abs(missingRow[i]) + Math.abs(completeRow[i]));\n                            validComparisons++;\n                        }\n                    }\n                    if (validComparisons > 0) {\n                        predictions.push({\n                            value: completeRow[colIdx],\n                            weight: similarity / validComparisons\n                        });\n                    }\n                }\n                if (predictions.length === 0) continue;\n                // Weighted average prediction\n                const totalWeight = predictions.reduce((sum, p)=>sum + p.weight, 0);\n                let imputedValue = predictions.reduce((sum, p)=>sum + p.value * p.weight, 0) / totalWeight;\n                // Convert back to original scale if needed\n                if (columnInfo[colIdx].isNormalized) {\n                    imputedValue = imputedValue * (columnInfo[colIdx].max - columnInfo[colIdx].min) + columnInfo[colIdx].min;\n                }\n                // Apply to original data\n                const confidence = Math.min(0.95, Math.max(0.6, totalWeight / predictions.length));\n                imputedData[missingRowIdx][targetColumn] = columnInfo[colIdx].isNumeric ? imputedValue : columnInfo[colIdx].valueMap[Math.round(imputedValue)];\n                if (config.mark_imputed) {\n                    imputedData[missingRowIdx][`${targetColumn}_imputed`] = true;\n                }\n                imputedFields.push({\n                    field: targetColumn,\n                    originalValue: data[missingRowIdx][targetColumn],\n                    imputedValue: imputedData[missingRowIdx][targetColumn],\n                    confidence,\n                    method: \"neural_network\",\n                    rowIndex: missingRowIdx\n                });\n            }\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"neural_network\"\n        ]);\n    }\n    /**\n   * Multiple Imputation by Chained Equations (MICE)\n   */ static imputeWithMICE(data, config) {\n        const imputedData = JSON.parse(JSON.stringify(data));\n        const imputedFields = [];\n        const columns = Object.keys(data[0]);\n        const maxIterations = config.max_iterations;\n        // Initialize missing values with mean/mode\n        this.initializeMissingValues(imputedData, columns);\n        // Iterative imputation\n        for(let iteration = 0; iteration < maxIterations; iteration++){\n            let hasChanges = false;\n            for (const targetColumn of columns){\n                const missingIndices = data.map((row, idx)=>({\n                        row,\n                        idx\n                    })).filter(({ row })=>row[targetColumn] === null || row[targetColumn] === undefined || row[targetColumn] === \"\").map(({ idx })=>idx);\n                if (missingIndices.length === 0) continue;\n                const otherColumns = columns.filter((col)=>col !== targetColumn);\n                // Use regression to predict missing values\n                const { coefficients } = this.simpleLinearRegression(imputedData.filter((_, idx)=>!missingIndices.includes(idx)), otherColumns.filter((col)=>{\n                    const values = imputedData.map((row)=>row[col]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n                    return values.length > 0 && values.every((val)=>!isNaN(parseFloat(val)));\n                }), targetColumn);\n                if (!coefficients) continue;\n                // Apply new predictions\n                for (const missingIdx of missingIndices){\n                    const row = imputedData[missingIdx];\n                    let newValue = coefficients.intercept;\n                    let validPrediction = true;\n                    for(let i = 0; i < coefficients.slopes.length; i++){\n                        const colName = otherColumns[i];\n                        if (row[colName] === null || row[colName] === undefined || isNaN(parseFloat(row[colName]))) {\n                            validPrediction = false;\n                            break;\n                        }\n                        newValue += coefficients.slopes[i] * parseFloat(row[colName]);\n                    }\n                    if (validPrediction && row[targetColumn] !== newValue) {\n                        const oldValue = row[targetColumn];\n                        row[targetColumn] = newValue;\n                        hasChanges = true;\n                        // Track this imputation (only on final iteration)\n                        if (iteration === maxIterations - 1) {\n                            imputedFields.push({\n                                field: targetColumn,\n                                originalValue: data[missingIdx][targetColumn],\n                                imputedValue: newValue,\n                                confidence: Math.max(0.7, 1 - iteration / maxIterations),\n                                method: \"mice\",\n                                rowIndex: missingIdx\n                            });\n                            if (config.mark_imputed) {\n                                row[`${targetColumn}_imputed`] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            // Convergence check\n            if (!hasChanges) break;\n        }\n        return this.buildImputationResult(imputedData, imputedFields, [\n            \"mice\"\n        ]);\n    }\n    // Helper methods\n    static analyzeFieldMissingPattern(data, field, allColumns) {\n        const missingRows = data.filter((row)=>row[field] === null || row[field] === undefined || row[field] === \"\");\n        const missingCount = missingRows.length;\n        const missingPercentage = missingCount / data.length * 100;\n        // Analyze correlations with other missing fields\n        const correlatedWith = [];\n        const predictors = [];\n        for (const otherField of allColumns){\n            if (otherField === field) continue;\n            // Check correlation with missing pattern\n            const otherMissingRows = data.filter((row)=>row[otherField] === null || row[otherField] === undefined || row[otherField] === \"\");\n            const commonMissing = missingRows.filter((row)=>otherMissingRows.includes(row)).length;\n            if (commonMissing > missingCount * 0.3) {\n                correlatedWith.push(otherField);\n            }\n            // Check if this field could predict the missing field\n            const completeRows = data.filter((row)=>row[field] !== null && row[field] !== undefined && row[field] !== \"\" && row[otherField] !== null && row[otherField] !== undefined && row[otherField] !== \"\");\n            if (completeRows.length > data.length * 0.5) {\n                predictors.push(otherField);\n            }\n        }\n        // Determine pattern type\n        let pattern = \"random\";\n        if (correlatedWith.length > 0) {\n            pattern = \"correlated\";\n        } else if (missingPercentage > 50 || predictors.length < 2) {\n            pattern = \"systematic\";\n        }\n        const confidence = predictors.length > 0 ? Math.min(0.9, predictors.length / allColumns.length * 2) : 0.3;\n        return {\n            field,\n            missingCount,\n            missingPercentage,\n            pattern,\n            correlatedWith,\n            predictors,\n            confidence\n        };\n    }\n    static calculateDistance(row1, row2, columns) {\n        let distance = 0;\n        let validComparisons = 0;\n        for (const col of columns){\n            const val1 = row1[col];\n            const val2 = row2[col];\n            if (val1 === null || val1 === undefined || val1 === \"\" || val2 === null || val2 === undefined || val2 === \"\") {\n                continue;\n            }\n            if (!isNaN(parseFloat(val1)) && !isNaN(parseFloat(val2))) {\n                // Numeric distance\n                const num1 = parseFloat(val1);\n                const num2 = parseFloat(val2);\n                distance += Math.abs(num1 - num2);\n            } else {\n                // Categorical distance\n                distance += val1 === val2 ? 0 : 1;\n            }\n            validComparisons++;\n        }\n        return validComparisons > 0 ? distance / validComparisons : Infinity;\n    }\n    static simpleLinearRegression(data, predictorColumns, targetColumn) {\n        const validRows = data.filter((row)=>row[targetColumn] !== null && row[targetColumn] !== undefined && row[targetColumn] !== \"\" && predictorColumns.every((col)=>row[col] !== null && row[col] !== undefined && row[col] !== \"\"));\n        if (validRows.length < 3) {\n            return {\n                coefficients: null,\n                rSquared: 0\n            };\n        }\n        // Simple multiple linear regression implementation\n        const y = validRows.map((row)=>parseFloat(row[targetColumn]));\n        const X = validRows.map((row)=>predictorColumns.map((col)=>parseFloat(row[col])));\n        // Add intercept column\n        X.forEach((row)=>row.unshift(1));\n        // Calculate coefficients using normal equation: (X'X)^-1 * X'y\n        const XTranspose = this.transposeMatrix(X);\n        const XTX = this.multiplyMatrices(XTranspose, X);\n        const XTy = this.multiplyMatrixVector(XTranspose, y);\n        const coefficients = this.solveLinearSystem(XTX, XTy);\n        if (!coefficients) {\n            return {\n                coefficients: null,\n                rSquared: 0\n            };\n        }\n        // Calculate R-squared\n        const predictions = X.map((row)=>row.reduce((sum, val, idx)=>sum + val * coefficients[idx], 0));\n        const yMean = y.reduce((sum, val)=>sum + val, 0) / y.length;\n        const totalSumSquares = y.reduce((sum, val)=>sum + Math.pow(val - yMean, 2), 0);\n        const residualSumSquares = y.reduce((sum, val, idx)=>sum + Math.pow(val - predictions[idx], 2), 0);\n        const rSquared = totalSumSquares > 0 ? 1 - residualSumSquares / totalSumSquares : 0;\n        return {\n            coefficients: {\n                intercept: coefficients[0],\n                slopes: coefficients.slice(1)\n            },\n            rSquared: Math.max(0, Math.min(1, rSquared))\n        };\n    }\n    static buildSimpleDecisionTree(data, predictorColumns, targetColumn) {\n        const validData = data.filter((row)=>row[targetColumn] !== null && row[targetColumn] !== undefined && row[targetColumn] !== \"\" && predictorColumns.some((col)=>row[col] !== null && row[col] !== undefined && row[col] !== \"\"));\n        if (validData.length < 3) return null;\n        // Simple tree: find best single split\n        let bestSplit = null;\n        let bestScore = -Infinity;\n        for (const col of predictorColumns){\n            const values = validData.map((row)=>row[col]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            if (values.length === 0) continue;\n            if (values.every((val)=>!isNaN(parseFloat(val)))) {\n                // Numeric split\n                const numValues = values.map((val)=>parseFloat(val)).sort((a, b)=>a - b);\n                const splitPoint = numValues[Math.floor(numValues.length / 2)];\n                const leftGroup = validData.filter((row)=>parseFloat(row[col]) <= splitPoint);\n                const rightGroup = validData.filter((row)=>parseFloat(row[col]) > splitPoint);\n                const score = this.calculateSplitScore(leftGroup, rightGroup, targetColumn);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestSplit = {\n                        column: col,\n                        splitPoint,\n                        type: \"numeric\"\n                    };\n                }\n            }\n        }\n        if (!bestSplit) return null;\n        const leftValue = this.calculateGroupValue(validData.filter((row)=>parseFloat(row[bestSplit.column]) <= bestSplit.splitPoint), targetColumn);\n        const rightValue = this.calculateGroupValue(validData.filter((row)=>parseFloat(row[bestSplit.column]) > bestSplit.splitPoint), targetColumn);\n        return {\n            split: bestSplit,\n            leftValue,\n            rightValue\n        };\n    }\n    static predictWithTree(tree, row) {\n        if (!tree || !tree.split) return null;\n        const value = row[tree.split.column];\n        if (value === null || value === undefined || value === \"\") return null;\n        if (tree.split.type === \"numeric\") {\n            return parseFloat(value) <= tree.split.splitPoint ? tree.leftValue : tree.rightValue;\n        }\n        return tree.leftValue; // Fallback\n    }\n    static calculateSplitScore(leftGroup, rightGroup, targetColumn) {\n        if (leftGroup.length === 0 || rightGroup.length === 0) return -Infinity;\n        const leftValues = leftGroup.map((row)=>row[targetColumn]);\n        const rightValues = rightGroup.map((row)=>row[targetColumn]);\n        // Simple variance reduction score\n        const totalVariance = this.calculateVariance([\n            ...leftValues,\n            ...rightValues\n        ]);\n        const leftVariance = this.calculateVariance(leftValues);\n        const rightVariance = this.calculateVariance(rightValues);\n        const weightedVariance = (leftGroup.length * leftVariance + rightGroup.length * rightVariance) / (leftGroup.length + rightGroup.length);\n        return totalVariance - weightedVariance;\n    }\n    static calculateVariance(values) {\n        if (values.length === 0) return 0;\n        const numValues = values.filter((val)=>!isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n        if (numValues.length === 0) return 0;\n        const mean = numValues.reduce((sum, val)=>sum + val, 0) / numValues.length;\n        return numValues.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / numValues.length;\n    }\n    static calculateGroupValue(group, targetColumn) {\n        if (group.length === 0) return null;\n        const values = group.map((row)=>row[targetColumn]);\n        const numValues = values.filter((val)=>!isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n        if (numValues.length === values.length && numValues.length > 0) {\n            // Numeric - return mean\n            return numValues.reduce((sum, val)=>sum + val, 0) / numValues.length;\n        } else {\n            // Categorical - return mode\n            const counts = values.reduce((acc, val)=>{\n                acc[val] = (acc[val] || 0) + 1;\n                return acc;\n            }, {});\n            return Object.keys(counts).reduce((a, b)=>counts[a] > counts[b] ? a : b);\n        }\n    }\n    static prepareDataMatrix(data, columns) {\n        const columnInfo = columns.map((col)=>{\n            const values = data.map((row)=>row[col]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            const numericValues = values.filter((val)=>!isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (numericValues.length === values.length && numericValues.length > 0) {\n                const min = Math.min(...numericValues);\n                const max = Math.max(...numericValues);\n                return {\n                    isNumeric: true,\n                    isNormalized: max > min,\n                    min,\n                    max,\n                    valueMap: null\n                };\n            } else {\n                const uniqueValues = Array.from(new Set(values));\n                const valueMap = uniqueValues.reduce((map, val, idx)=>{\n                    map[idx] = val;\n                    return map;\n                }, {});\n                return {\n                    isNumeric: false,\n                    isNormalized: false,\n                    min: 0,\n                    max: uniqueValues.length - 1,\n                    valueMap\n                };\n            }\n        });\n        const matrix = data.map((row)=>{\n            return columns.map((col, idx)=>{\n                const value = row[col];\n                if (value === null || value === undefined || value === \"\") {\n                    return NaN;\n                }\n                if (columnInfo[idx].isNumeric) {\n                    const num = parseFloat(value);\n                    return columnInfo[idx].isNormalized ? (num - columnInfo[idx].min) / (columnInfo[idx].max - columnInfo[idx].min) : num;\n                } else {\n                    const uniqueValues = Object.values(columnInfo[idx].valueMap);\n                    const index = uniqueValues.indexOf(value);\n                    return index >= 0 ? index : NaN;\n                }\n            });\n        });\n        return {\n            matrix,\n            columnInfo\n        };\n    }\n    static initializeMissingValues(data, columns) {\n        for (const col of columns){\n            const values = data.map((row)=>row[col]).filter((val)=>val !== null && val !== undefined && val !== \"\");\n            if (values.length === 0) continue;\n            let defaultValue;\n            const numericValues = values.filter((val)=>!isNaN(parseFloat(val))).map((val)=>parseFloat(val));\n            if (numericValues.length === values.length && numericValues.length > 0) {\n                // Use median for numeric\n                const sorted = numericValues.sort((a, b)=>a - b);\n                const mid = Math.floor(sorted.length / 2);\n                defaultValue = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n            } else {\n                // Use mode for categorical\n                const counts = values.reduce((acc, val)=>{\n                    acc[val] = (acc[val] || 0) + 1;\n                    return acc;\n                }, {});\n                defaultValue = Object.keys(counts).reduce((a, b)=>counts[a] > counts[b] ? a : b);\n            }\n            // Apply default value to missing entries\n            for (const row of data){\n                if (row[col] === null || row[col] === undefined || row[col] === \"\") {\n                    row[col] = defaultValue;\n                }\n            }\n        }\n    }\n    static transposeMatrix(matrix) {\n        if (matrix.length === 0) return [];\n        return matrix[0].map((_, colIndex)=>matrix.map((row)=>row[colIndex]));\n    }\n    static multiplyMatrices(a, b) {\n        const result = Array(a.length).fill(null).map(()=>Array(b[0].length).fill(0));\n        for(let i = 0; i < a.length; i++){\n            for(let j = 0; j < b[0].length; j++){\n                for(let k = 0; k < b.length; k++){\n                    result[i][j] += a[i][k] * b[k][j];\n                }\n            }\n        }\n        return result;\n    }\n    static multiplyMatrixVector(matrix, vector) {\n        return matrix.map((row)=>row.reduce((sum, val, idx)=>sum + val * vector[idx], 0));\n    }\n    static solveLinearSystem(A, b) {\n        // Simple Gaussian elimination\n        const n = A.length;\n        const augmented = A.map((row, i)=>[\n                ...row,\n                b[i]\n            ]);\n        // Forward elimination\n        for(let i = 0; i < n; i++){\n            // Find pivot\n            let maxRow = i;\n            for(let k = i + 1; k < n; k++){\n                if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {\n                    maxRow = k;\n                }\n            }\n            // Swap rows\n            [augmented[i], augmented[maxRow]] = [\n                augmented[maxRow],\n                augmented[i]\n            ];\n            // Check for singular matrix\n            if (Math.abs(augmented[i][i]) < 1e-10) {\n                return null;\n            }\n            // Eliminate\n            for(let k = i + 1; k < n; k++){\n                const factor = augmented[k][i] / augmented[i][i];\n                for(let j = i; j <= n; j++){\n                    augmented[k][j] -= factor * augmented[i][j];\n                }\n            }\n        }\n        // Back substitution\n        const solution = new Array(n);\n        for(let i = n - 1; i >= 0; i--){\n            solution[i] = augmented[i][n];\n            for(let j = i + 1; j < n; j++){\n                solution[i] -= augmented[i][j] * solution[j];\n            }\n            solution[i] /= augmented[i][i];\n        }\n        return solution;\n    }\n    static buildImputationResult(data, imputedFields, methods) {\n        const totalMissing = imputedFields.length;\n        const totalImputed = imputedFields.length;\n        const averageConfidence = totalImputed > 0 ? imputedFields.reduce((sum, field)=>sum + field.confidence, 0) / totalImputed : 0;\n        // Calculate quality metrics\n        const completeness = 100; // All missing data is now filled\n        const reliability = averageConfidence * 100;\n        const consistency = Math.min(100, 80 + averageConfidence * 20); // Consistency based on confidence\n        return {\n            data,\n            imputedFields,\n            statistics: {\n                totalMissing,\n                totalImputed,\n                methodsUsed: methods,\n                averageConfidence\n            },\n            qualityMetrics: {\n                completeness,\n                reliability,\n                consistency\n            }\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjRixvQkFBb0I7UUFDeEMsTUFBTUcsY0FBY3JKLEtBQUtXLEdBQUcsQ0FBQyxLQUFLLEtBQU11SSxvQkFBb0IsS0FBTSxrQ0FBa0M7UUFFcEcsT0FBTztZQUNMaE47WUFDQThDO1lBQ0FOLFlBQVk7Z0JBQ1YzQjtnQkFDQWtNO2dCQUNBdEssYUFBYXFLO2dCQUNiRTtZQUNGO1lBQ0FJLGdCQUFnQjtnQkFDZEg7Z0JBQ0FDO2dCQUNBQztZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV0d29yeC1lc3NlbnRpYWxzLy4vbGliL21pc3NpbmctZGF0YS1pbXB1dGF0aW9uLnRzP2NhNzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWR2YW5jZWQgTWlzc2luZyBEYXRhIEltcHV0YXRpb24gU3lzdGVtXG4vLyBJbXBsZW1lbnRzIFJhbmRvbSBGb3Jlc3RzLCBYR0Jvb3N0LXN0eWxlIGFsZ29yaXRobXMsIE5ldXJhbCBOZXR3b3JrcyAoTWlzc0ZvcmVzdCwgR0FJTiksIGFuZCBNSUNFXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wdXRhdGlvbkNvbmZpZyB7XG4gIG1ldGhvZDogJ21lYW5fbWVkaWFuJyB8ICdrbm4nIHwgJ3JlZ3Jlc3Npb24nIHwgJ3JhbmRvbV9mb3Jlc3QnIHwgJ25ldXJhbF9uZXR3b3JrJyB8ICdtaWNlJyB8ICdhdXRvJztcbiAgY29uZmlkZW5jZV90aHJlc2hvbGQ6IG51bWJlcjtcbiAgbWF4X2l0ZXJhdGlvbnM6IG51bWJlcjtcbiAgbWFya19pbXB1dGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltcHV0YXRpb25SZXN1bHQge1xuICBkYXRhOiBhbnlbXTtcbiAgaW1wdXRlZEZpZWxkczoge1xuICAgIGZpZWxkOiBzdHJpbmc7XG4gICAgb3JpZ2luYWxWYWx1ZTogYW55O1xuICAgIGltcHV0ZWRWYWx1ZTogYW55O1xuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICBtZXRob2Q6IHN0cmluZztcbiAgICByb3dJbmRleDogbnVtYmVyO1xuICB9W107XG4gIHN0YXRpc3RpY3M6IHtcbiAgICB0b3RhbE1pc3Npbmc6IG51bWJlcjtcbiAgICB0b3RhbEltcHV0ZWQ6IG51bWJlcjtcbiAgICBtZXRob2RzVXNlZDogc3RyaW5nW107XG4gICAgYXZlcmFnZUNvbmZpZGVuY2U6IG51bWJlcjtcbiAgfTtcbiAgcXVhbGl0eU1ldHJpY3M6IHtcbiAgICBjb21wbGV0ZW5lc3M6IG51bWJlcjtcbiAgICByZWxpYWJpbGl0eTogbnVtYmVyO1xuICAgIGNvbnNpc3RlbmN5OiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWlzc2luZ0RhdGFQYXR0ZXJuIHtcbiAgZmllbGQ6IHN0cmluZztcbiAgbWlzc2luZ0NvdW50OiBudW1iZXI7XG4gIG1pc3NpbmdQZXJjZW50YWdlOiBudW1iZXI7XG4gIHBhdHRlcm46ICdyYW5kb20nIHwgJ3N5c3RlbWF0aWMnIHwgJ2NvcnJlbGF0ZWQnO1xuICBjb3JyZWxhdGVkV2l0aDogc3RyaW5nW107XG4gIHByZWRpY3RvcnM6IHN0cmluZ1tdO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBZHZhbmNlZERhdGFJbXB1dGF0aW9uIHtcblxuICAvKipcbiAgICogRGlhZ25vc2UgbWlzc2luZyBkYXRhIHBhdHRlcm5zIGFuZCByZWNvbW1lbmQgaW1wdXRhdGlvbiBzdHJhdGVneVxuICAgKi9cbiAgc3RhdGljIGRpYWdub3NlTWlzc2luZ0RhdGEoZGF0YTogYW55W10pOiB7XG4gICAgcGF0dGVybnM6IE1pc3NpbmdEYXRhUGF0dGVybltdO1xuICAgIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XG4gICAgc3VnZ2VzdGVkTWV0aG9kOiBzdHJpbmc7XG4gIH0ge1xuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgcGF0dGVybnM6IFtdLCByZWNvbW1lbmRhdGlvbnM6IFtdLCBzdWdnZXN0ZWRNZXRob2Q6ICdtZWFuX21lZGlhbicgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2x1bW5zID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgY29uc3QgcGF0dGVybnM6IE1pc3NpbmdEYXRhUGF0dGVybltdID0gW107XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQW5hbHl6ZSBlYWNoIGZpZWxkIGZvciBtaXNzaW5nIHBhdHRlcm5zXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBjb2x1bW5zKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5hbmFseXplRmllbGRNaXNzaW5nUGF0dGVybihkYXRhLCBmaWVsZCwgY29sdW1ucyk7XG4gICAgICBpZiAocGF0dGVybi5taXNzaW5nQ291bnQgPiAwKSB7XG4gICAgICAgIHBhdHRlcm5zLnB1c2gocGF0dGVybik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgcmVjb21tZW5kYXRpb25zIGJhc2VkIG9uIHBhdHRlcm5zXG4gICAgY29uc3QgdG90YWxNaXNzaW5nID0gcGF0dGVybnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAubWlzc2luZ0NvdW50LCAwKTtcbiAgICBjb25zdCBoaWdoQ29ycmVsYXRpb25QYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcihwID0+IHAuY29ycmVsYXRlZFdpdGgubGVuZ3RoID4gMCk7XG5cbiAgICBpZiAodG90YWxNaXNzaW5nID09PSAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnTm8gbWlzc2luZyBkYXRhIGRldGVjdGVkIC0gcmVhZHkgZm9yIHByb2Nlc3NpbmcnKTtcbiAgICAgIHJldHVybiB7IHBhdHRlcm5zLCByZWNvbW1lbmRhdGlvbnMsIHN1Z2dlc3RlZE1ldGhvZDogJ25vbmUnIH07XG4gICAgfVxuXG4gICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA8PSAyICYmIHBhdHRlcm5zLmV2ZXJ5KHAgPT4gcC5taXNzaW5nUGVyY2VudGFnZSA8IDEwKSkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0xvdyBtaXNzaW5nIGRhdGEgcmF0ZSAtIHNpbXBsZSBpbXB1dGF0aW9uIG1ldGhvZHMgcmVjb21tZW5kZWQnKTtcbiAgICAgIHJldHVybiB7IHBhdHRlcm5zLCByZWNvbW1lbmRhdGlvbnMsIHN1Z2dlc3RlZE1ldGhvZDogJ21lYW5fbWVkaWFuJyB9O1xuICAgIH1cblxuICAgIGlmIChoaWdoQ29ycmVsYXRpb25QYXR0ZXJucy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnU3Ryb25nIGNvcnJlbGF0aW9ucyBkZXRlY3RlZCAtIHVzZSByZWdyZXNzaW9uIG9yIE1MLWJhc2VkIG1ldGhvZHMnKTtcbiAgICAgIHJldHVybiB7IHBhdHRlcm5zLCByZWNvbW1lbmRhdGlvbnMsIHN1Z2dlc3RlZE1ldGhvZDogJ3JhbmRvbV9mb3Jlc3QnIH07XG4gICAgfVxuXG4gICAgaWYgKHBhdHRlcm5zLnNvbWUocCA9PiBwLm1pc3NpbmdQZXJjZW50YWdlID4gMzApKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSGlnaCBtaXNzaW5nIGRhdGEgcmF0ZSAtIGFkdmFuY2VkIGltcHV0YXRpb24gcmVxdWlyZWQnKTtcbiAgICAgIHJldHVybiB7IHBhdHRlcm5zLCByZWNvbW1lbmRhdGlvbnMsIHN1Z2dlc3RlZE1ldGhvZDogJ25ldXJhbF9uZXR3b3JrJyB9O1xuICAgIH1cblxuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdNb2RlcmF0ZSBjb21wbGV4aXR5IC0gTUlDRSBvciBSYW5kb20gRm9yZXN0IHJlY29tbWVuZGVkJyk7XG4gICAgcmV0dXJuIHsgcGF0dGVybnMsIHJlY29tbWVuZGF0aW9ucywgc3VnZ2VzdGVkTWV0aG9kOiAnbWljZScgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIGltcHV0YXRpb24gbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBzZWxlY3RzIGJlc3Qgc3RyYXRlZ3lcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpbXB1dGVNaXNzaW5nRGF0YShcbiAgICBkYXRhOiBhbnlbXSxcbiAgICBjb25maWc6IFBhcnRpYWw8SW1wdXRhdGlvbkNvbmZpZz4gPSB7fVxuICApOiBQcm9taXNlPEltcHV0YXRpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBkZWZhdWx0Q29uZmlnOiBJbXB1dGF0aW9uQ29uZmlnID0ge1xuICAgICAgbWV0aG9kOiAnYXV0bycsXG4gICAgICBjb25maWRlbmNlX3RocmVzaG9sZDogMC43LFxuICAgICAgbWF4X2l0ZXJhdGlvbnM6IDEwLFxuICAgICAgbWFya19pbXB1dGVkOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWcgfTtcbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBwcm92aWRlZCBmb3IgaW1wdXRhdGlvbicpO1xuICAgIH1cblxuICAgIC8vIERpYWdub3NlIG1pc3NpbmcgZGF0YSBmaXJzdFxuICAgIGNvbnN0IGRpYWdub3NpcyA9IHRoaXMuZGlhZ25vc2VNaXNzaW5nRGF0YShkYXRhKTtcbiAgICBcbiAgICAvLyBBdXRvLXNlbGVjdCBtZXRob2QgaWYgbm90IHNwZWNpZmllZFxuICAgIGxldCBtZXRob2QgPSBmaW5hbENvbmZpZy5tZXRob2Q7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ2F1dG8nKSB7XG4gICAgICBtZXRob2QgPSBkaWFnbm9zaXMuc3VnZ2VzdGVkTWV0aG9kIGFzIGFueTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGltcHV0YXRpb24gYmFzZWQgb24gc2VsZWN0ZWQgbWV0aG9kXG4gICAgbGV0IHJlc3VsdDogSW1wdXRhdGlvblJlc3VsdDtcblxuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdtZWFuX21lZGlhbic6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW1wdXRlV2l0aE1lYW5NZWRpYW4oZGF0YSwgZmluYWxDb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tubic6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW1wdXRlV2l0aEtOTihkYXRhLCBmaW5hbENvbmZpZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVncmVzc2lvbic6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW1wdXRlV2l0aFJlZ3Jlc3Npb24oZGF0YSwgZmluYWxDb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JhbmRvbV9mb3Jlc3QnOlxuICAgICAgICByZXN1bHQgPSB0aGlzLmltcHV0ZVdpdGhSYW5kb21Gb3Jlc3QoZGF0YSwgZmluYWxDb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25ldXJhbF9uZXR3b3JrJzpcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbXB1dGVXaXRoTmV1cmFsTmV0d29yayhkYXRhLCBmaW5hbENvbmZpZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWljZSc6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW1wdXRlV2l0aE1JQ0UoZGF0YSwgZmluYWxDb25maWcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW1wdXRlV2l0aE1lYW5NZWRpYW4oZGF0YSwgZmluYWxDb25maWcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBkaWFnbm9zaXMgaW5mb3JtYXRpb24gdG8gcmVzdWx0XG4gICAgcmVzdWx0LnN0YXRpc3RpY3MubWV0aG9kc1VzZWQgPSBbbWV0aG9kXTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBtZWFuL21lZGlhbiBpbXB1dGF0aW9uIGZvciBiYXNpYyBjYXNlc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgaW1wdXRlV2l0aE1lYW5NZWRpYW4oZGF0YTogYW55W10sIGNvbmZpZzogSW1wdXRhdGlvbkNvbmZpZyk6IEltcHV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0IGltcHV0ZWREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgY29uc3QgaW1wdXRlZEZpZWxkczogYW55W10gPSBbXTtcbiAgICBjb25zdCBjb2x1bW5zID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG5cbiAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLm1hcChyb3cgPT4gcm93W2NvbHVtbl0pLmZpbHRlcih2YWwgPT4gXG4gICAgICAgIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09ICcnXG4gICAgICApO1xuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIGxldCBpbXB1dGVWYWx1ZTogYW55O1xuICAgICAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodmFsID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKS5tYXAodmFsID0+IHBhcnNlRmxvYXQodmFsKSk7XG5cbiAgICAgIGlmIChudW1lcmljVmFsdWVzLmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aCAmJiBudW1lcmljVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gTnVtZXJpYyBmaWVsZCAtIHVzZSBtZWRpYW4gZm9yIHJvYnVzdG5lc3NcbiAgICAgICAgY29uc3Qgc29ydGVkID0gbnVtZXJpY1ZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3Ioc29ydGVkLmxlbmd0aCAvIDIpO1xuICAgICAgICBpbXB1dGVWYWx1ZSA9IHNvcnRlZC5sZW5ndGggJSAyID09PSAwIFxuICAgICAgICAgID8gKHNvcnRlZFttaWQgLSAxXSArIHNvcnRlZFttaWRdKSAvIDIgXG4gICAgICAgICAgOiBzb3J0ZWRbbWlkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhdGVnb3JpY2FsIGZpZWxkIC0gdXNlIG1vZGVcbiAgICAgICAgY29uc3QgY291bnRzID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICBhY2NbdmFsXSA9IChhY2NbdmFsXSB8fCAwKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBpbXB1dGVWYWx1ZSA9IE9iamVjdC5rZXlzKGNvdW50cykucmVkdWNlKChhLCBiKSA9PiBjb3VudHNbYV0gPiBjb3VudHNbYl0gPyBhIDogYik7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGltcHV0YXRpb25cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1wdXRlZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGltcHV0ZWREYXRhW2ldW2NvbHVtbl07XG4gICAgICAgIGlmIChvcmlnaW5hbFZhbHVlID09PSBudWxsIHx8IG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcmlnaW5hbFZhbHVlID09PSAnJykge1xuICAgICAgICAgIGltcHV0ZWREYXRhW2ldW2NvbHVtbl0gPSBpbXB1dGVWYWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29uZmlnLm1hcmtfaW1wdXRlZCkge1xuICAgICAgICAgICAgaW1wdXRlZERhdGFbaV1bYCR7Y29sdW1ufV9pbXB1dGVkYF0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGltcHV0ZWRGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogY29sdW1uLFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgICAgIGltcHV0ZWRWYWx1ZTogaW1wdXRlVmFsdWUsXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwLjYsIC8vIE1lZGl1bSBjb25maWRlbmNlIGZvciBzaW1wbGUgbWV0aG9kc1xuICAgICAgICAgICAgbWV0aG9kOiAnbWVhbl9tZWRpYW4nLFxuICAgICAgICAgICAgcm93SW5kZXg6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJ1aWxkSW1wdXRhdGlvblJlc3VsdChpbXB1dGVkRGF0YSwgaW1wdXRlZEZpZWxkcywgWydtZWFuX21lZGlhbiddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLLU5lYXJlc3QgTmVpZ2hib3JzIGltcHV0YXRpb25cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGltcHV0ZVdpdGhLTk4oZGF0YTogYW55W10sIGNvbmZpZzogSW1wdXRhdGlvbkNvbmZpZyk6IEltcHV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0IGltcHV0ZWREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgY29uc3QgaW1wdXRlZEZpZWxkczogYW55W10gPSBbXTtcbiAgICBjb25zdCBjb2x1bW5zID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgY29uc3QgayA9IE1hdGgubWluKDUsIE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyAxMCkpOyAvLyBEeW5hbWljIGsgc2VsZWN0aW9uXG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldENvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICBjb25zdCBtaXNzaW5nSW5kaWNlcyA9IGltcHV0ZWREYXRhXG4gICAgICAgIC5tYXAoKHJvdzogYW55LCBpZHg6IG51bWJlcikgPT4gKHsgcm93LCBpZHggfSkpXG4gICAgICAgIC5maWx0ZXIoKHsgcm93IH06IHsgcm93OiBhbnkgfSkgPT4gcm93W3RhcmdldENvbHVtbl0gPT09IG51bGwgfHwgcm93W3RhcmdldENvbHVtbl0gPT09IHVuZGVmaW5lZCB8fCByb3dbdGFyZ2V0Q29sdW1uXSA9PT0gJycpXG4gICAgICAgIC5tYXAoKHsgaWR4IH06IHsgaWR4OiBudW1iZXIgfSkgPT4gaWR4KTtcblxuICAgICAgaWYgKG1pc3NpbmdJbmRpY2VzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IGltcHV0ZWREYXRhLmZpbHRlcigocm93OiBhbnkpID0+XG4gICAgICAgIHJvd1t0YXJnZXRDb2x1bW5dICE9PSBudWxsICYmIHJvd1t0YXJnZXRDb2x1bW5dICE9PSB1bmRlZmluZWQgJiYgcm93W3RhcmdldENvbHVtbl0gIT09ICcnXG4gICAgICApO1xuXG4gICAgICBpZiAodmFsaWREYXRhLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIGZvciAoY29uc3QgbWlzc2luZ0lkeCBvZiBtaXNzaW5nSW5kaWNlcykge1xuICAgICAgICBjb25zdCBtaXNzaW5nUm93ID0gaW1wdXRlZERhdGFbbWlzc2luZ0lkeF07XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VzIHRvIGFsbCB2YWxpZCByb3dzXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IHZhbGlkRGF0YS5tYXAoKHZhbGlkUm93OiBhbnkpID0+ICh7XG4gICAgICAgICAgcm93OiB2YWxpZFJvdyxcbiAgICAgICAgICBkaXN0YW5jZTogdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShtaXNzaW5nUm93LCB2YWxpZFJvdywgY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbCAhPT0gdGFyZ2V0Q29sdW1uKSlcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIEdldCBrIG5lYXJlc3QgbmVpZ2hib3JzXG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IGRpc3RhbmNlc1xuICAgICAgICAgIC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpXG4gICAgICAgICAgLnNsaWNlKDAsIGspO1xuXG4gICAgICAgIC8vIENvbXB1dGUgaW1wdXRlZCB2YWx1ZVxuICAgICAgICBjb25zdCBuZWlnaGJvclZhbHVlcyA9IG5laWdoYm9ycy5tYXAoKG46IGFueSkgPT4gbi5yb3dbdGFyZ2V0Q29sdW1uXSk7XG4gICAgICAgIGxldCBpbXB1dGVkVmFsdWU6IGFueTtcblxuICAgICAgICBpZiAobmVpZ2hib3JWYWx1ZXMuZXZlcnkoKHZhbDogYW55KSA9PiAhaXNOYU4ocGFyc2VGbG9hdCh2YWwpKSkpIHtcbiAgICAgICAgICAvLyBOdW1lcmljIC0gd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAgICAgIGNvbnN0IHdlaWdodHMgPSBuZWlnaGJvcnMubWFwKChuOiBhbnkpID0+IDEgLyAobi5kaXN0YW5jZSArIDFlLTYpKTsgLy8gQWRkIHNtYWxsIGVwc2lsb24gdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgIGNvbnN0IHdlaWdodGVkU3VtID0gbmVpZ2hib3JzLnJlZHVjZSgoc3VtOiBhbnksIG46IGFueSwgaTogYW55KSA9PiBzdW0gKyBwYXJzZUZsb2F0KG4ucm93W3RhcmdldENvbHVtbl0pICogd2VpZ2h0c1tpXSwgMCk7XG4gICAgICAgICAgY29uc3Qgd2VpZ2h0U3VtID0gd2VpZ2h0cy5yZWR1Y2UoKHN1bTogYW55LCB3OiBhbnkpID0+IHN1bSArIHcsIDApO1xuICAgICAgICAgIGltcHV0ZWRWYWx1ZSA9IHdlaWdodGVkU3VtIC8gd2VpZ2h0U3VtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhdGVnb3JpY2FsIC0gbW9kZSBvZiBuZWlnaGJvcnNcbiAgICAgICAgICBjb25zdCBjb3VudHMgPSBuZWlnaGJvclZhbHVlcy5yZWR1Y2UoKGFjYzogYW55LCB2YWw6IGFueSkgPT4ge1xuICAgICAgICAgICAgYWNjW3ZhbF0gPSAoYWNjW3ZhbF0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgaW1wdXRlZFZhbHVlID0gT2JqZWN0LmtleXMoY291bnRzKS5yZWR1Y2UoKGEsIGIpID0+IGNvdW50c1thXSA+IGNvdW50c1tiXSA/IGEgOiBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGltcHV0YXRpb25cbiAgICAgICAgY29uc3QgY29uZmlkZW5jZSA9IE1hdGgubWF4KDAuNSwgMSAtIChuZWlnaGJvcnNbMF0/LmRpc3RhbmNlIHx8IDAuNSkpO1xuICAgICAgICBpbXB1dGVkRGF0YVttaXNzaW5nSWR4XVt0YXJnZXRDb2x1bW5dID0gaW1wdXRlZFZhbHVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbmZpZy5tYXJrX2ltcHV0ZWQpIHtcbiAgICAgICAgICBpbXB1dGVkRGF0YVttaXNzaW5nSWR4XVtgJHt0YXJnZXRDb2x1bW59X2ltcHV0ZWRgXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbXB1dGVkRmllbGRzLnB1c2goe1xuICAgICAgICAgIGZpZWxkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZTogbWlzc2luZ1Jvd1t0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgIGltcHV0ZWRWYWx1ZSxcbiAgICAgICAgICBjb25maWRlbmNlLFxuICAgICAgICAgIG1ldGhvZDogJ2tubicsXG4gICAgICAgICAgcm93SW5kZXg6IG1pc3NpbmdJZHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRJbXB1dGF0aW9uUmVzdWx0KGltcHV0ZWREYXRhLCBpbXB1dGVkRmllbGRzLCBbJ2tubiddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdyZXNzaW9uLWJhc2VkIGltcHV0YXRpb25cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGltcHV0ZVdpdGhSZWdyZXNzaW9uKGRhdGE6IGFueVtdLCBjb25maWc6IEltcHV0YXRpb25Db25maWcpOiBJbXB1dGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBpbXB1dGVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIGNvbnN0IGltcHV0ZWRGaWVsZHM6IGFueVtdID0gW107XG4gICAgY29uc3QgY29sdW1ucyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXRDb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgY29uc3QgbWlzc2luZ0luZGljZXMgPSBpbXB1dGVkRGF0YVxuICAgICAgICAubWFwKChyb3c6IGFueSwgaWR4OiBudW1iZXIpID0+ICh7IHJvdywgaWR4IH0pKVxuICAgICAgICAuZmlsdGVyKCh7IHJvdyB9OiB7IHJvdzogYW55IH0pID0+IHJvd1t0YXJnZXRDb2x1bW5dID09PSBudWxsIHx8IHJvd1t0YXJnZXRDb2x1bW5dID09PSB1bmRlZmluZWQgfHwgcm93W3RhcmdldENvbHVtbl0gPT09ICcnKVxuICAgICAgICAubWFwKCh7IGlkeCB9OiB7IGlkeDogbnVtYmVyIH0pID0+IGlkeCk7XG5cbiAgICAgIGlmIChtaXNzaW5nSW5kaWNlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAvLyBHZXQgcHJlZGljdG9yIGNvbHVtbnMgKGV4Y2x1ZGUgdGFyZ2V0IGFuZCBub24tbnVtZXJpYylcbiAgICAgIGNvbnN0IHByZWRpY3RvckNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjb2wgPT4ge1xuICAgICAgICBpZiAoY29sID09PSB0YXJnZXRDb2x1bW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZGF0YS5tYXAoKHJvdzogYW55KSA9PiByb3dbY29sXSkuZmlsdGVyKCh2YWw6IGFueSkgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gJycpO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDAgJiYgdmFsdWVzLmV2ZXJ5KCh2YWw6IGFueSkgPT4gIWlzTmFOKHBhcnNlRmxvYXQodmFsKSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmVkaWN0b3JDb2x1bW5zLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgIC8vIFByZXBhcmUgdHJhaW5pbmcgZGF0YVxuICAgICAgY29uc3QgdHJhaW5pbmdEYXRhID0gaW1wdXRlZERhdGEuZmlsdGVyKChyb3c6IGFueSkgPT5cbiAgICAgICAgcm93W3RhcmdldENvbHVtbl0gIT09IG51bGwgJiYgcm93W3RhcmdldENvbHVtbl0gIT09IHVuZGVmaW5lZCAmJiByb3dbdGFyZ2V0Q29sdW1uXSAhPT0gJycgJiZcbiAgICAgICAgcHJlZGljdG9yQ29sdW1ucy5ldmVyeSgoY29sOiBhbnkpID0+IHJvd1tjb2xdICE9PSBudWxsICYmIHJvd1tjb2xdICE9PSB1bmRlZmluZWQgJiYgcm93W2NvbF0gIT09ICcnKVxuICAgICAgKTtcblxuICAgICAgaWYgKHRyYWluaW5nRGF0YS5sZW5ndGggPCAzKSBjb250aW51ZTsgLy8gTmVlZCBtaW5pbXVtIGRhdGEgZm9yIHJlZ3Jlc3Npb25cblxuICAgICAgLy8gU2ltcGxlIGxpbmVhciByZWdyZXNzaW9uIGltcGxlbWVudGF0aW9uXG4gICAgICBjb25zdCB7IGNvZWZmaWNpZW50cywgclNxdWFyZWQgfSA9IHRoaXMuc2ltcGxlTGluZWFyUmVncmVzc2lvbih0cmFpbmluZ0RhdGEsIHByZWRpY3RvckNvbHVtbnMsIHRhcmdldENvbHVtbik7XG5cbiAgICAgIC8vIEFwcGx5IHByZWRpY3Rpb25zXG4gICAgICBmb3IgKGNvbnN0IG1pc3NpbmdJZHggb2YgbWlzc2luZ0luZGljZXMpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1JvdyA9IGltcHV0ZWREYXRhW21pc3NpbmdJZHhdO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHByZWRpY3RvcnMgYXJlIGF2YWlsYWJsZVxuICAgICAgICBpZiAocHJlZGljdG9yQ29sdW1ucy5zb21lKGNvbCA9PiBcbiAgICAgICAgICBtaXNzaW5nUm93W2NvbF0gPT09IG51bGwgfHwgbWlzc2luZ1Jvd1tjb2xdID09PSB1bmRlZmluZWQgfHwgbWlzc2luZ1Jvd1tjb2xdID09PSAnJ1xuICAgICAgICApKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIFNraXAgaWYgcHJlZGljdG9ycyBhcmUgbWlzc2luZ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWRpY3RlZCB2YWx1ZVxuICAgICAgICBsZXQgcHJlZGljdGlvbiA9IGNvZWZmaWNpZW50cz8uaW50ZXJjZXB0IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZGljdG9yQ29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHByZWRpY3Rpb24gKz0gKGNvZWZmaWNpZW50cz8uc2xvcGVzW2ldIHx8IDApICogcGFyc2VGbG9hdChtaXNzaW5nUm93W3ByZWRpY3RvckNvbHVtbnNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBNYXRoLm1heCgwLjQsIHJTcXVhcmVkKTtcbiAgICAgICAgaW1wdXRlZERhdGFbbWlzc2luZ0lkeF1bdGFyZ2V0Q29sdW1uXSA9IHByZWRpY3Rpb247XG4gICAgICAgIFxuICAgICAgICBpZiAoY29uZmlnLm1hcmtfaW1wdXRlZCkge1xuICAgICAgICAgIGltcHV0ZWREYXRhW21pc3NpbmdJZHhdW2Ake3RhcmdldENvbHVtbn1faW1wdXRlZGBdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltcHV0ZWRGaWVsZHMucHVzaCh7XG4gICAgICAgICAgZmllbGQ6IHRhcmdldENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBtaXNzaW5nUm93W3RhcmdldENvbHVtbl0sXG4gICAgICAgICAgaW1wdXRlZFZhbHVlOiBwcmVkaWN0aW9uLFxuICAgICAgICAgIGNvbmZpZGVuY2UsXG4gICAgICAgICAgbWV0aG9kOiAncmVncmVzc2lvbicsXG4gICAgICAgICAgcm93SW5kZXg6IG1pc3NpbmdJZHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRJbXB1dGF0aW9uUmVzdWx0KGltcHV0ZWREYXRhLCBpbXB1dGVkRmllbGRzLCBbJ3JlZ3Jlc3Npb24nXSk7XG4gIH1cblxuICAvKipcbiAgICogUmFuZG9tIEZvcmVzdC1zdHlsZSBpbXB1dGF0aW9uXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBpbXB1dGVXaXRoUmFuZG9tRm9yZXN0KGRhdGE6IGFueVtdLCBjb25maWc6IEltcHV0YXRpb25Db25maWcpOiBJbXB1dGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBpbXB1dGVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIGNvbnN0IGltcHV0ZWRGaWVsZHM6IGFueVtdID0gW107XG4gICAgY29uc3QgY29sdW1ucyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuICAgIGNvbnN0IG51bVRyZWVzID0gMTA7IC8vIFNpbXBsaWZpZWQgZm9yZXN0IHNpemVcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0Q29sdW1uIG9mIGNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IG1pc3NpbmdJbmRpY2VzID0gaW1wdXRlZERhdGFcbiAgICAgICAgLm1hcCgocm93OiBhbnksIGlkeDogbnVtYmVyKSA9PiAoeyByb3csIGlkeCB9KSlcbiAgICAgICAgLmZpbHRlcigoeyByb3cgfTogeyByb3c6IGFueSB9KSA9PiByb3dbdGFyZ2V0Q29sdW1uXSA9PT0gbnVsbCB8fCByb3dbdGFyZ2V0Q29sdW1uXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1t0YXJnZXRDb2x1bW5dID09PSAnJylcbiAgICAgICAgLm1hcCgoeyBpZHggfTogeyBpZHg6IG51bWJlciB9KSA9PiBpZHgpO1xuXG4gICAgICBpZiAobWlzc2luZ0luZGljZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgcHJlZGljdG9yQ29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGNvbCA9PiBjb2wgIT09IHRhcmdldENvbHVtbik7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBkZWNpc2lvbiB0cmVlcyAoc2ltcGxpZmllZCByYW5kb20gZm9yZXN0KVxuICAgICAgY29uc3QgdHJlZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbnVtVHJlZXM7IHQrKykge1xuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy5idWlsZFNpbXBsZURlY2lzaW9uVHJlZShpbXB1dGVkRGF0YSwgcHJlZGljdG9yQ29sdW1ucywgdGFyZ2V0Q29sdW1uKTtcbiAgICAgICAgaWYgKHRyZWUpIHRyZWVzLnB1c2godHJlZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmVlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAvLyBBcHBseSBlbnNlbWJsZSBwcmVkaWN0aW9uc1xuICAgICAgZm9yIChjb25zdCBtaXNzaW5nSWR4IG9mIG1pc3NpbmdJbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdSb3cgPSBpbXB1dGVkRGF0YVttaXNzaW5nSWR4XTtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbnMgPSB0cmVlcy5tYXAodHJlZSA9PiB0aGlzLnByZWRpY3RXaXRoVHJlZSh0cmVlLCBtaXNzaW5nUm93KSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgaW1wdXRlZFZhbHVlOiBhbnk7XG4gICAgICAgIGlmIChwcmVkaWN0aW9ucy5ldmVyeShwID0+ICFpc05hTihwYXJzZUZsb2F0KHApKSkpIHtcbiAgICAgICAgICAvLyBOdW1lcmljIC0gYXZlcmFnZVxuICAgICAgICAgIGltcHV0ZWRWYWx1ZSA9IHByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwYXJzZUZsb2F0KHApLCAwKSAvIHByZWRpY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXRlZ29yaWNhbCAtIG1vZGVcbiAgICAgICAgICBjb25zdCBjb3VudHMgPSBwcmVkaWN0aW9ucy5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gICAgICAgICAgICBhY2NbdmFsXSA9IChhY2NbdmFsXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICBpbXB1dGVkVmFsdWUgPSBPYmplY3Qua2V5cyhjb3VudHMpLnJlZHVjZSgoYSwgYikgPT4gY291bnRzW2FdID4gY291bnRzW2JdID8gYSA6IGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlkZW5jZSA9IE1hdGgubWluKDAuOSwgMC41ICsgKHRyZWVzLmxlbmd0aCAvIG51bVRyZWVzKSAqIDAuNCk7XG4gICAgICAgIGltcHV0ZWREYXRhW21pc3NpbmdJZHhdW3RhcmdldENvbHVtbl0gPSBpbXB1dGVkVmFsdWU7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29uZmlnLm1hcmtfaW1wdXRlZCkge1xuICAgICAgICAgIGltcHV0ZWREYXRhW21pc3NpbmdJZHhdW2Ake3RhcmdldENvbHVtbn1faW1wdXRlZGBdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltcHV0ZWRGaWVsZHMucHVzaCh7XG4gICAgICAgICAgZmllbGQ6IHRhcmdldENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBtaXNzaW5nUm93W3RhcmdldENvbHVtbl0sXG4gICAgICAgICAgaW1wdXRlZFZhbHVlLFxuICAgICAgICAgIGNvbmZpZGVuY2UsXG4gICAgICAgICAgbWV0aG9kOiAncmFuZG9tX2ZvcmVzdCcsXG4gICAgICAgICAgcm93SW5kZXg6IG1pc3NpbmdJZHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRJbXB1dGF0aW9uUmVzdWx0KGltcHV0ZWREYXRhLCBpbXB1dGVkRmllbGRzLCBbJ3JhbmRvbV9mb3Jlc3QnXSk7XG4gIH1cblxuICAvKipcbiAgICogTmV1cmFsIE5ldHdvcmstYmFzZWQgaW1wdXRhdGlvbiAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBHQUlOIGNvbmNlcHQpXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyBpbXB1dGVXaXRoTmV1cmFsTmV0d29yayhkYXRhOiBhbnlbXSwgY29uZmlnOiBJbXB1dGF0aW9uQ29uZmlnKTogUHJvbWlzZTxJbXB1dGF0aW9uUmVzdWx0PiB7XG4gICAgLy8gU2ltcGxpZmllZCBuZXVyYWwgbmV0d29yayBhcHByb2FjaCAtIGluIHByb2R1Y3Rpb24sIHdvdWxkIHVzZSBUZW5zb3JGbG93LmpzXG4gICAgY29uc3QgaW1wdXRlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICBjb25zdCBpbXB1dGVkRmllbGRzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcblxuICAgIC8vIENvbnZlcnQgdG8gbnVtZXJpYyBtYXRyaXggZm9yIG5ldXJhbCBuZXR3b3JrIHByb2Nlc3NpbmdcbiAgICBjb25zdCB7IG1hdHJpeCwgY29sdW1uSW5mbyB9ID0gdGhpcy5wcmVwYXJlRGF0YU1hdHJpeChkYXRhLCBjb2x1bW5zKTtcbiAgICBcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGRJbXB1dGF0aW9uUmVzdWx0KGltcHV0ZWREYXRhLCBpbXB1dGVkRmllbGRzLCBbJ25ldXJhbF9uZXR3b3JrJ10pO1xuICAgIH1cblxuICAgIC8vIFNpbXBsZSBhdXRvZW5jb2Rlci1zdHlsZSBpbXB1dGF0aW9uXG4gICAgZm9yIChsZXQgY29sSWR4ID0gMDsgY29sSWR4IDwgY29sdW1ucy5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSBjb2x1bW5zW2NvbElkeF07XG4gICAgICBjb25zdCBtaXNzaW5nUm93cyA9IG1hdHJpeFxuICAgICAgICAubWFwKChyb3c6IGFueSwgaWR4OiBudW1iZXIpID0+ICh7IHJvdywgaWR4IH0pKVxuICAgICAgICAuZmlsdGVyKCh7IHJvdyB9OiB7IHJvdzogYW55IH0pID0+IGlzTmFOKHJvd1tjb2xJZHhdKSlcbiAgICAgICAgLm1hcCgoeyBpZHggfTogeyBpZHg6IG51bWJlciB9KSA9PiBpZHgpO1xuXG4gICAgICBpZiAobWlzc2luZ1Jvd3MubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgLy8gVXNlIG90aGVyIGNvbHVtbnMgdG8gcHJlZGljdCBtaXNzaW5nIHZhbHVlc1xuICAgICAgY29uc3QgY29tcGxldGVSb3dzID0gbWF0cml4LmZpbHRlcigocm93OiBhbnkpID0+ICFpc05hTihyb3dbY29sSWR4XSkpO1xuICAgICAgaWYgKGNvbXBsZXRlUm93cy5sZW5ndGggPCAzKSBjb250aW51ZTtcblxuICAgICAgLy8gU2ltcGxpZmllZCBuZXVyYWwgbmV0d29yayBwcmVkaWN0aW9uICh3b3VsZCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbCBOTiBpbiBwcm9kdWN0aW9uKVxuICAgICAgZm9yIChjb25zdCBtaXNzaW5nUm93SWR4IG9mIG1pc3NpbmdSb3dzKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdSb3cgPSBtYXRyaXhbbWlzc2luZ1Jvd0lkeF07XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gW107XG5cbiAgICAgICAgLy8gRmluZCBzaW1pbGFyIGNvbXBsZXRlIHJvd3MgYmFzZWQgb24gYXZhaWxhYmxlIGZlYXR1cmVzXG4gICAgICAgIGZvciAoY29uc3QgY29tcGxldGVSb3cgb2YgY29tcGxldGVSb3dzKSB7XG4gICAgICAgICAgbGV0IHNpbWlsYXJpdHkgPSAwO1xuICAgICAgICAgIGxldCB2YWxpZENvbXBhcmlzb25zID0gMDtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgIT09IGNvbElkeCAmJiAhaXNOYU4obWlzc2luZ1Jvd1tpXSkgJiYgIWlzTmFOKGNvbXBsZXRlUm93W2ldKSkge1xuICAgICAgICAgICAgICBzaW1pbGFyaXR5ICs9IDEgLSBNYXRoLmFicyhtaXNzaW5nUm93W2ldIC0gY29tcGxldGVSb3dbaV0pIC8gKDEgKyBNYXRoLmFicyhtaXNzaW5nUm93W2ldKSArIE1hdGguYWJzKGNvbXBsZXRlUm93W2ldKSk7XG4gICAgICAgICAgICAgIHZhbGlkQ29tcGFyaXNvbnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsaWRDb21wYXJpc29ucyA+IDApIHtcbiAgICAgICAgICAgIHByZWRpY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICB2YWx1ZTogY29tcGxldGVSb3dbY29sSWR4XSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiBzaW1pbGFyaXR5IC8gdmFsaWRDb21wYXJpc29uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY3Rpb25zLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgLy8gV2VpZ2h0ZWQgYXZlcmFnZSBwcmVkaWN0aW9uXG4gICAgICAgIGNvbnN0IHRvdGFsV2VpZ2h0ID0gcHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAud2VpZ2h0LCAwKTtcbiAgICAgICAgbGV0IGltcHV0ZWRWYWx1ZSA9IHByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnZhbHVlICogcC53ZWlnaHQsIDApIC8gdG90YWxXZWlnaHQ7XG5cbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIG9yaWdpbmFsIHNjYWxlIGlmIG5lZWRlZFxuICAgICAgICBpZiAoY29sdW1uSW5mb1tjb2xJZHhdLmlzTm9ybWFsaXplZCkge1xuICAgICAgICAgIGltcHV0ZWRWYWx1ZSA9IGltcHV0ZWRWYWx1ZSAqIChjb2x1bW5JbmZvW2NvbElkeF0ubWF4IC0gY29sdW1uSW5mb1tjb2xJZHhdLm1pbikgKyBjb2x1bW5JbmZvW2NvbElkeF0ubWluO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgdG8gb3JpZ2luYWwgZGF0YVxuICAgICAgICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5taW4oMC45NSwgTWF0aC5tYXgoMC42LCB0b3RhbFdlaWdodCAvIHByZWRpY3Rpb25zLmxlbmd0aCkpO1xuICAgICAgICBpbXB1dGVkRGF0YVttaXNzaW5nUm93SWR4XVt0YXJnZXRDb2x1bW5dID0gY29sdW1uSW5mb1tjb2xJZHhdLmlzTnVtZXJpYyA/IGltcHV0ZWRWYWx1ZSA6IGNvbHVtbkluZm9bY29sSWR4XS52YWx1ZU1hcFtNYXRoLnJvdW5kKGltcHV0ZWRWYWx1ZSldO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbmZpZy5tYXJrX2ltcHV0ZWQpIHtcbiAgICAgICAgICBpbXB1dGVkRGF0YVttaXNzaW5nUm93SWR4XVtgJHt0YXJnZXRDb2x1bW59X2ltcHV0ZWRgXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbXB1dGVkRmllbGRzLnB1c2goe1xuICAgICAgICAgIGZpZWxkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZTogZGF0YVttaXNzaW5nUm93SWR4XVt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgIGltcHV0ZWRWYWx1ZTogaW1wdXRlZERhdGFbbWlzc2luZ1Jvd0lkeF1bdGFyZ2V0Q29sdW1uXSxcbiAgICAgICAgICBjb25maWRlbmNlLFxuICAgICAgICAgIG1ldGhvZDogJ25ldXJhbF9uZXR3b3JrJyxcbiAgICAgICAgICByb3dJbmRleDogbWlzc2luZ1Jvd0lkeFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZEltcHV0YXRpb25SZXN1bHQoaW1wdXRlZERhdGEsIGltcHV0ZWRGaWVsZHMsIFsnbmV1cmFsX25ldHdvcmsnXSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGUgSW1wdXRhdGlvbiBieSBDaGFpbmVkIEVxdWF0aW9ucyAoTUlDRSlcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGltcHV0ZVdpdGhNSUNFKGRhdGE6IGFueVtdLCBjb25maWc6IEltcHV0YXRpb25Db25maWcpOiBJbXB1dGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBpbXB1dGVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIGNvbnN0IGltcHV0ZWRGaWVsZHM6IGFueVtdID0gW107XG4gICAgY29uc3QgY29sdW1ucyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBjb25maWcubWF4X2l0ZXJhdGlvbnM7XG5cbiAgICAvLyBJbml0aWFsaXplIG1pc3NpbmcgdmFsdWVzIHdpdGggbWVhbi9tb2RlXG4gICAgdGhpcy5pbml0aWFsaXplTWlzc2luZ1ZhbHVlcyhpbXB1dGVkRGF0YSwgY29sdW1ucyk7XG5cbiAgICAvLyBJdGVyYXRpdmUgaW1wdXRhdGlvblxuICAgIGZvciAobGV0IGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IHRhcmdldENvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdJbmRpY2VzID0gZGF0YVxuICAgICAgICAgIC5tYXAoKHJvdzogYW55LCBpZHg6IG51bWJlcikgPT4gKHsgcm93LCBpZHggfSkpXG4gICAgICAgICAgLmZpbHRlcigoeyByb3cgfTogeyByb3c6IGFueSB9KSA9PiByb3dbdGFyZ2V0Q29sdW1uXSA9PT0gbnVsbCB8fCByb3dbdGFyZ2V0Q29sdW1uXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1t0YXJnZXRDb2x1bW5dID09PSAnJylcbiAgICAgICAgICAubWFwKCh7IGlkeCB9OiB7IGlkeDogbnVtYmVyIH0pID0+IGlkeCk7XG5cbiAgICAgICAgaWYgKG1pc3NpbmdJbmRpY2VzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbCAhPT0gdGFyZ2V0Q29sdW1uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSByZWdyZXNzaW9uIHRvIHByZWRpY3QgbWlzc2luZyB2YWx1ZXNcbiAgICAgICAgY29uc3QgeyBjb2VmZmljaWVudHMgfSA9IHRoaXMuc2ltcGxlTGluZWFyUmVncmVzc2lvbihcbiAgICAgICAgICBpbXB1dGVkRGF0YS5maWx0ZXIoKF86IGFueSwgaWR4OiBudW1iZXIpID0+ICFtaXNzaW5nSW5kaWNlcy5pbmNsdWRlcyhpZHgpKSxcbiAgICAgICAgICBvdGhlckNvbHVtbnMuZmlsdGVyKGNvbCA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBpbXB1dGVkRGF0YS5tYXAoKHJvdzogYW55KSA9PiByb3dbY29sXSkuZmlsdGVyKCh2YWw6IGFueSkgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gJycpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwICYmIHZhbHVlcy5ldmVyeSgodmFsOiBhbnkpID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0YXJnZXRDb2x1bW5cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWNvZWZmaWNpZW50cykgY29udGludWU7XG5cbiAgICAgICAgLy8gQXBwbHkgbmV3IHByZWRpY3Rpb25zXG4gICAgICAgIGZvciAoY29uc3QgbWlzc2luZ0lkeCBvZiBtaXNzaW5nSW5kaWNlcykge1xuICAgICAgICAgIGNvbnN0IHJvdyA9IGltcHV0ZWREYXRhW21pc3NpbmdJZHhdO1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGNvZWZmaWNpZW50cy5pbnRlcmNlcHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHZhbGlkUHJlZGljdGlvbiA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2VmZmljaWVudHMuc2xvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xOYW1lID0gb3RoZXJDb2x1bW5zW2ldO1xuICAgICAgICAgICAgaWYgKHJvd1tjb2xOYW1lXSA9PT0gbnVsbCB8fCByb3dbY29sTmFtZV0gPT09IHVuZGVmaW5lZCB8fCBpc05hTihwYXJzZUZsb2F0KHJvd1tjb2xOYW1lXSkpKSB7XG4gICAgICAgICAgICAgIHZhbGlkUHJlZGljdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZhbHVlICs9IGNvZWZmaWNpZW50cy5zbG9wZXNbaV0gKiBwYXJzZUZsb2F0KHJvd1tjb2xOYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbGlkUHJlZGljdGlvbiAmJiByb3dbdGFyZ2V0Q29sdW1uXSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gcm93W3RhcmdldENvbHVtbl07XG4gICAgICAgICAgICByb3dbdGFyZ2V0Q29sdW1uXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIHRoaXMgaW1wdXRhdGlvbiAob25seSBvbiBmaW5hbCBpdGVyYXRpb24pXG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uID09PSBtYXhJdGVyYXRpb25zIC0gMSkge1xuICAgICAgICAgICAgICBpbXB1dGVkRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZpZWxkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZTogZGF0YVttaXNzaW5nSWR4XVt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgIGltcHV0ZWRWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZTogTWF0aC5tYXgoMC43LCAxIC0gaXRlcmF0aW9uIC8gbWF4SXRlcmF0aW9ucyksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnbWljZScsXG4gICAgICAgICAgICAgICAgcm93SW5kZXg6IG1pc3NpbmdJZHhcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXJrX2ltcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByb3dbYCR7dGFyZ2V0Q29sdW1ufV9pbXB1dGVkYF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcmdlbmNlIGNoZWNrXG4gICAgICBpZiAoIWhhc0NoYW5nZXMpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJ1aWxkSW1wdXRhdGlvblJlc3VsdChpbXB1dGVkRGF0YSwgaW1wdXRlZEZpZWxkcywgWydtaWNlJ10pO1xuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHNcblxuICBwcml2YXRlIHN0YXRpYyBhbmFseXplRmllbGRNaXNzaW5nUGF0dGVybihkYXRhOiBhbnlbXSwgZmllbGQ6IHN0cmluZywgYWxsQ29sdW1uczogc3RyaW5nW10pOiBNaXNzaW5nRGF0YVBhdHRlcm4ge1xuICAgIGNvbnN0IG1pc3NpbmdSb3dzID0gZGF0YS5maWx0ZXIocm93ID0+IHJvd1tmaWVsZF0gPT09IG51bGwgfHwgcm93W2ZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tmaWVsZF0gPT09ICcnKTtcbiAgICBjb25zdCBtaXNzaW5nQ291bnQgPSBtaXNzaW5nUm93cy5sZW5ndGg7XG4gICAgY29uc3QgbWlzc2luZ1BlcmNlbnRhZ2UgPSAobWlzc2luZ0NvdW50IC8gZGF0YS5sZW5ndGgpICogMTAwO1xuXG4gICAgLy8gQW5hbHl6ZSBjb3JyZWxhdGlvbnMgd2l0aCBvdGhlciBtaXNzaW5nIGZpZWxkc1xuICAgIGNvbnN0IGNvcnJlbGF0ZWRXaXRoOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHByZWRpY3RvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG90aGVyRmllbGQgb2YgYWxsQ29sdW1ucykge1xuICAgICAgaWYgKG90aGVyRmllbGQgPT09IGZpZWxkKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2hlY2sgY29ycmVsYXRpb24gd2l0aCBtaXNzaW5nIHBhdHRlcm5cbiAgICAgIGNvbnN0IG90aGVyTWlzc2luZ1Jvd3MgPSBkYXRhLmZpbHRlcihyb3cgPT4gcm93W290aGVyRmllbGRdID09PSBudWxsIHx8IHJvd1tvdGhlckZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tvdGhlckZpZWxkXSA9PT0gJycpO1xuICAgICAgY29uc3QgY29tbW9uTWlzc2luZyA9IG1pc3NpbmdSb3dzLmZpbHRlcihyb3cgPT4gb3RoZXJNaXNzaW5nUm93cy5pbmNsdWRlcyhyb3cpKS5sZW5ndGg7XG4gICAgICBcbiAgICAgIGlmIChjb21tb25NaXNzaW5nID4gbWlzc2luZ0NvdW50ICogMC4zKSB7XG4gICAgICAgIGNvcnJlbGF0ZWRXaXRoLnB1c2gob3RoZXJGaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgZmllbGQgY291bGQgcHJlZGljdCB0aGUgbWlzc2luZyBmaWVsZFxuICAgICAgY29uc3QgY29tcGxldGVSb3dzID0gZGF0YS5maWx0ZXIocm93ID0+IFxuICAgICAgICAocm93W2ZpZWxkXSAhPT0gbnVsbCAmJiByb3dbZmllbGRdICE9PSB1bmRlZmluZWQgJiYgcm93W2ZpZWxkXSAhPT0gJycpICYmXG4gICAgICAgIChyb3dbb3RoZXJGaWVsZF0gIT09IG51bGwgJiYgcm93W290aGVyRmllbGRdICE9PSB1bmRlZmluZWQgJiYgcm93W290aGVyRmllbGRdICE9PSAnJylcbiAgICAgICk7XG5cbiAgICAgIGlmIChjb21wbGV0ZVJvd3MubGVuZ3RoID4gZGF0YS5sZW5ndGggKiAwLjUpIHtcbiAgICAgICAgcHJlZGljdG9ycy5wdXNoKG90aGVyRmllbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZSBwYXR0ZXJuIHR5cGVcbiAgICBsZXQgcGF0dGVybjogJ3JhbmRvbScgfCAnc3lzdGVtYXRpYycgfCAnY29ycmVsYXRlZCcgPSAncmFuZG9tJztcbiAgICBpZiAoY29ycmVsYXRlZFdpdGgubGVuZ3RoID4gMCkge1xuICAgICAgcGF0dGVybiA9ICdjb3JyZWxhdGVkJztcbiAgICB9IGVsc2UgaWYgKG1pc3NpbmdQZXJjZW50YWdlID4gNTAgfHwgcHJlZGljdG9ycy5sZW5ndGggPCAyKSB7XG4gICAgICBwYXR0ZXJuID0gJ3N5c3RlbWF0aWMnO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBwcmVkaWN0b3JzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbigwLjksIHByZWRpY3RvcnMubGVuZ3RoIC8gYWxsQ29sdW1ucy5sZW5ndGggKiAyKSA6IDAuMztcblxuICAgIHJldHVybiB7XG4gICAgICBmaWVsZCxcbiAgICAgIG1pc3NpbmdDb3VudCxcbiAgICAgIG1pc3NpbmdQZXJjZW50YWdlLFxuICAgICAgcGF0dGVybixcbiAgICAgIGNvcnJlbGF0ZWRXaXRoLFxuICAgICAgcHJlZGljdG9ycyxcbiAgICAgIGNvbmZpZGVuY2VcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlRGlzdGFuY2Uocm93MTogYW55LCByb3cyOiBhbnksIGNvbHVtbnM6IHN0cmluZ1tdKTogbnVtYmVyIHtcbiAgICBsZXQgZGlzdGFuY2UgPSAwO1xuICAgIGxldCB2YWxpZENvbXBhcmlzb25zID0gMDtcblxuICAgIGZvciAoY29uc3QgY29sIG9mIGNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IHZhbDEgPSByb3cxW2NvbF07XG4gICAgICBjb25zdCB2YWwyID0gcm93Mltjb2xdO1xuXG4gICAgICBpZiAoKHZhbDEgPT09IG51bGwgfHwgdmFsMSA9PT0gdW5kZWZpbmVkIHx8IHZhbDEgPT09ICcnKSB8fCBcbiAgICAgICAgICAodmFsMiA9PT0gbnVsbCB8fCB2YWwyID09PSB1bmRlZmluZWQgfHwgdmFsMiA9PT0gJycpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodmFsMSkpICYmICFpc05hTihwYXJzZUZsb2F0KHZhbDIpKSkge1xuICAgICAgICAvLyBOdW1lcmljIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IG51bTEgPSBwYXJzZUZsb2F0KHZhbDEpO1xuICAgICAgICBjb25zdCBudW0yID0gcGFyc2VGbG9hdCh2YWwyKTtcbiAgICAgICAgZGlzdGFuY2UgKz0gTWF0aC5hYnMobnVtMSAtIG51bTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2F0ZWdvcmljYWwgZGlzdGFuY2VcbiAgICAgICAgZGlzdGFuY2UgKz0gdmFsMSA9PT0gdmFsMiA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgdmFsaWRDb21wYXJpc29ucysrO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZENvbXBhcmlzb25zID4gMCA/IGRpc3RhbmNlIC8gdmFsaWRDb21wYXJpc29ucyA6IEluZmluaXR5O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgc2ltcGxlTGluZWFyUmVncmVzc2lvbihkYXRhOiBhbnlbXSwgcHJlZGljdG9yQ29sdW1uczogc3RyaW5nW10sIHRhcmdldENvbHVtbjogc3RyaW5nKToge1xuICAgIGNvZWZmaWNpZW50czogeyBpbnRlcmNlcHQ6IG51bWJlcjsgc2xvcGVzOiBudW1iZXJbXSB9IHwgbnVsbDtcbiAgICByU3F1YXJlZDogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCB2YWxpZFJvd3MgPSBkYXRhLmZpbHRlcihyb3cgPT4gXG4gICAgICByb3dbdGFyZ2V0Q29sdW1uXSAhPT0gbnVsbCAmJiByb3dbdGFyZ2V0Q29sdW1uXSAhPT0gdW5kZWZpbmVkICYmIHJvd1t0YXJnZXRDb2x1bW5dICE9PSAnJyAmJlxuICAgICAgcHJlZGljdG9yQ29sdW1ucy5ldmVyeShjb2wgPT4gcm93W2NvbF0gIT09IG51bGwgJiYgcm93W2NvbF0gIT09IHVuZGVmaW5lZCAmJiByb3dbY29sXSAhPT0gJycpXG4gICAgKTtcblxuICAgIGlmICh2YWxpZFJvd3MubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIHsgY29lZmZpY2llbnRzOiBudWxsLCByU3F1YXJlZDogMCB9O1xuICAgIH1cblxuICAgIC8vIFNpbXBsZSBtdWx0aXBsZSBsaW5lYXIgcmVncmVzc2lvbiBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHkgPSB2YWxpZFJvd3MubWFwKHJvdyA9PiBwYXJzZUZsb2F0KHJvd1t0YXJnZXRDb2x1bW5dKSk7XG4gICAgY29uc3QgWCA9IHZhbGlkUm93cy5tYXAocm93ID0+IHByZWRpY3RvckNvbHVtbnMubWFwKGNvbCA9PiBwYXJzZUZsb2F0KHJvd1tjb2xdKSkpO1xuXG4gICAgLy8gQWRkIGludGVyY2VwdCBjb2x1bW5cbiAgICBYLmZvckVhY2gocm93ID0+IHJvdy51bnNoaWZ0KDEpKTtcblxuICAgIC8vIENhbGN1bGF0ZSBjb2VmZmljaWVudHMgdXNpbmcgbm9ybWFsIGVxdWF0aW9uOiAoWCdYKV4tMSAqIFgneVxuICAgIGNvbnN0IFhUcmFuc3Bvc2UgPSB0aGlzLnRyYW5zcG9zZU1hdHJpeChYKTtcbiAgICBjb25zdCBYVFggPSB0aGlzLm11bHRpcGx5TWF0cmljZXMoWFRyYW5zcG9zZSwgWCk7XG4gICAgY29uc3QgWFR5ID0gdGhpcy5tdWx0aXBseU1hdHJpeFZlY3RvcihYVHJhbnNwb3NlLCB5KTtcbiAgICBcbiAgICBjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLnNvbHZlTGluZWFyU3lzdGVtKFhUWCwgWFR5KTtcbiAgICBcbiAgICBpZiAoIWNvZWZmaWNpZW50cykge1xuICAgICAgcmV0dXJuIHsgY29lZmZpY2llbnRzOiBudWxsLCByU3F1YXJlZDogMCB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBSLXNxdWFyZWRcbiAgICBjb25zdCBwcmVkaWN0aW9ucyA9IFgubWFwKHJvdyA9PiByb3cucmVkdWNlKChzdW0sIHZhbCwgaWR4KSA9PiBzdW0gKyB2YWwgKiBjb2VmZmljaWVudHNbaWR4XSwgMCkpO1xuICAgIGNvbnN0IHlNZWFuID0geS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8geS5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxTdW1TcXVhcmVzID0geS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyBNYXRoLnBvdyh2YWwgLSB5TWVhbiwgMiksIDApO1xuICAgIGNvbnN0IHJlc2lkdWFsU3VtU3F1YXJlcyA9IHkucmVkdWNlKChzdW0sIHZhbCwgaWR4KSA9PiBzdW0gKyBNYXRoLnBvdyh2YWwgLSBwcmVkaWN0aW9uc1tpZHhdLCAyKSwgMCk7XG4gICAgY29uc3QgclNxdWFyZWQgPSB0b3RhbFN1bVNxdWFyZXMgPiAwID8gMSAtIChyZXNpZHVhbFN1bVNxdWFyZXMgLyB0b3RhbFN1bVNxdWFyZXMpIDogMDtcblxuICAgIHJldHVybiB7XG4gICAgICBjb2VmZmljaWVudHM6IHtcbiAgICAgICAgaW50ZXJjZXB0OiBjb2VmZmljaWVudHNbMF0sXG4gICAgICAgIHNsb3BlczogY29lZmZpY2llbnRzLnNsaWNlKDEpXG4gICAgICB9LFxuICAgICAgclNxdWFyZWQ6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJTcXVhcmVkKSlcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYnVpbGRTaW1wbGVEZWNpc2lvblRyZWUoZGF0YTogYW55W10sIHByZWRpY3RvckNvbHVtbnM6IHN0cmluZ1tdLCB0YXJnZXRDb2x1bW46IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgdmFsaWREYXRhID0gZGF0YS5maWx0ZXIocm93ID0+IFxuICAgICAgcm93W3RhcmdldENvbHVtbl0gIT09IG51bGwgJiYgcm93W3RhcmdldENvbHVtbl0gIT09IHVuZGVmaW5lZCAmJiByb3dbdGFyZ2V0Q29sdW1uXSAhPT0gJycgJiZcbiAgICAgIHByZWRpY3RvckNvbHVtbnMuc29tZShjb2wgPT4gcm93W2NvbF0gIT09IG51bGwgJiYgcm93W2NvbF0gIT09IHVuZGVmaW5lZCAmJiByb3dbY29sXSAhPT0gJycpXG4gICAgKTtcblxuICAgIGlmICh2YWxpZERhdGEubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTaW1wbGUgdHJlZTogZmluZCBiZXN0IHNpbmdsZSBzcGxpdFxuICAgIGxldCBiZXN0U3BsaXQgPSBudWxsO1xuICAgIGxldCBiZXN0U2NvcmUgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGNvbnN0IGNvbCBvZiBwcmVkaWN0b3JDb2x1bW5zKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB2YWxpZERhdGEubWFwKChyb3c6IGFueSkgPT4gcm93W2NvbF0pLmZpbHRlcigodmFsOiBhbnkpID0+IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09ICcnKTtcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgaWYgKHZhbHVlcy5ldmVyeSgodmFsOiBhbnkpID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKSkge1xuICAgICAgICAvLyBOdW1lcmljIHNwbGl0XG4gICAgICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+IHBhcnNlRmxvYXQodmFsKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBjb25zdCBzcGxpdFBvaW50ID0gbnVtVmFsdWVzW01hdGguZmxvb3IobnVtVmFsdWVzLmxlbmd0aCAvIDIpXTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxlZnRHcm91cCA9IHZhbGlkRGF0YS5maWx0ZXIocm93ID0+IHBhcnNlRmxvYXQocm93W2NvbF0pIDw9IHNwbGl0UG9pbnQpO1xuICAgICAgICBjb25zdCByaWdodEdyb3VwID0gdmFsaWREYXRhLmZpbHRlcihyb3cgPT4gcGFyc2VGbG9hdChyb3dbY29sXSkgPiBzcGxpdFBvaW50KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNjb3JlID0gdGhpcy5jYWxjdWxhdGVTcGxpdFNjb3JlKGxlZnRHcm91cCwgcmlnaHRHcm91cCwgdGFyZ2V0Q29sdW1uKTtcbiAgICAgICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgYmVzdFNwbGl0ID0geyBjb2x1bW46IGNvbCwgc3BsaXRQb2ludCwgdHlwZTogJ251bWVyaWMnIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWJlc3RTcGxpdCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBsZWZ0VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUdyb3VwVmFsdWUoXG4gICAgICB2YWxpZERhdGEuZmlsdGVyKHJvdyA9PiBwYXJzZUZsb2F0KHJvd1tiZXN0U3BsaXQuY29sdW1uXSkgPD0gYmVzdFNwbGl0LnNwbGl0UG9pbnQpLFxuICAgICAgdGFyZ2V0Q29sdW1uXG4gICAgKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gdGhpcy5jYWxjdWxhdGVHcm91cFZhbHVlKFxuICAgICAgdmFsaWREYXRhLmZpbHRlcihyb3cgPT4gcGFyc2VGbG9hdChyb3dbYmVzdFNwbGl0LmNvbHVtbl0pID4gYmVzdFNwbGl0LnNwbGl0UG9pbnQpLFxuICAgICAgdGFyZ2V0Q29sdW1uXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzcGxpdDogYmVzdFNwbGl0LFxuICAgICAgbGVmdFZhbHVlLFxuICAgICAgcmlnaHRWYWx1ZVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBwcmVkaWN0V2l0aFRyZWUodHJlZTogYW55LCByb3c6IGFueSk6IGFueSB7XG4gICAgaWYgKCF0cmVlIHx8ICF0cmVlLnNwbGl0KSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHZhbHVlID0gcm93W3RyZWUuc3BsaXQuY29sdW1uXTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKHRyZWUuc3BsaXQudHlwZSA9PT0gJ251bWVyaWMnKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgPD0gdHJlZS5zcGxpdC5zcGxpdFBvaW50ID8gdHJlZS5sZWZ0VmFsdWUgOiB0cmVlLnJpZ2h0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWUubGVmdFZhbHVlOyAvLyBGYWxsYmFja1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlU3BsaXRTY29yZShsZWZ0R3JvdXA6IGFueVtdLCByaWdodEdyb3VwOiBhbnlbXSwgdGFyZ2V0Q29sdW1uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmIChsZWZ0R3JvdXAubGVuZ3RoID09PSAwIHx8IHJpZ2h0R3JvdXAubGVuZ3RoID09PSAwKSByZXR1cm4gLUluZmluaXR5O1xuXG4gICAgY29uc3QgbGVmdFZhbHVlcyA9IGxlZnRHcm91cC5tYXAocm93ID0+IHJvd1t0YXJnZXRDb2x1bW5dKTtcbiAgICBjb25zdCByaWdodFZhbHVlcyA9IHJpZ2h0R3JvdXAubWFwKHJvdyA9PiByb3dbdGFyZ2V0Q29sdW1uXSk7XG4gICAgXG4gICAgLy8gU2ltcGxlIHZhcmlhbmNlIHJlZHVjdGlvbiBzY29yZVxuICAgIGNvbnN0IHRvdGFsVmFyaWFuY2UgPSB0aGlzLmNhbGN1bGF0ZVZhcmlhbmNlKFsuLi5sZWZ0VmFsdWVzLCAuLi5yaWdodFZhbHVlc10pO1xuICAgIGNvbnN0IGxlZnRWYXJpYW5jZSA9IHRoaXMuY2FsY3VsYXRlVmFyaWFuY2UobGVmdFZhbHVlcyk7XG4gICAgY29uc3QgcmlnaHRWYXJpYW5jZSA9IHRoaXMuY2FsY3VsYXRlVmFyaWFuY2UocmlnaHRWYWx1ZXMpO1xuICAgIFxuICAgIGNvbnN0IHdlaWdodGVkVmFyaWFuY2UgPSAobGVmdEdyb3VwLmxlbmd0aCAqIGxlZnRWYXJpYW5jZSArIHJpZ2h0R3JvdXAubGVuZ3RoICogcmlnaHRWYXJpYW5jZSkgLyAobGVmdEdyb3VwLmxlbmd0aCArIHJpZ2h0R3JvdXAubGVuZ3RoKTtcbiAgICBcbiAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAtIHdlaWdodGVkVmFyaWFuY2U7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjYWxjdWxhdGVWYXJpYW5jZSh2YWx1ZXM6IGFueVtdKTogbnVtYmVyIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgXG4gICAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmZpbHRlcih2YWwgPT4gIWlzTmFOKHBhcnNlRmxvYXQodmFsKSkpLm1hcCh2YWwgPT4gcGFyc2VGbG9hdCh2YWwpKTtcbiAgICBpZiAobnVtVmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgXG4gICAgY29uc3QgbWVhbiA9IG51bVZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gbnVtVmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gbnVtVmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIG1lYW4sIDIpLCAwKSAvIG51bVZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjYWxjdWxhdGVHcm91cFZhbHVlKGdyb3VwOiBhbnlbXSwgdGFyZ2V0Q29sdW1uOiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChncm91cC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIFxuICAgIGNvbnN0IHZhbHVlcyA9IGdyb3VwLm1hcChyb3cgPT4gcm93W3RhcmdldENvbHVtbl0pO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodmFsID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKS5tYXAodmFsID0+IHBhcnNlRmxvYXQodmFsKSk7XG4gICAgXG4gICAgaWYgKG51bVZhbHVlcy5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGggJiYgbnVtVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE51bWVyaWMgLSByZXR1cm4gbWVhblxuICAgICAgcmV0dXJuIG51bVZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gbnVtVmFsdWVzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2F0ZWdvcmljYWwgLSByZXR1cm4gbW9kZVxuICAgICAgY29uc3QgY291bnRzID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgYWNjW3ZhbF0gPSAoYWNjW3ZhbF0gfHwgMCkgKyAxO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvdW50cykucmVkdWNlKChhLCBiKSA9PiBjb3VudHNbYV0gPiBjb3VudHNbYl0gPyBhIDogYik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcHJlcGFyZURhdGFNYXRyaXgoZGF0YTogYW55W10sIGNvbHVtbnM6IHN0cmluZ1tdKToge1xuICAgIG1hdHJpeDogbnVtYmVyW11bXTtcbiAgICBjb2x1bW5JbmZvOiBhbnlbXTtcbiAgfSB7XG4gICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbnMubWFwKGNvbCA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLm1hcCgocm93OiBhbnkpID0+IHJvd1tjb2xdKS5maWx0ZXIoKHZhbDogYW55KSA9PiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSAnJyk7XG4gICAgICBjb25zdCBudW1lcmljVmFsdWVzID0gdmFsdWVzLmZpbHRlcih2YWwgPT4gIWlzTmFOKHBhcnNlRmxvYXQodmFsKSkpLm1hcCh2YWwgPT4gcGFyc2VGbG9hdCh2YWwpKTtcbiAgICAgIFxuICAgICAgaWYgKG51bWVyaWNWYWx1ZXMubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoICYmIG51bWVyaWNWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5udW1lcmljVmFsdWVzKTtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4ubnVtZXJpY1ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNOdW1lcmljOiB0cnVlLFxuICAgICAgICAgIGlzTm9ybWFsaXplZDogbWF4ID4gbWluLFxuICAgICAgICAgIG1pbixcbiAgICAgICAgICBtYXgsXG4gICAgICAgICAgdmFsdWVNYXA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpKTtcbiAgICAgICAgY29uc3QgdmFsdWVNYXAgPSB1bmlxdWVWYWx1ZXMucmVkdWNlKChtYXAsIHZhbCwgaWR4KSA9PiB7XG4gICAgICAgICAgbWFwW2lkeF0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzTnVtZXJpYzogZmFsc2UsXG4gICAgICAgICAgaXNOb3JtYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiB1bmlxdWVWYWx1ZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICB2YWx1ZU1hcFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbWF0cml4ID0gZGF0YS5tYXAocm93ID0+IHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoY29sLCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByb3dbY29sXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW5JbmZvW2lkeF0uaXNOdW1lcmljKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbkluZm9baWR4XS5pc05vcm1hbGl6ZWQgPyBcbiAgICAgICAgICAgIChudW0gLSBjb2x1bW5JbmZvW2lkeF0ubWluKSAvIChjb2x1bW5JbmZvW2lkeF0ubWF4IC0gY29sdW1uSW5mb1tpZHhdLm1pbikgOiBcbiAgICAgICAgICAgIG51bTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGNvbHVtbkluZm9baWR4XS52YWx1ZU1hcCk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB1bmlxdWVWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBtYXRyaXgsIGNvbHVtbkluZm8gfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGluaXRpYWxpemVNaXNzaW5nVmFsdWVzKGRhdGE6IGFueVtdLCBjb2x1bW5zOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgY29sIG9mIGNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKChyb3c6IGFueSkgPT4gcm93W2NvbF0pLmZpbHRlcigodmFsOiBhbnkpID0+IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09ICcnKTtcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgbGV0IGRlZmF1bHRWYWx1ZTogYW55O1xuICAgICAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodmFsID0+ICFpc05hTihwYXJzZUZsb2F0KHZhbCkpKS5tYXAodmFsID0+IHBhcnNlRmxvYXQodmFsKSk7XG5cbiAgICAgIGlmIChudW1lcmljVmFsdWVzLmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aCAmJiBudW1lcmljVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVXNlIG1lZGlhbiBmb3IgbnVtZXJpY1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBudW1lcmljVmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihzb3J0ZWQubGVuZ3RoIC8gMik7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHNvcnRlZC5sZW5ndGggJSAyID09PSAwID8gKHNvcnRlZFttaWQgLSAxXSArIHNvcnRlZFttaWRdKSAvIDIgOiBzb3J0ZWRbbWlkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSBtb2RlIGZvciBjYXRlZ29yaWNhbFxuICAgICAgICBjb25zdCBjb3VudHMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgIGFjY1t2YWxdID0gKGFjY1t2YWxdIHx8IDApICsgMTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IE9iamVjdC5rZXlzKGNvdW50cykucmVkdWNlKChhLCBiKSA9PiBjb3VudHNbYV0gPiBjb3VudHNbYl0gPyBhIDogYik7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWUgdG8gbWlzc2luZyBlbnRyaWVzXG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChyb3dbY29sXSA9PT0gbnVsbCB8fCByb3dbY29sXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tjb2xdID09PSAnJykge1xuICAgICAgICAgIHJvd1tjb2xdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgdHJhbnNwb3NlTWF0cml4KG1hdHJpeDogbnVtYmVyW11bXSk6IG51bWJlcltdW10ge1xuICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgcmV0dXJuIG1hdHJpeFswXS5tYXAoKF8sIGNvbEluZGV4KSA9PiBtYXRyaXgubWFwKHJvdyA9PiByb3dbY29sSW5kZXhdKSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBtdWx0aXBseU1hdHJpY2VzKGE6IG51bWJlcltdW10sIGI6IG51bWJlcltdW10pOiBudW1iZXJbXVtdIHtcbiAgICBjb25zdCByZXN1bHQgPSBBcnJheShhLmxlbmd0aCkuZmlsbChudWxsKS5tYXAoKCkgPT4gQXJyYXkoYlswXS5sZW5ndGgpLmZpbGwoMCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHJlc3VsdFtpXVtqXSArPSBhW2ldW2tdICogYltrXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgbXVsdGlwbHlNYXRyaXhWZWN0b3IobWF0cml4OiBudW1iZXJbXVtdLCB2ZWN0b3I6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBtYXRyaXgubWFwKHJvdyA9PiByb3cucmVkdWNlKChzdW0sIHZhbCwgaWR4KSA9PiBzdW0gKyB2YWwgKiB2ZWN0b3JbaWR4XSwgMCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgc29sdmVMaW5lYXJTeXN0ZW0oQTogbnVtYmVyW11bXSwgYjogbnVtYmVyW10pOiBudW1iZXJbXSB8IG51bGwge1xuICAgIC8vIFNpbXBsZSBHYXVzc2lhbiBlbGltaW5hdGlvblxuICAgIGNvbnN0IG4gPSBBLmxlbmd0aDtcbiAgICBjb25zdCBhdWdtZW50ZWQgPSBBLm1hcCgocm93LCBpKSA9PiBbLi4ucm93LCBiW2ldXSk7XG5cbiAgICAvLyBGb3J3YXJkIGVsaW1pbmF0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIC8vIEZpbmQgcGl2b3RcbiAgICAgIGxldCBtYXhSb3cgPSBpO1xuICAgICAgZm9yIChsZXQgayA9IGkgKyAxOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhhdWdtZW50ZWRba11baV0pID4gTWF0aC5hYnMoYXVnbWVudGVkW21heFJvd11baV0pKSB7XG4gICAgICAgICAgbWF4Um93ID0gaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTd2FwIHJvd3NcbiAgICAgIFthdWdtZW50ZWRbaV0sIGF1Z21lbnRlZFttYXhSb3ddXSA9IFthdWdtZW50ZWRbbWF4Um93XSwgYXVnbWVudGVkW2ldXTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHNpbmd1bGFyIG1hdHJpeFxuICAgICAgaWYgKE1hdGguYWJzKGF1Z21lbnRlZFtpXVtpXSkgPCAxZS0xMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxpbWluYXRlXG4gICAgICBmb3IgKGxldCBrID0gaSArIDE7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gYXVnbWVudGVkW2tdW2ldIC8gYXVnbWVudGVkW2ldW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgICBhdWdtZW50ZWRba11bal0gLT0gZmFjdG9yICogYXVnbWVudGVkW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFjayBzdWJzdGl0dXRpb25cbiAgICBjb25zdCBzb2x1dGlvbiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzb2x1dGlvbltpXSA9IGF1Z21lbnRlZFtpXVtuXTtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBzb2x1dGlvbltpXSAtPSBhdWdtZW50ZWRbaV1bal0gKiBzb2x1dGlvbltqXTtcbiAgICAgIH1cbiAgICAgIHNvbHV0aW9uW2ldIC89IGF1Z21lbnRlZFtpXVtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29sdXRpb247XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBidWlsZEltcHV0YXRpb25SZXN1bHQoZGF0YTogYW55W10sIGltcHV0ZWRGaWVsZHM6IGFueVtdLCBtZXRob2RzOiBzdHJpbmdbXSk6IEltcHV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0IHRvdGFsTWlzc2luZyA9IGltcHV0ZWRGaWVsZHMubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsSW1wdXRlZCA9IGltcHV0ZWRGaWVsZHMubGVuZ3RoO1xuICAgIGNvbnN0IGF2ZXJhZ2VDb25maWRlbmNlID0gdG90YWxJbXB1dGVkID4gMCA/IFxuICAgICAgaW1wdXRlZEZpZWxkcy5yZWR1Y2UoKHN1bSwgZmllbGQpID0+IHN1bSArIGZpZWxkLmNvbmZpZGVuY2UsIDApIC8gdG90YWxJbXB1dGVkIDogMDtcblxuICAgIC8vIENhbGN1bGF0ZSBxdWFsaXR5IG1ldHJpY3NcbiAgICBjb25zdCBjb21wbGV0ZW5lc3MgPSAxMDA7IC8vIEFsbCBtaXNzaW5nIGRhdGEgaXMgbm93IGZpbGxlZFxuICAgIGNvbnN0IHJlbGlhYmlsaXR5ID0gYXZlcmFnZUNvbmZpZGVuY2UgKiAxMDA7XG4gICAgY29uc3QgY29uc2lzdGVuY3kgPSBNYXRoLm1pbigxMDAsIDgwICsgKGF2ZXJhZ2VDb25maWRlbmNlICogMjApKTsgLy8gQ29uc2lzdGVuY3kgYmFzZWQgb24gY29uZmlkZW5jZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBpbXB1dGVkRmllbGRzLFxuICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICB0b3RhbE1pc3NpbmcsXG4gICAgICAgIHRvdGFsSW1wdXRlZCxcbiAgICAgICAgbWV0aG9kc1VzZWQ6IG1ldGhvZHMsXG4gICAgICAgIGF2ZXJhZ2VDb25maWRlbmNlXG4gICAgICB9LFxuICAgICAgcXVhbGl0eU1ldHJpY3M6IHtcbiAgICAgICAgY29tcGxldGVuZXNzLFxuICAgICAgICByZWxpYWJpbGl0eSxcbiAgICAgICAgY29uc2lzdGVuY3lcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iXSwibmFtZXMiOlsiQWR2YW5jZWREYXRhSW1wdXRhdGlvbiIsImRpYWdub3NlTWlzc2luZ0RhdGEiLCJkYXRhIiwibGVuZ3RoIiwicGF0dGVybnMiLCJyZWNvbW1lbmRhdGlvbnMiLCJzdWdnZXN0ZWRNZXRob2QiLCJjb2x1bW5zIiwiT2JqZWN0Iiwia2V5cyIsImZpZWxkIiwicGF0dGVybiIsImFuYWx5emVGaWVsZE1pc3NpbmdQYXR0ZXJuIiwibWlzc2luZ0NvdW50IiwicHVzaCIsInRvdGFsTWlzc2luZyIsInJlZHVjZSIsInN1bSIsInAiLCJoaWdoQ29ycmVsYXRpb25QYXR0ZXJucyIsImZpbHRlciIsImNvcnJlbGF0ZWRXaXRoIiwiZXZlcnkiLCJtaXNzaW5nUGVyY2VudGFnZSIsInNvbWUiLCJpbXB1dGVNaXNzaW5nRGF0YSIsImNvbmZpZyIsImRlZmF1bHRDb25maWciLCJtZXRob2QiLCJjb25maWRlbmNlX3RocmVzaG9sZCIsIm1heF9pdGVyYXRpb25zIiwibWFya19pbXB1dGVkIiwiZmluYWxDb25maWciLCJFcnJvciIsImRpYWdub3NpcyIsInJlc3VsdCIsImltcHV0ZVdpdGhNZWFuTWVkaWFuIiwiaW1wdXRlV2l0aEtOTiIsImltcHV0ZVdpdGhSZWdyZXNzaW9uIiwiaW1wdXRlV2l0aFJhbmRvbUZvcmVzdCIsImltcHV0ZVdpdGhOZXVyYWxOZXR3b3JrIiwiaW1wdXRlV2l0aE1JQ0UiLCJzdGF0aXN0aWNzIiwibWV0aG9kc1VzZWQiLCJpbXB1dGVkRGF0YSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImltcHV0ZWRGaWVsZHMiLCJjb2x1bW4iLCJ2YWx1ZXMiLCJtYXAiLCJyb3ciLCJ2YWwiLCJ1bmRlZmluZWQiLCJpbXB1dGVWYWx1ZSIsIm51bWVyaWNWYWx1ZXMiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJjb3VudHMiLCJhY2MiLCJpIiwib3JpZ2luYWxWYWx1ZSIsImltcHV0ZWRWYWx1ZSIsImNvbmZpZGVuY2UiLCJyb3dJbmRleCIsImJ1aWxkSW1wdXRhdGlvblJlc3VsdCIsImsiLCJtaW4iLCJ0YXJnZXRDb2x1bW4iLCJtaXNzaW5nSW5kaWNlcyIsImlkeCIsInZhbGlkRGF0YSIsIm1pc3NpbmdJZHgiLCJtaXNzaW5nUm93IiwiZGlzdGFuY2VzIiwidmFsaWRSb3ciLCJkaXN0YW5jZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwiY29sIiwibmVpZ2hib3JzIiwic2xpY2UiLCJuZWlnaGJvclZhbHVlcyIsIm4iLCJ3ZWlnaHRzIiwid2VpZ2h0ZWRTdW0iLCJ3ZWlnaHRTdW0iLCJ3IiwibWF4IiwicHJlZGljdG9yQ29sdW1ucyIsInRyYWluaW5nRGF0YSIsImNvZWZmaWNpZW50cyIsInJTcXVhcmVkIiwic2ltcGxlTGluZWFyUmVncmVzc2lvbiIsInByZWRpY3Rpb24iLCJpbnRlcmNlcHQiLCJzbG9wZXMiLCJudW1UcmVlcyIsInRyZWVzIiwidCIsInRyZWUiLCJidWlsZFNpbXBsZURlY2lzaW9uVHJlZSIsInByZWRpY3Rpb25zIiwicHJlZGljdFdpdGhUcmVlIiwibWF0cml4IiwiY29sdW1uSW5mbyIsInByZXBhcmVEYXRhTWF0cml4IiwiY29sSWR4IiwibWlzc2luZ1Jvd3MiLCJjb21wbGV0ZVJvd3MiLCJtaXNzaW5nUm93SWR4IiwiY29tcGxldGVSb3ciLCJzaW1pbGFyaXR5IiwidmFsaWRDb21wYXJpc29ucyIsImFicyIsInZhbHVlIiwid2VpZ2h0IiwidG90YWxXZWlnaHQiLCJpc05vcm1hbGl6ZWQiLCJpc051bWVyaWMiLCJ2YWx1ZU1hcCIsInJvdW5kIiwibWF4SXRlcmF0aW9ucyIsImluaXRpYWxpemVNaXNzaW5nVmFsdWVzIiwiaXRlcmF0aW9uIiwiaGFzQ2hhbmdlcyIsIm90aGVyQ29sdW1ucyIsIl8iLCJpbmNsdWRlcyIsIm5ld1ZhbHVlIiwidmFsaWRQcmVkaWN0aW9uIiwiY29sTmFtZSIsIm9sZFZhbHVlIiwiYWxsQ29sdW1ucyIsInByZWRpY3RvcnMiLCJvdGhlckZpZWxkIiwib3RoZXJNaXNzaW5nUm93cyIsImNvbW1vbk1pc3NpbmciLCJyb3cxIiwicm93MiIsInZhbDEiLCJ2YWwyIiwibnVtMSIsIm51bTIiLCJJbmZpbml0eSIsInZhbGlkUm93cyIsInkiLCJYIiwiZm9yRWFjaCIsInVuc2hpZnQiLCJYVHJhbnNwb3NlIiwidHJhbnNwb3NlTWF0cml4IiwiWFRYIiwibXVsdGlwbHlNYXRyaWNlcyIsIlhUeSIsIm11bHRpcGx5TWF0cml4VmVjdG9yIiwic29sdmVMaW5lYXJTeXN0ZW0iLCJ5TWVhbiIsInRvdGFsU3VtU3F1YXJlcyIsInBvdyIsInJlc2lkdWFsU3VtU3F1YXJlcyIsImJlc3RTcGxpdCIsImJlc3RTY29yZSIsIm51bVZhbHVlcyIsInNwbGl0UG9pbnQiLCJsZWZ0R3JvdXAiLCJyaWdodEdyb3VwIiwic2NvcmUiLCJjYWxjdWxhdGVTcGxpdFNjb3JlIiwidHlwZSIsImxlZnRWYWx1ZSIsImNhbGN1bGF0ZUdyb3VwVmFsdWUiLCJyaWdodFZhbHVlIiwic3BsaXQiLCJsZWZ0VmFsdWVzIiwicmlnaHRWYWx1ZXMiLCJ0b3RhbFZhcmlhbmNlIiwiY2FsY3VsYXRlVmFyaWFuY2UiLCJsZWZ0VmFyaWFuY2UiLCJyaWdodFZhcmlhbmNlIiwid2VpZ2h0ZWRWYXJpYW5jZSIsIm1lYW4iLCJncm91cCIsInVuaXF1ZVZhbHVlcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIk5hTiIsIm51bSIsImluZGV4IiwiaW5kZXhPZiIsImRlZmF1bHRWYWx1ZSIsImNvbEluZGV4IiwiZmlsbCIsImoiLCJ2ZWN0b3IiLCJBIiwiYXVnbWVudGVkIiwibWF4Um93IiwiZmFjdG9yIiwic29sdXRpb24iLCJtZXRob2RzIiwidG90YWxJbXB1dGVkIiwiYXZlcmFnZUNvbmZpZGVuY2UiLCJjb21wbGV0ZW5lc3MiLCJyZWxpYWJpbGl0eSIsImNvbnNpc3RlbmN5IiwicXVhbGl0eU1ldHJpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/missing-data-imputation.ts\n");

/***/ }),

/***/ "(rsc)/./types/data-schema.ts":
/*!******************************!*\
  !*** ./types/data-schema.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATA_MAPPING_TEMPLATES: () => (/* binding */ DATA_MAPPING_TEMPLATES)\n/* harmony export */ });\n// Comprehensive data schema types for NetWORX Essentials operational reporting\n// Predefined data mapping templates\nconst DATA_MAPPING_TEMPLATES = [\n    {\n        name: \"Network Footprint & Capacity\",\n        description: \"DC square footage, facility capacity, storage utilization data\",\n        targetCategory: \"operationalReporting\",\n        targetSubcategory: \"networkFootprintCapacity\",\n        mappings: [\n            {\n                sourceColumn: \"DC Sq Ft\",\n                targetField: \"dcSqFt\",\n                dataType: \"number\",\n                required: true\n            },\n            {\n                sourceColumn: \"Facility Capacity\",\n                targetField: \"facilityCapacity\",\n                dataType: \"number\",\n                required: true\n            },\n            {\n                sourceColumn: \"Storage Space Utilized\",\n                targetField: \"storageSpaceUtilized\",\n                dataType: \"number\",\n                required: false\n            },\n            {\n                sourceColumn: \"Dock Door Availability\",\n                targetField: \"dockDoorAvailability\",\n                dataType: \"number\",\n                required: false\n            }\n        ],\n        requiredColumns: [\n            \"DC Sq Ft\",\n            \"Facility Capacity\"\n        ],\n        optionalColumns: [\n            \"Storage Space Utilized\",\n            \"Dock Door Availability\",\n            \"SKU Count per DC\"\n        ]\n    },\n    {\n        name: \"Order & Payment Data\",\n        description: \"Customer orders, freight class, delivery quantities\",\n        targetCategory: \"operationalReporting\",\n        targetSubcategory: \"orderPaymentData\",\n        mappings: [\n            {\n                sourceColumn: \"Customer Name\",\n                targetField: \"customerName\",\n                dataType: \"string\",\n                required: true\n            },\n            {\n                sourceColumn: \"Freight Class\",\n                targetField: \"freightClass\",\n                dataType: \"string\",\n                required: false\n            },\n            {\n                sourceColumn: \"Order Delivery Quantities\",\n                targetField: \"orderDeliveryQuantities\",\n                dataType: \"number\",\n                required: true\n            },\n            {\n                sourceColumn: \"Shipment Weight\",\n                targetField: \"shipmentWeight\",\n                dataType: \"number\",\n                required: false\n            }\n        ],\n        requiredColumns: [\n            \"Customer Name\",\n            \"Order Delivery Quantities\"\n        ],\n        optionalColumns: [\n            \"Freight Class\",\n            \"Shipment Weight\",\n            \"Customer Ship-To Region\"\n        ]\n    },\n    {\n        name: \"Cost & Financial Data\",\n        description: \"Warehouse operating costs, lease costs, inventory carrying costs\",\n        targetCategory: \"businessFinancials\",\n        targetSubcategory: \"costFinancialData\",\n        mappings: [\n            {\n                sourceColumn: \"Warehouse Operating Cost\",\n                targetField: \"warehouseOperatingCost\",\n                dataType: \"number\",\n                required: true\n            },\n            {\n                sourceColumn: \"Lease or Purchase Cost\",\n                targetField: \"leaseOrPurchaseCost\",\n                dataType: \"number\",\n                required: false\n            },\n            {\n                sourceColumn: \"Inventory Carrying Cost\",\n                targetField: \"inventoryCarryingCost\",\n                dataType: \"number\",\n                required: false\n            },\n            {\n                sourceColumn: \"Carrier Cost\",\n                targetField: \"carrierCost\",\n                dataType: \"number\",\n                required: false\n            }\n        ],\n        requiredColumns: [\n            \"Warehouse Operating Cost\"\n        ],\n        optionalColumns: [\n            \"Lease or Purchase Cost\",\n            \"Inventory Carrying Cost\",\n            \"Carrier Cost\"\n        ]\n    },\n    {\n        name: \"Historical Sales Data\",\n        description: \"Historical sales data, customer-level data, SKU sales velocity\",\n        targetCategory: \"salesGrowthTrajectory\",\n        targetSubcategory: \"historicalSalesData\",\n        mappings: [\n            {\n                sourceColumn: \"Historical Sales Data\",\n                targetField: \"historicalSalesData\",\n                dataType: \"number\",\n                required: true\n            },\n            {\n                sourceColumn: \"SKU Sales Velocity\",\n                targetField: \"skuSalesVelocity\",\n                dataType: \"number\",\n                required: false\n            },\n            {\n                sourceColumn: \"Customer Order History\",\n                targetField: \"customerOrderHistory\",\n                dataType: \"number\",\n                required: false\n            },\n            {\n                sourceColumn: \"SKU Total Value\",\n                targetField: \"skuTotalValue\",\n                dataType: \"number\",\n                required: false\n            }\n        ],\n        requiredColumns: [\n            \"Historical Sales Data\"\n        ],\n        optionalColumns: [\n            \"SKU Sales Velocity\",\n            \"Customer Order History\",\n            \"SKU Total Value\"\n        ]\n    }\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi90eXBlcy9kYXRhLXNjaGVtYS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsK0VBQStFO0FBa04vRSxvQ0FBb0M7QUFDN0IsTUFBTUEseUJBQWdEO0lBQzNEO1FBQ0VDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxnQkFBZ0I7UUFDaEJDLG1CQUFtQjtRQUNuQkMsVUFBVTtZQUNSO2dCQUFFQyxjQUFjO2dCQUFZQyxhQUFhO2dCQUFVQyxVQUFVO2dCQUFVQyxVQUFVO1lBQUs7WUFDdEY7Z0JBQUVILGNBQWM7Z0JBQXFCQyxhQUFhO2dCQUFvQkMsVUFBVTtnQkFBVUMsVUFBVTtZQUFLO1lBQ3pHO2dCQUFFSCxjQUFjO2dCQUEwQkMsYUFBYTtnQkFBd0JDLFVBQVU7Z0JBQVVDLFVBQVU7WUFBTTtZQUNuSDtnQkFBRUgsY0FBYztnQkFBMEJDLGFBQWE7Z0JBQXdCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQU07U0FDcEg7UUFDREMsaUJBQWlCO1lBQUM7WUFBWTtTQUFvQjtRQUNsREMsaUJBQWlCO1lBQUM7WUFBMEI7WUFBMEI7U0FBbUI7SUFDM0Y7SUFDQTtRQUNFVixNQUFNO1FBQ05DLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxtQkFBbUI7UUFDbkJDLFVBQVU7WUFDUjtnQkFBRUMsY0FBYztnQkFBaUJDLGFBQWE7Z0JBQWdCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQUs7WUFDakc7Z0JBQUVILGNBQWM7Z0JBQWlCQyxhQUFhO2dCQUFnQkMsVUFBVTtnQkFBVUMsVUFBVTtZQUFNO1lBQ2xHO2dCQUFFSCxjQUFjO2dCQUE2QkMsYUFBYTtnQkFBMkJDLFVBQVU7Z0JBQVVDLFVBQVU7WUFBSztZQUN4SDtnQkFBRUgsY0FBYztnQkFBbUJDLGFBQWE7Z0JBQWtCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQU07U0FDdkc7UUFDREMsaUJBQWlCO1lBQUM7WUFBaUI7U0FBNEI7UUFDL0RDLGlCQUFpQjtZQUFDO1lBQWlCO1lBQW1CO1NBQTBCO0lBQ2xGO0lBQ0E7UUFDRVYsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxVQUFVO1lBQ1I7Z0JBQUVDLGNBQWM7Z0JBQTRCQyxhQUFhO2dCQUEwQkMsVUFBVTtnQkFBVUMsVUFBVTtZQUFLO1lBQ3RIO2dCQUFFSCxjQUFjO2dCQUEwQkMsYUFBYTtnQkFBdUJDLFVBQVU7Z0JBQVVDLFVBQVU7WUFBTTtZQUNsSDtnQkFBRUgsY0FBYztnQkFBMkJDLGFBQWE7Z0JBQXlCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQU07WUFDckg7Z0JBQUVILGNBQWM7Z0JBQWdCQyxhQUFhO2dCQUFlQyxVQUFVO2dCQUFVQyxVQUFVO1lBQU07U0FDakc7UUFDREMsaUJBQWlCO1lBQUM7U0FBMkI7UUFDN0NDLGlCQUFpQjtZQUFDO1lBQTBCO1lBQTJCO1NBQWU7SUFDeEY7SUFDQTtRQUNFVixNQUFNO1FBQ05DLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyxtQkFBbUI7UUFDbkJDLFVBQVU7WUFDUjtnQkFBRUMsY0FBYztnQkFBeUJDLGFBQWE7Z0JBQXVCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQUs7WUFDaEg7Z0JBQUVILGNBQWM7Z0JBQXNCQyxhQUFhO2dCQUFvQkMsVUFBVTtnQkFBVUMsVUFBVTtZQUFNO1lBQzNHO2dCQUFFSCxjQUFjO2dCQUEwQkMsYUFBYTtnQkFBd0JDLFVBQVU7Z0JBQVVDLFVBQVU7WUFBTTtZQUNuSDtnQkFBRUgsY0FBYztnQkFBbUJDLGFBQWE7Z0JBQWlCQyxVQUFVO2dCQUFVQyxVQUFVO1lBQU07U0FDdEc7UUFDREMsaUJBQWlCO1lBQUM7U0FBd0I7UUFDMUNDLGlCQUFpQjtZQUFDO1lBQXNCO1lBQTBCO1NBQWtCO0lBQ3RGO0NBQ0QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25ldHdvcngtZXNzZW50aWFscy8uL3R5cGVzL2RhdGEtc2NoZW1hLnRzPzhjMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29tcHJlaGVuc2l2ZSBkYXRhIHNjaGVtYSB0eXBlcyBmb3IgTmV0V09SWCBFc3NlbnRpYWxzIG9wZXJhdGlvbmFsIHJlcG9ydGluZ1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFGaWVsZCB7XG4gIHByaW1hcnlDYXRlZ29yeTogc3RyaW5nO1xuICBzZWNvbmRhcnlDYXRlZ29yeTogc3RyaW5nO1xuICBkYXRhRmllbGQ6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgdXNlUmVhc29uOiBzdHJpbmc7XG59XG5cbi8vIE9wZXJhdGlvbmFsIFJlcG9ydGluZyBDYXRlZ29yaWVzXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtGb290cHJpbnRDYXBhY2l0eSB7XG4gIGRjU3FGdD86IG51bWJlcjtcbiAgZmFjaWxpdHlDYXBhY2l0eT86IG51bWJlcjtcbiAgc3RvcmFnZVNwYWNlVXRpbGl6ZWQ/OiBudW1iZXI7XG4gIGRvY2tEb29yQXZhaWxhYmlsaXR5PzogbnVtYmVyO1xuICBza3VDb3VudFBlckRjPzogbnVtYmVyO1xuICBzaGlwbWVudHNQZXJEYXk/OiBudW1iZXI7XG4gIHJlY2VpdmVkUGFsbGV0cz86IG51bWJlcjtcbiAgc2hpcHBlZFBhbGxldHM/OiBudW1iZXI7XG4gIGludmVudG9yeVRocm91Z2hwdXQ/OiBudW1iZXI7XG4gIG9yZGVyRnVsZmlsbG1lbnRUaW1lPzogbnVtYmVyO1xuICBpbnZlbnRvcnlWYWx1ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcmRlclBheW1lbnREYXRhIHtcbiAgY3VzdG9tZXJOYW1lPzogc3RyaW5nO1xuICBmcmVpZ2h0Q2xhc3M/OiBzdHJpbmc7XG4gIG9yZGVyRGVsaXZlcnlRdWFudGl0aWVzPzogbnVtYmVyO1xuICBzaGlwbWVudFdlaWdodD86IG51bWJlcjtcbiAgc2hpcG1lbnREaW1lbnNpb25zPzogc3RyaW5nO1xuICBjdXN0b21lclNoaXBUb1JlZ2lvbj86IHN0cmluZztcbiAgb3JkZXJTaGlwTWV0aG9kcz86IHN0cmluZztcbiAgY3VzdG9tZXJPcmRlck51bWJlcj86IG51bWJlcjtcbiAgbG9jYXRpb25TaGlwcGluZ1RvPzogc3RyaW5nO1xuICBza3VEZW1hbmQ/OiBudW1iZXI7XG4gIHRvdGFsTnVtYmVyT2ZVbml0cz86IG51bWJlcjtcbiAgaW52ZW50b3J5T25IYW5kPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yZGVyU2hpcG1lbnREYXRhIHtcbiAgZmFjaWxpdHlEY1JlZ0xvY2F0aW9uPzogc3RyaW5nO1xuICBwdXJjaGFzZU9yZGVyTnVtYmVyPzogbnVtYmVyO1xuICByZWNlaXZlZFNoaXBtZW50TG9jYXRpb25zPzogc3RyaW5nO1xuICBpbmJvdW5kUHVyY2hhc2VPcmRlckRhdGE/OiBzdHJpbmc7XG4gIHNrdVF1YW50aXR5UGVyRWFjaD86IG51bWJlcjtcbiAgb3JkZXJTaGlwbWVudERhdGFGcm9tRGM/OiBzdHJpbmc7XG4gIG9yZGVyRnVsZmlsbG1lbnRUaW1lPzogbnVtYmVyO1xuICBvcmRlckZ1bGZpbGxtZW50Q3ljbGVTb2x1dGlvbj86IHN0cmluZztcbiAgYWN0dWFsU2hpcG1lbnREYXRhRnJvbURjPzogc3RyaW5nO1xuICBvcmRlclJlY2VpdmVkQXREYz86IHN0cmluZztcbiAgY3VzdG9tZXJTaGlwVG9SZWdpb24/OiBzdHJpbmc7XG4gIHJvdXRlRGNUb0N1c3RvbWVyPzogc3RyaW5nO1xuICBza3VEZW1hbmQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uYWxQZXJmb3JtYW5jZU1ldHJpY3Mge1xuICBzaGlwbWVudFF1YWxpdHlQZXJjZW50YWdlPzogbnVtYmVyO1xuICBsaW5lSXRlbUFjY3VyYWN5PzogbnVtYmVyO1xuICBpbnZlbnRvcnlBY2N1cmFjeT86IG51bWJlcjtcbiAgaW52ZW50b3J5Q291bnQ/OiBudW1iZXI7XG4gIG9uVGltZURlbGl2ZXJ5VGltZT86IG51bWJlcjtcbiAgY3VzdG9tZXJDb21wbGFpbnQ/OiBudW1iZXI7XG4gIHNoaXBwZWRQZXJmZWN0T3JkZXI/OiBudW1iZXI7XG4gIHRvdGFsTnVtYmVyT2ZVbml0c09yT3JkZXI/OiBudW1iZXI7XG4gIHNoaXBtZW50T3RkUGVyY2VudGFnZT86IG51bWJlcjtcbiAgaW52ZW50b3J5VHVybnM/OiBudW1iZXI7XG4gIGludmVudG9yeVNlcnZpY2U/OiBudW1iZXI7XG4gIGNhcGFjaXR5VXRpbGl6YXRpb24/OiBudW1iZXI7XG4gIGNhcGFjaXR5VXRpbGl6YXRpb25QZXJjZW50YWdlPzogbnVtYmVyO1xufVxuXG4vLyBCdXNpbmVzcyBGaW5hbmNpYWxzIENhdGVnb3JpZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29zdEZpbmFuY2lhbERhdGEge1xuICB3YXJlaG91c2VPcGVyYXRpbmdDb3N0PzogbnVtYmVyO1xuICBsZWFzZU9yUHVyY2hhc2VDb3N0PzogbnVtYmVyO1xuICBpbnZlbnRvcnlDYXJyeWluZ0Nvc3Q/OiBudW1iZXI7XG4gIGNhcnJpZXJDb3N0PzogbnVtYmVyO1xuICBmcmVpZ2h0Q29zdFBlckxiPzogbnVtYmVyO1xuICBvcGVyYXRpb25hbFN0YXRlbWVudFJldkFjdHVhbEJ1ZGdldD86IHN0cmluZztcbiAgb3BlcmF0aW9uYWxTdGF0ZW1lbnRzPzogc3RyaW5nO1xufVxuXG4vLyBTYWxlcyBHcm93dGggVHJhamVjdG9yeSBDYXRlZ29yaWVzXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcmljYWxTYWxlc0RhdGEge1xuICBoaXN0b3JpY2FsU2FsZXNEYXRhPzogbnVtYmVyO1xuICBoaXN0b3JpY2FsU2FsZXNEYXRhQ3VzdG9tZXJMZXZlbD86IG51bWJlcjtcbiAgc2t1U2FsZXNWZWxvY2l0eT86IG51bWJlcjtcbiAgY3VzdG9tZXJPcmRlckhpc3Rvcnk/OiBudW1iZXI7XG4gIHNrdVRvdGFsVmFsdWU/OiBudW1iZXI7XG4gIHNhbGVzQ2hhbm5lbD86IHN0cmluZztcbiAgZm9yZWNhc3REZW1hbmQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kUHJvamVjdGlvbkZvcmVjYXN0IHtcbiAgY2hhbm5lbFNlZ21lbnRzPzogc3RyaW5nO1xuICBkZW1hbmRGb3JlY2FzdD86IHN0cmluZztcbiAgZm9yZWNhc3RVbml0cz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm93dGhGb3JlY2FzdCB7XG4gIGZvcmVjYXN0VW5pdHM/OiBudW1iZXI7XG59XG5cbi8vIENvbWJpbmVkIG9wZXJhdGlvbmFsIGRhdGEgc3RydWN0dXJlXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdGlvbmFsUmVwb3J0aW5nRGF0YSB7XG4gIG5ldHdvcmtGb290cHJpbnRDYXBhY2l0eT86IE5ldHdvcmtGb290cHJpbnRDYXBhY2l0eTtcbiAgb3JkZXJQYXltZW50RGF0YT86IE9yZGVyUGF5bWVudERhdGE7XG4gIG9yZGVyU2hpcG1lbnREYXRhPzogT3JkZXJTaGlwbWVudERhdGE7XG4gIG9wZXJhdGlvbmFsUGVyZm9ybWFuY2VNZXRyaWNzPzogT3BlcmF0aW9uYWxQZXJmb3JtYW5jZU1ldHJpY3M7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3NGaW5hbmNpYWxzRGF0YSB7XG4gIGNvc3RGaW5hbmNpYWxEYXRhPzogQ29zdEZpbmFuY2lhbERhdGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FsZXNHcm93dGhUcmFqZWN0b3J5RGF0YSB7XG4gIGhpc3RvcmljYWxTYWxlc0RhdGE/OiBIaXN0b3JpY2FsU2FsZXNEYXRhO1xuICBkZW1hbmRQcm9qZWN0aW9uRm9yZWNhc3Q/OiBEZW1hbmRQcm9qZWN0aW9uRm9yZWNhc3Q7XG4gIGdyb3d0aEZvcmVjYXN0PzogR3Jvd3RoRm9yZWNhc3Q7XG59XG5cbi8vIE1hc3RlciBkYXRhIHN0cnVjdHVyZSBmb3IgYWxsIGNhdGVnb3JpZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHJlaGVuc2l2ZU9wZXJhdGlvbmFsRGF0YSB7XG4gIG9wZXJhdGlvbmFsUmVwb3J0aW5nPzogT3BlcmF0aW9uYWxSZXBvcnRpbmdEYXRhO1xuICBidXNpbmVzc0ZpbmFuY2lhbHM/OiBCdXNpbmVzc0ZpbmFuY2lhbHNEYXRhO1xuICBzYWxlc0dyb3d0aFRyYWplY3Rvcnk/OiBTYWxlc0dyb3d0aFRyYWplY3RvcnlEYXRhO1xuICBtZXRhZGF0YT86IHtcbiAgICBmaWxlU291cmNlPzogc3RyaW5nO1xuICAgIGRhdGFRdWFsaXR5PzogRGF0YVF1YWxpdHlNZXRyaWNzO1xuICAgIHZhbGlkYXRpb25SZXN1bHRzPzogVmFsaWRhdGlvblJlc3VsdFtdO1xuICAgIGxhc3RQcm9jZXNzZWQ/OiBzdHJpbmc7XG4gICAgaW1wdXRhdGlvbkluZm8/OiB7XG4gICAgICBtZXRob2RVc2VkOiBzdHJpbmdbXTtcbiAgICAgIHRvdGFsSW1wdXRlZDogbnVtYmVyO1xuICAgICAgYXZlcmFnZUNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICAgIHF1YWxpdHlNZXRyaWNzOiBhbnk7XG4gICAgICBpbXB1dGVkRmllbGRzOiBhbnlbXTtcbiAgICB9O1xuICAgIHByb2R1Y3Rpb25Qcm9jZXNzaW5nPzoge1xuICAgICAgY2FsY3VsYXRpb25SZXN1bHRzOiBhbnk7XG4gICAgICBxdWFsaXR5QXNzZXNzbWVudDogYW55O1xuICAgICAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbiAgICB9O1xuICAgIFtrZXk6IHN0cmluZ106IGFueTsgLy8gQWxsb3cgYWRkaXRpb25hbCBkeW5hbWljIHByb3BlcnRpZXNcbiAgfTtcbn1cblxuLy8gRGF0YSB2YWxpZGF0aW9uIHN0cnVjdHVyZXNcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVF1YWxpdHlNZXRyaWNzIHtcbiAgY29tcGxldGVuZXNzOiBudW1iZXI7IC8vIFBlcmNlbnRhZ2Ugb2YgcmVxdWlyZWQgZmllbGRzIGZpbGxlZFxuICBhY2N1cmFjeTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIG9mIHZhbGlkIHZhbHVlc1xuICBjb25zaXN0ZW5jeTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIG9mIGNvbnNpc3RlbnQgZGF0YSBhY3Jvc3MgZmllbGRzXG4gIHRpbWVsaW5lc3M6IG51bWJlcjsgLy8gRGF0YSBmcmVzaG5lc3Mgc2NvcmVcbiAgdmFsaWRSZWNvcmRzOiBudW1iZXI7XG4gIHRvdGFsUmVjb3JkczogbnVtYmVyO1xuICBtaXNzaW5nRmllbGRzOiBzdHJpbmdbXTtcbiAgaW52YWxpZFZhbHVlczogeyBmaWVsZDogc3RyaW5nOyB2YWx1ZTogYW55OyByZWFzb246IHN0cmluZyB9W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIGZpZWxkOiBzdHJpbmc7XG4gIHZhbHVlOiBhbnk7XG4gIGlzVmFsaWQ6IGJvb2xlYW47XG4gIGVycm9yTWVzc2FnZT86IHN0cmluZztcbiAgc3VnZ2VzdGlvbj86IHN0cmluZztcbn1cblxuLy8gRmlsZSBwcm9jZXNzaW5nIHJlc3VsdHNcbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2luZ1Jlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGRhdGE/OiBDb21wcmVoZW5zaXZlT3BlcmF0aW9uYWxEYXRhO1xuICBlcnJvcnM6IHN0cmluZ1tdO1xuICB3YXJuaW5nczogc3RyaW5nW107XG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbFJvd3M6IG51bWJlcjtcbiAgICB2YWxpZFJvd3M6IG51bWJlcjtcbiAgICBza2lwcGVkUm93czogbnVtYmVyO1xuICAgIGRhdGFRdWFsaXR5OiBEYXRhUXVhbGl0eU1ldHJpY3M7XG4gIH07XG59XG5cbi8vIERhdGEgbWFwcGluZyBjb25maWd1cmF0aW9uIGZvciBmaWxlIGltcG9ydHNcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUZpZWxkTWFwcGluZyB7XG4gIHNvdXJjZUNvbHVtbjogc3RyaW5nO1xuICB0YXJnZXRGaWVsZDogc3RyaW5nO1xuICBkYXRhVHlwZTogJ3N0cmluZycgfCAnbnVtYmVyJyB8ICdib29sZWFuJyB8ICdkYXRlJztcbiAgcmVxdWlyZWQ6IGJvb2xlYW47XG4gIHZhbGlkYXRpb24/OiB7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBwYXR0ZXJuPzogc3RyaW5nO1xuICAgIGFsbG93ZWRWYWx1ZXM/OiBzdHJpbmdbXTtcbiAgfTtcbiAgdHJhbnNmb3JtYXRpb24/OiB7XG4gICAgdHlwZTogJ2xvd2VyY2FzZScgfCAndXBwZXJjYXNlJyB8ICd0cmltJyB8ICdwYXJzZU51bWJlcicgfCAncGFyc2VEYXRlJztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YU1hcHBpbmdUZW1wbGF0ZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgdGFyZ2V0Q2F0ZWdvcnk6ICdvcGVyYXRpb25hbFJlcG9ydGluZycgfCAnYnVzaW5lc3NGaW5hbmNpYWxzJyB8ICdzYWxlc0dyb3d0aFRyYWplY3RvcnknO1xuICB0YXJnZXRTdWJjYXRlZ29yeTogc3RyaW5nO1xuICBtYXBwaW5nczogRGF0YUZpZWxkTWFwcGluZ1tdO1xuICByZXF1aXJlZENvbHVtbnM6IHN0cmluZ1tdO1xuICBvcHRpb25hbENvbHVtbnM6IHN0cmluZ1tdO1xufVxuXG4vLyBQcmVkZWZpbmVkIGRhdGEgbWFwcGluZyB0ZW1wbGF0ZXNcbmV4cG9ydCBjb25zdCBEQVRBX01BUFBJTkdfVEVNUExBVEVTOiBEYXRhTWFwcGluZ1RlbXBsYXRlW10gPSBbXG4gIHtcbiAgICBuYW1lOiAnTmV0d29yayBGb290cHJpbnQgJiBDYXBhY2l0eScsXG4gICAgZGVzY3JpcHRpb246ICdEQyBzcXVhcmUgZm9vdGFnZSwgZmFjaWxpdHkgY2FwYWNpdHksIHN0b3JhZ2UgdXRpbGl6YXRpb24gZGF0YScsXG4gICAgdGFyZ2V0Q2F0ZWdvcnk6ICdvcGVyYXRpb25hbFJlcG9ydGluZycsXG4gICAgdGFyZ2V0U3ViY2F0ZWdvcnk6ICduZXR3b3JrRm9vdHByaW50Q2FwYWNpdHknLFxuICAgIG1hcHBpbmdzOiBbXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0RDIFNxIEZ0JywgdGFyZ2V0RmllbGQ6ICdkY1NxRnQnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0ZhY2lsaXR5IENhcGFjaXR5JywgdGFyZ2V0RmllbGQ6ICdmYWNpbGl0eUNhcGFjaXR5JywgZGF0YVR5cGU6ICdudW1iZXInLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgeyBzb3VyY2VDb2x1bW46ICdTdG9yYWdlIFNwYWNlIFV0aWxpemVkJywgdGFyZ2V0RmllbGQ6ICdzdG9yYWdlU3BhY2VVdGlsaXplZCcsIGRhdGFUeXBlOiAnbnVtYmVyJywgcmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0RvY2sgRG9vciBBdmFpbGFiaWxpdHknLCB0YXJnZXRGaWVsZDogJ2RvY2tEb29yQXZhaWxhYmlsaXR5JywgZGF0YVR5cGU6ICdudW1iZXInLCByZXF1aXJlZDogZmFsc2UgfSxcbiAgICBdLFxuICAgIHJlcXVpcmVkQ29sdW1uczogWydEQyBTcSBGdCcsICdGYWNpbGl0eSBDYXBhY2l0eSddLFxuICAgIG9wdGlvbmFsQ29sdW1uczogWydTdG9yYWdlIFNwYWNlIFV0aWxpemVkJywgJ0RvY2sgRG9vciBBdmFpbGFiaWxpdHknLCAnU0tVIENvdW50IHBlciBEQyddXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnT3JkZXIgJiBQYXltZW50IERhdGEnLFxuICAgIGRlc2NyaXB0aW9uOiAnQ3VzdG9tZXIgb3JkZXJzLCBmcmVpZ2h0IGNsYXNzLCBkZWxpdmVyeSBxdWFudGl0aWVzJyxcbiAgICB0YXJnZXRDYXRlZ29yeTogJ29wZXJhdGlvbmFsUmVwb3J0aW5nJyxcbiAgICB0YXJnZXRTdWJjYXRlZ29yeTogJ29yZGVyUGF5bWVudERhdGEnLFxuICAgIG1hcHBpbmdzOiBbXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0N1c3RvbWVyIE5hbWUnLCB0YXJnZXRGaWVsZDogJ2N1c3RvbWVyTmFtZScsIGRhdGFUeXBlOiAnc3RyaW5nJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgIHsgc291cmNlQ29sdW1uOiAnRnJlaWdodCBDbGFzcycsIHRhcmdldEZpZWxkOiAnZnJlaWdodENsYXNzJywgZGF0YVR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgIHsgc291cmNlQ29sdW1uOiAnT3JkZXIgRGVsaXZlcnkgUXVhbnRpdGllcycsIHRhcmdldEZpZWxkOiAnb3JkZXJEZWxpdmVyeVF1YW50aXRpZXMnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ1NoaXBtZW50IFdlaWdodCcsIHRhcmdldEZpZWxkOiAnc2hpcG1lbnRXZWlnaHQnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIF0sXG4gICAgcmVxdWlyZWRDb2x1bW5zOiBbJ0N1c3RvbWVyIE5hbWUnLCAnT3JkZXIgRGVsaXZlcnkgUXVhbnRpdGllcyddLFxuICAgIG9wdGlvbmFsQ29sdW1uczogWydGcmVpZ2h0IENsYXNzJywgJ1NoaXBtZW50IFdlaWdodCcsICdDdXN0b21lciBTaGlwLVRvIFJlZ2lvbiddXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnQ29zdCAmIEZpbmFuY2lhbCBEYXRhJyxcbiAgICBkZXNjcmlwdGlvbjogJ1dhcmVob3VzZSBvcGVyYXRpbmcgY29zdHMsIGxlYXNlIGNvc3RzLCBpbnZlbnRvcnkgY2FycnlpbmcgY29zdHMnLFxuICAgIHRhcmdldENhdGVnb3J5OiAnYnVzaW5lc3NGaW5hbmNpYWxzJyxcbiAgICB0YXJnZXRTdWJjYXRlZ29yeTogJ2Nvc3RGaW5hbmNpYWxEYXRhJyxcbiAgICBtYXBwaW5nczogW1xuICAgICAgeyBzb3VyY2VDb2x1bW46ICdXYXJlaG91c2UgT3BlcmF0aW5nIENvc3QnLCB0YXJnZXRGaWVsZDogJ3dhcmVob3VzZU9wZXJhdGluZ0Nvc3QnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0xlYXNlIG9yIFB1cmNoYXNlIENvc3QnLCB0YXJnZXRGaWVsZDogJ2xlYXNlT3JQdXJjaGFzZUNvc3QnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgeyBzb3VyY2VDb2x1bW46ICdJbnZlbnRvcnkgQ2FycnlpbmcgQ29zdCcsIHRhcmdldEZpZWxkOiAnaW52ZW50b3J5Q2FycnlpbmdDb3N0JywgZGF0YVR5cGU6ICdudW1iZXInLCByZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgIHsgc291cmNlQ29sdW1uOiAnQ2FycmllciBDb3N0JywgdGFyZ2V0RmllbGQ6ICdjYXJyaWVyQ29zdCcsIGRhdGFUeXBlOiAnbnVtYmVyJywgcmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgXSxcbiAgICByZXF1aXJlZENvbHVtbnM6IFsnV2FyZWhvdXNlIE9wZXJhdGluZyBDb3N0J10sXG4gICAgb3B0aW9uYWxDb2x1bW5zOiBbJ0xlYXNlIG9yIFB1cmNoYXNlIENvc3QnLCAnSW52ZW50b3J5IENhcnJ5aW5nIENvc3QnLCAnQ2FycmllciBDb3N0J11cbiAgfSxcbiAge1xuICAgIG5hbWU6ICdIaXN0b3JpY2FsIFNhbGVzIERhdGEnLFxuICAgIGRlc2NyaXB0aW9uOiAnSGlzdG9yaWNhbCBzYWxlcyBkYXRhLCBjdXN0b21lci1sZXZlbCBkYXRhLCBTS1Ugc2FsZXMgdmVsb2NpdHknLFxuICAgIHRhcmdldENhdGVnb3J5OiAnc2FsZXNHcm93dGhUcmFqZWN0b3J5JyxcbiAgICB0YXJnZXRTdWJjYXRlZ29yeTogJ2hpc3RvcmljYWxTYWxlc0RhdGEnLFxuICAgIG1hcHBpbmdzOiBbXG4gICAgICB7IHNvdXJjZUNvbHVtbjogJ0hpc3RvcmljYWwgU2FsZXMgRGF0YScsIHRhcmdldEZpZWxkOiAnaGlzdG9yaWNhbFNhbGVzRGF0YScsIGRhdGFUeXBlOiAnbnVtYmVyJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgIHsgc291cmNlQ29sdW1uOiAnU0tVIFNhbGVzIFZlbG9jaXR5JywgdGFyZ2V0RmllbGQ6ICdza3VTYWxlc1ZlbG9jaXR5JywgZGF0YVR5cGU6ICdudW1iZXInLCByZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgIHsgc291cmNlQ29sdW1uOiAnQ3VzdG9tZXIgT3JkZXIgSGlzdG9yeScsIHRhcmdldEZpZWxkOiAnY3VzdG9tZXJPcmRlckhpc3RvcnknLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgeyBzb3VyY2VDb2x1bW46ICdTS1UgVG90YWwgVmFsdWUnLCB0YXJnZXRGaWVsZDogJ3NrdVRvdGFsVmFsdWUnLCBkYXRhVHlwZTogJ251bWJlcicsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIF0sXG4gICAgcmVxdWlyZWRDb2x1bW5zOiBbJ0hpc3RvcmljYWwgU2FsZXMgRGF0YSddLFxuICAgIG9wdGlvbmFsQ29sdW1uczogWydTS1UgU2FsZXMgVmVsb2NpdHknLCAnQ3VzdG9tZXIgT3JkZXIgSGlzdG9yeScsICdTS1UgVG90YWwgVmFsdWUnXVxuICB9XG5dO1xuIl0sIm5hbWVzIjpbIkRBVEFfTUFQUElOR19URU1QTEFURVMiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJ0YXJnZXRDYXRlZ29yeSIsInRhcmdldFN1YmNhdGVnb3J5IiwibWFwcGluZ3MiLCJzb3VyY2VDb2x1bW4iLCJ0YXJnZXRGaWVsZCIsImRhdGFUeXBlIiwicmVxdWlyZWQiLCJyZXF1aXJlZENvbHVtbnMiLCJvcHRpb25hbENvbHVtbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./types/data-schema.ts\n");

/***/ })

};
;